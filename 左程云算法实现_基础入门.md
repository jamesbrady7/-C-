# 经典排序算法

## 1. 快速排序算法

### 1.1 Version 1.0

#### 思路

​		荷兰国旗问题1的翻版，每次将当前子区间部分的最后一个元素当作num对子数组进行划分，再不断递归排序即可。明显的缺陷在于，小于和等于num的部分无法快速排清，而要不断递归到最小规模问题才能形成有序数组。

#### 代码

```c plus
// 荷兰国旗问题1，给快速排序1方法用，返回值为int，表示划分完之后，小于等于区域的
// startIndex和endIndex分别表示该需要划分的子区间的范围，即[startIndex, endIndex]
int Partition1(vector<int>& arr, const int& startIndex, const int& endIndex, const int& num)
{
	int Index_Smaller = startIndex;
	for (int i = startIndex; i <= endIndex - 1; i++)
	{
		// 只取到endIndex - 1，最后一个数是作为标准的num
		if (arr[i] <= num)
			Swap(arr, i, Index_Smaller++);
	}
	// 将最后一个数和小于等于区域之外往后的第一个数交换位置
	Swap(arr, endIndex, Index_Smaller);
	// 注意，这里需要--xxxx，就算是返回的时候，也是遵循单目运算符的先后执行规则的
	return (--Index_Smaller);
}

// 快速排序1
void QuickSort1(vector<int>& arr, const int& lowIndex, const int& highIndex)
{
	if (lowIndex >= highIndex) return;
	int index = Partition1(arr, lowIndex, highIndex, arr[highIndex]);
	QuickSort1(arr, lowIndex, index);
	QuickSort1(arr, index + 1, highIndex);
}
```

#### 性质

**时间复杂度：**  $O(N^2)$

**空间复杂度：** $O(N)$



### 1.2 Version 2.0

​		荷兰国旗问题2的翻版，每次将当前子区间部分的最后一个元素当作num对子数组进行划分，不过此时不仅划分小、大子区间，同时也划分和num相同的区域，这个和num相同的区域相当于可以直接有序排列。

#### 思路

荷兰国旗问题1的翻版，每次将当前子区间部分的最后一个元素当作num对子数组进行划分，再不断递归排序即可。

#### 代码

```c plus
// 荷兰国旗问题2，给快速排序23方法用，返回值为<int, int>，分别表示划分完之后的小区域和大区域的第一个Index
// startIndex和endIndex分别表示该需要划分的子区间的范围，即[startIndex, endIndex]
pair<int, int> Partition23(vector<int>& arr, const int& startIndex, const int& endIndex, const int& num)
{
	pair<int, int>result;
	int Index_Smaller = startIndex;
	// 因为我们传入的num其实是子区间的最后一个数（当然，对3.0版本，此时传入的最后一个位置的数其实是我们将子区间上取的随机数换到了该位置）
	// 所以仅排到倒数第二个数
	int Index_Bigger = endIndex - 1;
	for (int i = startIndex; i <= Index_Bigger; i++)
	{
		if (arr[i] < num)
			Swap(arr, i, Index_Smaller++);
		else if (arr[i] > num)
			Swap(arr, i--, Index_Bigger--);
	}
	// 下面的处理是为了让两个子数组可以直接取到返回的Index值
	result.first = Index_Smaller - 1;
	result.second = Index_Bigger + 1;
	// 将最后一个数和大区域中的第一个元素进行交换
	Swap(arr, endIndex, Index_Bigger + 1);
	return result;
}

// 快速排序2
void QuickSort2(vector<int>& arr, const int& lowIndex, const int& highIndex)
{
	// 这里取大于的原因在于：我们为了将子区间全部取为双闭区间，对first-1，对second+1，导致有可能出现下标大于上标的情况
	if (lowIndex >= highIndex) return;
	// 用尾部数字进行划分，得到小区间末位置和大区间初位置
	auto indices = Partition23(arr, lowIndex, highIndex, arr[highIndex]);
	QuickSort2(arr, lowIndex, indices.first);
	QuickSort2(arr, indices.second, highIndex);
}
```

#### 性质

**时间复杂度： $O(N^2)$**

**空间复杂度：** $O(N)$



### 1.3 Version 3.0

#### 思路

针对1.0和2.0中始终取最后一个数作为num的时候会出现最差情况，3.0中选择采用随机位置数作为num的方式，而最终的最差时间复杂度期望能够明显降低。

#### 代码

```c plus
// 快速排序3
void QuickSort3(vector<int>& arr, const int& lowIndex, const int& highIndex)
{
    // 这里取大于的原因在于：我们为了将子区间全部取为双闭区间，对first-1，对second+1，导致有可能出现下标大于上标的情况
	if (lowIndex >= highIndex) return;
	// 和2唯一的区别在于首先将子序列中任意一个数和当前子序列最后一个数交换，由于在该序列内部是完全无序的，所以不用怕打乱顺序
	Swap(arr, RandInt(lowIndex, highIndex), highIndex);
	auto indices = Partition23(arr, lowIndex, highIndex, arr[highIndex]);
	QuickSort3(arr, lowIndex, indices.first);
	QuickSort3(arr, indices.second, highIndex);
}
```

#### 性质

**时间复杂度： $O(N \times logN)$**

**空间复杂度：** $O(logN)$

**注：** 是因为该方法通过递归的方式进行，过程中需要若干空间记录枢轴（num元素）的划分位置，所以需要递归多少次，就需要多少个额外的空间进行压栈。



## 2. 完全二叉树和堆

**注：** 以0为起始下标的情况，孩子和双亲的下标计算关系有所不同：
$$
Index\_LeftSon = 2 \times Index\_Mother+1 \\\\
Index\_RightSon = 2 \times Index\_Mother+2 \\\\
Index\_Mother = \frac{Index\_Son-1}{2}
$$
另外，优先级队列就是堆结构。

### 2.1 堆—Heap Insert

#### 构建思路 

&emsp;&emsp;每次给定一个数，将其不断和双亲结点的大小进行比较并交换，直到满足堆的定义。

#### 代码

```c plus
// Heap Insert操作，即某个数在Index位置，判断它能否向堆的上层移动（也就是向数组的上面移动）
void HeapInsert(vector<int>& arr, const int& index)
{
	int i = index;
	while (arr[i] > arr[(i - 1) / 2])
	{
		// 如果index位置的数比其双亲结点的数大，则向上换
		Swap(arr, i, (i - 1) / 2);
		// 当前数来到了之前双亲位置
		i = (i - 1) / 2;
	}
}
```

#### 性质

**时间复杂度：**$O(logN)$，因为一个数最多要交换它当前深度的次数。



### 2.2 堆—Heapify

&emsp;&emsp;要求给出当前要进行Heapify操作的结点位置，一个指示当前堆的长度的值，然后调整当前结点使得完全二叉树形成堆（设仅可能当前结点引起完全二叉树不满足堆的定义）。

#### 代码

```c plus
// Heapify操作，即某个数在Index位置，判断它能否向堆的下层移动（也就是向数组的后面移动）
void Heapify(vector<int>& arr, const int& index, const int& heapSize)
{
	int i = index;
	// 找出左孩子的下标
	int left = 2 * i + 1;
	while (left < heapSize)
	{
		// 这个判断表示当前位于结点位置还存在左孩子（也就是说还存在孩子）
		// 找出左右孩子中比较大的那一个，另外需要注意没有右孩子的情况
		int largeIndex = arr[left] > arr[left + 1] || left + 1 >= heapSize ? left : left + 1;
		// 如果当前位置已经比左右孩子都大了，可以停止比较，直接break，说明已经到位
		if (arr[i] > arr[largeIndex]) break;
		// 否则将当前结点和孩子进行交换
		Swap(arr, i, largeIndex);
		// 由于进行了交换，用于指示目标结点位置的i变为孩子结点的下标
		i = largeIndex;
		// 求出当前结点位置的左孩子下标
		left = 2 * i + 1;
	}
}
```

#### 性质

**时间复杂度：**$O(logN)$，因为一个数最多要交换当前堆的深度次数。



### 2.3 堆排序

#### 构建思路

&emsp;&emsp;看下面的代码，已经写得很清楚了。

#### 代码

``` c plus
// Heap Insert操作，用于查看index位置的数能否继续向上层移动（大根堆）
void HeapInsert(vector<int>& arr, const int& index)
{
	int i = index;
	while (arr[i] > arr[(i - 1) / 2])
	{
		// 如果index位置的数比其双亲结点的数大，则向上换
		Swap(arr, i, (i - 1) / 2);
		// 当前数来到了之前双亲位置
		i = (i - 1) / 2;
	}
}

// Heapify操作，值得注意的是，此时控制数组大小的并不是arr的size，而是我们人为指定的heapSize（大根堆）
void Heapify(vector<int>& arr, const int& index, const int& heapSize)
{
	int i = index;
	// 找出左孩子的下标
	int left = 2 * i + 1;
	while (left < heapSize)
	{
		// 这个判断表示当前位于结点位置还存在左孩子（也就是说还存在孩子）
		// 找出左右孩子中比较大的那一个，另外需要注意没有右孩子的情况
		int largeIndex = arr[left] > arr[left + 1] || left + 1 >= heapSize ? left : left + 1;
		// 如果当前位置已经比左右孩子都大了，可以停止比较，直接break，说明已经到位
		if (arr[i] > arr[largeIndex]) break;
		// 否则将当前结点和孩子进行交换
		Swap(arr, i, largeIndex);
		// 由于进行了交换，用于指示目标结点位置的i变为孩子结点的下标
		i = largeIndex;
		// 求出当前结点位置的左孩子下标
		left = 2 * i + 1;
	}
}

// 堆排序
void HeapSort(vector<int>& arr)
{
	// 第一步，先要进行大根堆的构造，两种方法
	int ConstructAlgorithm = 1;
	if (ConstructAlgorithm == 1)
	{
		// I. 从第一个结点开始，进行结点的Heap Insert
		for (int i = 1; i < arr.size(); i++)
			// 这种方法构建大根堆的时候，除了第一个结点，其它结点都需要进行Heap Insert操作（一种从下到上的操作）
			HeapInsert(arr, i);
	}
	else
	{
		// II. 从倒数第二层开始，进行结点的Heapify
		for (int i = (arr.size() - 2) / 2; i >= 0; i--)
			// arr.size() - 1表示最后一个元素下标
			// 这种方法构建大根堆的时候，最后一层均不需要进行Heapify操作（一种从上到下的操作）
			Heapify(arr, i, arr.size());
	}
	// 第二步，将第一个结点和最后一个结点（HeapSize指示的最后一个结点，不是arr.size()）交换
	// 由于大根堆的根一定是最大的，所以每次交换，数组从尾部开始变得有序
	// 换完之后，需要对根节点进行Heapify操作，以重新形成堆，这个操作不断进行直到HeapSize为1
	for (int HeapSize = arr.size(); HeapSize > 1; HeapSize--)
	{
		// 取到HeapSize > 1，因为最后一个结点是自己和自己交换，没有意义了
		Swap(arr, HeapSize - 1, 0);
		// 这里一定要-1，不然Heapify可能会使得最后一个已经有序的结果被打乱
		Heapify(arr, 0, HeapSize - 1);
	}
}

void main()
{
	vector<int> arr = RandVector(1, 20, 25);
	cout << "原数组：" << endl;
	ShowVector(arr);
	HeapSort(arr);
	cout << "有序数组：" << endl;
	ShowVector(arr);
	system("pause");
}
```



#### 性质

**时间复杂度：** $O(NlogN)$

分为两步，第一步构建大根堆，这个过程有两种方法，他们的时间复杂度是不同的：

①$O(NlogN)$，只需要看最后一层，明显需要的最大交换次数为
$$
T(N)=\frac{N}{2}\times logN
$$
注意，这种方法对深度越深的结点，其可能执行的最大交换次数越多。

②$O(N)$，此时需要经过一定的推导，但只需要注意，这种方法对深度越深的结点，其可能执行的最大交换次数越少，这就是它优于①的地方，因为结点肯定是随着深度增加而在一层上不断变多的，那么可以知道
$$
T(N)=1 \times logN+2 \times (logN-1)+...+\frac{N}{4} \times 1+\frac{N}{2} \times0\\\
2T(N)=2 \times logN+4 \times (logN-1)+...+\frac{N}{4} \times 2+\frac{N}{2} \times0
$$
上下一减发现是一个关于1/2的等比数列，那么其时间复杂度得证。

第二步，不断将首末元素进行交换，并对交换后的首元素进行Heapify操作，容易看出一种最差的情况，即当前堆为满二叉树，且叶子换上来之后都要做最大次数的Heapify，此时的时间复杂度为
$$
T(N)=\frac{N}{2} \times logN
$$

## 3. 非比较排序

### 3.1 计数排序

 		所有数都分开，而完全不考虑数大小定义的逻辑关系。

### 3.2 基数排序（桶排序）

#### 代码1

``` c plus
// num是给定的数字，d是给定的数位，比如个位的话d = 1，十位d = 2，以此类推
// 那么这个函数的效果是：计算出num在数位d上面的数值
int GetDigit(const int& num, const int& d)
{
	// 除以对应数，再模10，注意，C++中^表示按位异或...
	return (num / int(pow(10, d - 1))) % 10;
}

// 得到arr数组中最大的位数，比如一个数组中最大的数为110000，那么返回的结果为6
int MaxBits(vector<int>& arr)
{
	// 求出数组中的最大值
	int maxNum = *max_element(arr.begin(), arr.end());
	// 初始化一个计数器
	int result = 0;
	while (maxNum != 0)
	{
		// 只要maxNum不为0，则计数器++
		result++;
		// 除以10
		maxNum /= 10;
	}
	return result;
}

// 基数排序，其中digit表示当前arr中的最大位数，直接调用MaxBits来求得即可
// 该函数可以指定排序的具体区间
void RadixSort(vector<int>& arr, const int& L, const int& R, const int& digit)
{
	// 首先，我们需要一个bucket，即桶，我们知道，此时我们用一个分片的数组来代表若干桶
	// 且数组中越靠后的分片对应的桶装数值越大
	// 且该桶数组的大小是我们需要排序的数字个数
	vector<int> bucket(R - L + 1);

	for (int i = 1; i <= digit; i++)
	{
		// 然后，我们需要一个count数组，用于记录每次待排序数要进桶时，各个数的count次数
		// 且这个数组的大小一定是10，下标0~9表示各个位置上的数，对应数值表示待排序数在某个位上的数，小于等于该位置数字的总个数
		// 这个数组放在循环内部，表示每一次进桶都可以重新初始化为0
		vector<int> count(10, 0);
		// 我们数组最大有多少位，就意味着我们要进桶多少次
		// 步骤1，数数
		for (int j = L; j <= R; j++)
		{
			// 此时i就表示当前桶对应的位数
			// GetDigit(arr[L], i)得到当前位的值
			// 由于之前说过count的下标值代表的是具体的数值，而元素代表个数，所以用GetDigit(arr[L], i)作为其下标值
			count[GetDigit(arr[j], i)]++;
		}
		// 步骤2，逐步累加
		for (int j = 1; j < count.size(); j++)
			count[j] = count[j] + count[j - 1];
		// 步骤3，将数组从右往左入桶
		for (int j = R; j >= L; j--)
		{
			// 这里要-1，因为count表示的是个数，-1才是下标
			bucket[count[GetDigit(arr[j], i)] - 1] = arr[j];
			count[GetDigit(arr[j], i)]--;
		}
		// 步骤4，出桶，即将桶中的数据，按从左往右的顺序复制到arr中即可
		for (int j = L, k = 0; j <= R; j++, k++)
		{
			arr[j] = bucket[k];
		}
	}
}

// 最终的基数排序接口
void RadixSort(vector<int>& arr)
{
	// 意味着是在整个数组上进行基数排序
	RadixSort(arr, 0, arr.size() - 1, MaxBits(arr));
}

void main()
{
	vector<int> arr = RandVector(0, 400000, 20);
	cout << "原数组：" << endl;
	ShowVector(arr);
	RadixSort(arr);
	cout << "有序数组：" << endl;
	ShowVector(arr);
	system("pause");
}
```

#### 性质

**适用条件：** 取值范围已知且范围不太大（否则需要开的桶太大了），且这种方法仅适用于某些特定问题（基于数据状况）。

**时间复杂度：** $O(N)$

#### 讨论

​		我个人比较好奇，是否一定要按照从右往左的顺序读上一次排好序的数组，实际上，从右往左读数组，表示从右边开始将元素入桶，而从左往右把桶里的数据往arr里面拷贝，说明是从从左边开始将元素出桶，也就说，先入桶的先出桶，但个人感觉，这个先后并没有什么区别，不妨来模拟一下排序过程：
$$
1:{34,35,27,41,54,63,24,72,29,23}\\\
2:{41,72,63,23,34,54,24,35,27,29}\\\
3:{23,24,27,29,34,35,54,63,72,41}
$$
说实话还是很有关系的，但这个关系并不是当前层桶内的关系，而是为了**维持上一层桶与桶之间的有序关系**，**进而形成该层桶内的有序关系**，这一点视频里面他没讲清楚。由于我们在构建数组的过程中，每个步骤的数组的趋势都是升序，所以从右往左遍历，先遍历大的数（说明它在上一层遍历过程中属于“大桶”），那么对该层来说，与**同一个桶内的元素对比**，它同样应该属于大的位置，所以刚好，现在我们是用对数字的累积关系来标识当前数应该放的位置，所以可以满足需求，当然我们可以对代码稍作修改，使得可以从左边遍历，如下所示：

#### 代码2

``` c plus
// 仅修改入桶时候的操作
// 还是不太方便操作的，因为我们仅用了一个count来统计小于等于某个数值的元素位个数，所以不太方便直接找出某个桶的第一个位置在哪儿
```

## 4. 排序算法的综合评价

### 4.1 总结与比较

​		在某些结构化数据的排序场景是有意义的。

| 排序算法 | 时间复杂度 | 空间复杂度 | 稳定性 |
| :------: | :--------: | :--------: | :----: |
| 选择排序 |  $O(N^2)$  |   $O(1)$   | 不稳定 |
| 冒泡排序 |  $O(N^2)$  |   $O(1)$   |  稳定  |
| 插入排序 |  $O(N^2)$  |   $O(1)$   |  稳定  |
| 归并排序 | $O(NlogN)$ |   $O(N)$   |  稳定  |
| 快速排序 | $O(NlogN)$ | $O(logN)$  | 不稳定 |
|  堆排序  | $O(NlogN)$ |   $O(1)$   | 不稳定 |
|  桶排序  |   $O(N)$   |            |  稳定  |

**注：** 

1. 对归并排序来说，只要在左右子区间比较时，先放入左边子区间的相等数据，则可以保证算法的稳定性，但是对之前的小和问题，在数值相等的时候，优先拷贝右边子区间的数值，则丧失了稳定性；

2. 基于比较的排序，暂时还未发现时间复杂度在 $O(NlogN)$ 以下的；

3. 时间复杂度 $O(NlogN)$ ，空间复杂度小于 $O(NlogN)$ ，并且稳定的算法，暂时还没有。

### 4.2 常见的问题

1.  归并排序的额外空间复杂度可以变成 $O(1)$，但是非常难，不需要掌握，有兴趣可以搜“归并排序内部缓存法“，但是此时算法不再稳定；

2.  ”原地归并排序”的帖子都是垃圾，但会让归并排序的时间复杂度变成 $O(N^2)$ ；
3.  快速排序可以做到稳定性问题，但是非常难，不需要掌握，且会让空间复杂度变为 $O(N)$ ，论文”01 stable“；
4.  所有的改进都不重要，因为目前没有找到时间复杂度 $O(NlogN)$，额外空间复杂度为 $O(1)$，又稳定的排序；
5.  有一道题目，是奇数放在数组左边，偶数放在数组右边，还要求原始的相对次序不变，且要求时间复杂度 $O(N)$ ，以及空间复杂度 $O(1)$ ，思路和快速排序一样，但是拿不下；

6.  综合排序，在整体调度上采用快速排序或者归并排序，但是在小样本量的情况下采用插入排序等（常数系数小，在小样本情况下运行得很快），**感觉采用递归实现的算法特别适宜于采用这种形式**；

``` c plus

```

7.  系统自定义的排序，如果是基础类型的数据，其会采用快速排序，否则会采用归并排序，主要原因就在于稳定性；



# 表

## 1. 哈希表（散列表）

### 概念		

1.  在使用层面，可以理解为一种集合结构，即**UnOrderedMap, UnSortedMap, UnOrderedSet, UnSortedSet**，value有没有并没有关系，都只是key的伴随数据罢了；

2.  哈希表增删改查的时间复杂度是常数时间复杂度 $O(1)$ （比较大的常数）； 

3.  放入哈希表的东西，如果key值是基础类型（包括string类型等），则直接内部按照值传递，内存占用的是该对象的大小，而如果是非基础类型，内部按照引用传递，内存占用的是该对象内存地址的大小，为什么会这么做，一个是因为内存空间的问题，还有一个在于非基础类型之间的比较是比较麻烦的，而就算两个非基础类型之间的数据完全相同，在Hash表中也应当被视作两个不同的key，我们可以用来尝试一下：

``` c plus

```



## 2. 有序表

### 概念

1.  **OrederedMap, OrderedSet** 
2.  不管底层的具体实现机制是什么，只要是有序表，其都具有固定的基本功能和固定的时间复杂度 $O(logN)$：
3. <img src="C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230305230505314.png" alt="image-20230305230505314" style="zoom: 67%;" />
4.  和哈希表的第三点同理，另外，由于有序表要求数据之间有序，所以一定要求用户对非基础类型提供比较器；



## 3. 单链表和双链表

### 简单的题目

1.  分别实现反转单向链表和反转双向链表的函数（主要注意换头操作）；

**要求：** 要求时间复杂度为 $O(N)$，额外空间复杂度为 $O(1)$

2.  打印两个有序链表的公共部分，给定两个有序链表的头指针head1和head2，打印两个链表的公共部分

**要求：** 若两个链表的长度之和为 $N$，要求时间复杂度为 $O(N)$，额外空间复杂度为 $O(1)$

``` c plus
```

3.  面试时链表解题的方法论

   ①对于笔试，不用太在乎空间复杂度，一切为了时间复杂度；

   ②对于面试，时间复杂度依然放在第一位，但是一定要找到空间最省的方法；

   **重要技巧：** ①额外数据结构记录（哈希表等）；②快慢指针。

# 二叉树

## 1. 基本遍历方法

### 1.0 准备工作

```  c plus
TNode* ConstructTree()
{
	// 构造一棵二叉树
	TNode* head = new TNode(5);
	head->left = new TNode(3);
	head->right = new TNode(8);
	head->left->left = new TNode(2);
	head->left->right = new TNode(4);
	head->left->left->left = new TNode(1);
	head->right->left = new TNode(7);
	head->right->left->left = new TNode(6);
	head->right->right = new TNode(10);
	head->right->right->left = new TNode(9);
	head->right->right->right = new TNode(11);
	// 构造的是这样的树
	//                               5
	//                       3                 8
	//                     2   4            7    10
	//                    1                6    9  11
	// 明显的，先序遍历为 5 3 2 1 4 8 7 6 10 9 11
	// 中序遍历为 1 2 3 4 5 6 7 8 9 10 11
	// 后续遍历为 1 2 4 3 6 7 9 11 10 8 5
	return head;
}
```

### 1.1 前序遍历

#### **1.1.1 递归前序遍历**

``` c plus
// 前序遍历，递归实现
void PreOrderRecur1(TNode* head)
{
	if (head == NULL)
		// 说明此时到达叶子结点
		return;
	// 第一次访问到的时候就输出，则为前序遍历
	cout << head->data<<" ";
	PreOrderRecur1(head->left);
	// 该函数完全执行后，第二次访问到这个结点
	PreOrderRecur1(head->right);
	// 该函数完全执行后，第三次访问到这个结点
}
```

#### **1.1.2 用户自己压栈实现前序遍历**

``` c cplus
// 前序遍历，非递归实现，用户压栈实现
void PreOrderRecur2(TNode* head)
{
	if (head == NULL)return;
	stack<TNode*> stk;
	// 压入第一个结点
	stk.push(head);
	while (!stk.empty())
	{
		// 只要栈不为空，就持续执行这个过程
		// 访问栈顶，然后弹出
		cout << stk.top()->data << " ";
		// 弹出结点
		TNode* tmpN = stk.top();
		stk.pop();
		// 一定是先推右结点再推左结点，因为后进的要先出（也就是说左结点先出）
		// 注：非空才能推入，这样到后面才能慢慢将栈置为空
		if (tmpN->right != NULL)stk.push(tmpN->right);
		if (tmpN->left != NULL)stk.push(tmpN->left);
	}
}
```

### 1.2 中序遍历

#### **1.2.1 递归中序遍历**

``` c plus
// 中序遍历，递归实现
void InOrderRecur1(TNode* head)
{
	if (head == NULL)
		// 说明此时到达叶子结点
		return;
	// 第一次访问到的时候就输出，则为前序遍历
	InOrderRecur1(head->left);
	// 该函数完全执行后，第二次访问到这个结点
	cout << head->data << " ";
	InOrderRecur1(head->right);
	// 该函数完全执行后，第三次访问到这个结点
}
```

#### **1.2.2 非递归实现**

**思路：**每棵子树左边界进栈（从上层到下层依次进栈），在依次弹出结点的过程中进行打印，对弹出结点的右树周而复始（即查看当前弹出结点有没有右结点，有的话，就将包括该右结点在内的所有左边界全部压栈，**当然需要注意，是把当前右结点的父节点弹出之后再压入这个左边界**，周而复始）。注：左边界就是沿着当前左节点一直找下去直到找不到。

**原理：**所有的树都可以被左边界分解掉。由于压入结点的时候，是从头部往左边压的，所以弹出过程中，是按照先左再头的顺序进行弹出，而弹出当前树的头部之后，不是要去抓取当前头结点的右边结点继续进行遍历吗，那对每一棵树都实现了左头右，那么自然最终就是中序遍历。

``` c plus
// 中序遍历，非递归实现——左子树分解
void InOrderRecur2(TNode* head)
{
	stack<TNode*> stk;
	while (!stk.empty() || head != NULL)
	{
		if (head != NULL)
		{
			// 如果结点指针head不为空，则一直沿着左边界把所有结点压入栈
			stk.push(head);
			head = head->left;
		}
		else
		{
			// 如果结点指针为空，说明应该弹出结点，并将head指向当前弹出结点的右子结点
			// 比较有意思的是，如果当前弹出结点没有右子结点，此时head依旧指向空，那么下一步循环依旧弹出结点而不会去压入右子节点对应的左边界
			cout << stk.top()->data << " ";
			// 弹出结点
			head = stk.top();
			stk.pop();
			// 指向其右子结点
			head = head->right;
		}
	}
}
```

### 1.3 后序遍历

#### **1.3.1 递归后序遍历**

``` c plus
// 后续遍历，递归实现
void PostOrderRecur1(TNode* head)
{
	if (head == NULL)
		// 说明此时到达叶子结点
		return;
	// 第一次访问到的时候就输出，则为前序遍历
	PostOrderRecur1(head->left);
	// 该函数完全执行后，第二次访问到这个结点
	PostOrderRecur1(head->right);
	// 该函数完全执行后，第三次访问到这个结点
	cout << head->data << " ";
}
```

#### **1.3.2 非递归后序遍历**

**思想：**由于在压栈过程中，先压右结点再压左节点得到的是头左右的遍历顺序，那么如果我们先压左结点再压右结点，此时得到的遍历顺序是头右左，那么如果在弹出元素的时候，用另一个栈收集弹出的元素，并在收集完成后依次将元素弹出栈，此时得到的遍历顺序就是左右中，即后序遍历。

``` c plus
// 后续遍历，非递归实现
void PostOrderRecur2(TNode* head)
{
	if (head == NULL)return;
	stack<TNode*> stk;
	stk.push(head);
	stack<TNode*> cntStk;
	while (!stk.empty())
	{
		TNode* tmpN = stk.top();
		// 不要着急访问，现在是收集过程		
		cntStk.push(tmpN);
		// 一定是先弹出再压入
		stk.pop();
		if (tmpN->left != NULL)stk.push(tmpN->left);
		if (tmpN->right != NULL) stk.push(tmpN->right);
	}
	// 然后依次访问即可
	while (!cntStk.empty())
	{
		cout << cntStk.top()->data << " ";
		cntStk.pop();
	}
}
```

### 1.4 主函数

``` c plus
void main()
{
	// 构造二叉树
	TNode* tN = ConstructTree();
	// 前序遍历二叉树
	cout << "前序遍历结果：" << endl;
	PreOrderRecur1(tN);
	cout << endl;
	cout << "前序遍历——非递归实现结果：" << endl;
	PreOrderRecur2(tN);
	cout << endl;
	// 中序遍历二叉树
	cout << "中序遍历结果：" << endl;
	InOrderRecur1(tN);
	cout << endl;
	// 中序遍历二叉树——非递归实现
	cout << "中序遍历——非递归实现结果：" << endl;
	InOrderRecur2(tN);
	cout << endl;
	// 后续遍历二叉树
	cout << "后续遍历结果：" << endl;
	PostOrderRecur1(tN);
	cout << endl;
	cout << "后序遍历——非递归实现结果：" << endl;
	PostOrderRecur2(tN);
	cout << endl;
	// 注：以上的结果都不会改变主函数里面的tN指针，但是会改变tN指针指向的空间
	system("pause");
}
```

### 1.5 宽度优先遍历

**注：二叉树的深度优先遍历就是先序遍历**

**定义：**宽度优先遍历指的是将二叉树从上到下，每一层按照从左到右的顺序依次遍历

**思路：**准备一个队列，将头结点入队，然后弹出结点，访问并操作数据，并先推入该结点左节点再推入右节点，周而复始直至队列为空

``` c plu
// 宽度优先遍历
void QueueRecur(TNode* head)
{
    // 准备队列
	queue<TNode*> que;
    // 头结点入队
	que.push(head);
	while (!que.empty())
	{
        // 访问结点
		cout << que.front()->data << " ";
        // 弹出结点
		head = que.front();
		que.pop();
        // 非空子结点按左->右顺序入队
		if (head->left != NULL) que.push(head->left);
		if (head->right != NULL) que.push(head->right);
	}
}
```

## 2. 搜索二叉树

​		对每一棵子树，都满足其左子树都比根小，且其右子树比根大。

### 2.1 判断搜索二叉树

**思路：**中序遍历，只要过程中完全升序，当前树一定是搜索二叉树。

**方法1：** 最简单的方法，在递归中序遍历过程中用一个静态队列存储结点的访问情况，然后依次出队，看是否整个过程升序即可。

``` c plus
void CheckProcess1(TNode* head, queue<TNode*>& que)
{
	if (head == NULL) return;
	// 操作过程在中间，完成中序遍历，那么先入队的就是先访问到的
	CheckProcess1(head->left, que);
	que.push(head);
	CheckProcess1(head->right, que);
}

// 检查是否为Binary Search Tree
bool CheckBST1(TNode* head)
{
	queue<TNode*> que;
	CheckProcess1(head,que);
	// 一个preValue来记录之前的值
	int preValue=INT_MIN;
	while (!que.empty())
	{
		if (que.front()->data > preValue)
		{
			preValue = que.front()->data;
			que.pop();
		}
		else
			return false;
	}
	return true;
}
```

**方法2：**采用非递归中序遍历方法，很简单，直接看代码

``` c plus
// 检查是否为Binary Search Tree
bool CheckBST2(TNode* head)
{
	int preValue = INT_MIN;
	stack<TNode*> que;
	while (!que.empty() || head != NULL)
	{
		if (head != NULL)
		{
			que.push(head);
			head = head->left;
		}
		else
		{
			// 弹出队头结点，将head指向其右子树根
			head = que.top()->right;
			if (preValue < que.top()->data)
			{
				preValue = que.top()->data;
				que.pop();
			}
			else
				return false;
		}
	}
	return true;
}
```

**方法3：**采用递归的动态检查方式，逻辑也很简单，直接看代码

``` c plus
// 检查是否为Binary Search Tree
bool CheckBST3(TNode* head)
{
	// 在当前结点为空或为叶子结点的情况下，直接返回true
	if (head == NULL || (head->left == NULL && head->right == NULL))return true;
	// 检查左子树是否是搜索二叉树，若是，检查当前结点和左子结点的关系
	if (CheckBST3(head->left))
	{
		if (head->data < head->left->data)
			return false;
	}
	else
		return false;
	// 检查右子树是否是搜索二叉树，若是，检查当前结点和右子结点的关系（如果有，若没有右子结点，则依然满足搜索二叉树关系）
	if (CheckBST3(head->right))
	{
		if (head->right != NULL && head->data > head->right->data)
			return false;
	}
	else
		return false;
	return true;
}
```

**方法4：**采用递归的动态检查方式，但是适用一个额外的静态变量的方式来记录之前遍历结点的最大值

``` c plus
static int preValue = INT_MIN;
// 检查是否为Binary Search Tree
bool CheckBST4(TNode* head)
{
	// 在当前结点为空或为叶子结点的情况下，直接返回true
	if (head == NULL)return true;
	
	// 相当于先遍历左子树
	if (!CheckBST4(head->left))
		return false;
	// 此时的preValue为左子树上的最大值
	if (head->data > preValue)
		preValue = head->data;
	else
		return false;
	// 然后遍历右子树，在遍历过程中就采用了刚刚用根结点更新过的preValue
	return CheckBST4(head->right);
}
```

**方法5：**采用递归套路的方法求解

``` c plu
struct BSTType
{
	// 要保证所有返回值类型的统一
	int max;
	int min;
	bool isBST;
	BSTType(const int& ma, const int& mi, const bool& isBS) :max(ma), min(mi), isBST(isBS) {};
};
BSTType* CheckBST_process(TNode* head)
{
	if (head == NULL) return NULL;
	bool isBST = true;
	int max_value = head->data;
	int min_value = head->data;

	BSTType* leftReturn = CheckBST_process(head->left);
	BSTType* rightReturn = CheckBST_process(head->right);
	// 由于在本问题中，左边最大值和右边最小值不太好设置成任意数，所以用head->left != NULL来判断其是否有东西
	if (head->left != NULL)
	{
		max_value = max(leftReturn->max, max_value);
		min_value = min(leftReturn->min, min_value);
	}
	if (head->right != NULL)
	{
		max_value = max(rightReturn->max, max_value);
		min_value = min(rightReturn->min, min_value);
	}
	if (head->left != NULL &&
		(
			leftReturn->max >= head->data ||
			!leftReturn->isBST
			))
	{
		// 在左树有东西的情况下，如果左树的最大值比当前结点大，或者左树不是搜索二叉树
		isBST = false;
	}
	if (head->right != NULL &&
		(
			rightReturn->min <= head->data||
			!rightReturn->isBST
			))
	{
		// 在右树有东西的情况下，如果右树的最小值比当前结点小，或者右树不是搜索二叉树
		isBST = false;
	}
	// 释放上一步申请的堆区空间
	delete leftReturn, rightReturn;
	return new BSTType(max_value, min_value, isBST);
}

bool CheckBST5(TNode* head)
{
	if (head == NULL) return true;
	auto rp = CheckBST_process(head);
	bool result = rp->isBST;
	// 释放最后一次判断申请的空间
	delete rp;
	return result;
}
```



### 2.2 判断完全二叉树

**规则：**

1）沿宽度优先遍历（从左至右）；

2）对任意结点，若其存在右孩子，其必然存在左孩子，否则不是完全二叉树；

3）在遍历过程中，若一个结点缺少左右任何一个孩子（包括两个孩子都缺失），其同层的后续结点都必须是叶子结点，否则不是完全二叉树

**构造完全二叉树**

``` c plus
TNode* ConstructCBTTree()
{
	// 构造一棵完全二叉树
	TNode* head = new TNode(5);

	head->left = new TNode(3);
	head->right = new TNode(8);

	head->left->left = new TNode(2);
	head->left->right = new TNode(4);
	head->right->left = new TNode(7);
	head->right->right = new TNode(10);

	head->left->left->left = new TNode(1);
	head->left->left->right = new TNode(3);
	head->left->right->left = new TNode(3);
	head->left->right->right = new TNode(6);
	head->right->left->left = new TNode(6);
	head->right->left->right = new TNode(9);
	head->right->right->left = new TNode(9);
	head->right->right->right = new TNode(11);

	// 构造的是这样的树
	//                               5
	//                       3                 8
	//                     2   4            7    10
	//                    1 3 3 6          6 9  9  11
	return head;
}
```

**检查是否是完全二叉树**

``` c plu
// 检查是否为完全二叉树，用基于队列的宽度优先遍历
bool CheckCBT(TNode* head)
{
	// 用于标记，当前是否已经遇到了仅有左孩子的结点
	bool leaf = false;
	queue<TNode*> que;
	que.push(head);
	while (!que.empty())
	{
		// 弹出队头
		head = que.front();
		que.pop();
		TNode* left = head->left;
		TNode* right = head->right;
		if (
			// 第一条判断表示左孩子为空但右孩子不为空，此时直接返回false
			// 第二条判断表示在已经出现了左右孩子有空的情况下，还有结点有左右孩子，此时也返回false
			(left == NULL && right != NULL) ||
			(!(right == NULL && left == NULL) && leaf == true)
			)
		{
			return false;
		}
		if (left != NULL)
		{
			que.push(left);
		}
		if (right != NULL)
		{
			que.push(right);
		}
		if (left == NULL || right == NULL)
			leaf = true;
	}
	return true;
}

void main()
{
	TNode* tN = ConstructCBTTree();
	cout << "检查，" << (CheckCBT(tN) == true ? "是搜索二叉树" : "不是搜索二叉树") << endl;
	system("pause");
}
```

### 2.3 判断满二叉树

**分析：**现在我们的目的是，统计整个树的深度和结点数，那么只需要从子树里面搜集这两个条件即可

``` c plus
// 检查当前树是否为满二叉树，用递归套路求解
struct FBTType
{
	// 结点个数
	int nodes;
	// 当前层数
	int depth;
	FBTType(const int& n, const int& d) : nodes(n), depth(d) {}
};

// 递归过程
FBTType* CheckFBT_process(TNode* head)
{
	// 这里深度和结点个数的定义非常明确，直接返回0，0即可
	if (head == NULL) return new FBTType(0,0);
	// 这里必须要有两个指针，不然没办法释放空间
	auto leftReturn = CheckFBT_process(head->left);
	auto rightReturn = CheckFBT_process(head->right);
	// 然后记录下需要返回的量，然后就释放空间
	int ln = leftReturn->nodes;
	int rn = rightReturn->nodes;
	int ld = leftReturn->depth;
	int rd = rightReturn->depth;
	delete leftReturn, rightReturn;
	return new FBTType(ln + rn + 1, max(ld, rd) + 1);
}

// 判断是否为满二叉树
bool CheckFBT(TNode* head)
{
	if (head == NULL) return true;
	// 分别创建一个指针和一个额外的栈区变量，一个用于释放原空间，一个用于返回值
	FBTType* rp = CheckFBT_process(head);
	FBTType result = *rp;
	delete rp;
	// 看结点和深度是否满足条件，满足则肯定是满二叉树
	return (result.nodes == (1 << result.depth) - 1);
}

void main()
{
	// 我这边创建的完全二叉树也是一个满二叉树
	TNode* head = ConstructCBT();
	cout << "检查，" << (CheckFBT(head) ? ("是满二叉树") : ("不是满二叉树")) << endl;
	system("pause");
}
```

**2的n次方：**

``` c plus
void main()
{
	// 容易理解，1往左进一位，得到10，再往左进一位，得到100，再往左进一位，得到1000，即8
	cout << (1 << 3) << endl;
	system("pause");
}
```

### 2.4 判断平衡二叉树

**概念：**左子树和右子树都是平衡二叉树，且|左高 - 右高| ≤ 1

**递归套路：**1）左树是否为平衡二叉树+高度；2）右树是否为平衡二叉树+高度；3）当前树是否为平衡二叉树+高度

``` c plus
// 构造一棵不平衡的二叉树
TNode* ConstructUBT()
{
	// 构造一棵完全二叉树
	TNode* head = new TNode(5);

	head->left = new TNode(3);
	head->right = new TNode(8);

	head->left->left = new TNode(2);
	head->left->left->left = new TNode(1);

	head->right->left = new TNode(7);
	head->right->right = new TNode(10);

	// 构造的是这样的树
	//                               5
	//                       3                 8
	//                     2                7    10
	//                    1        
	return head;
}

// 由于存储当前平衡二叉树检查中的返回值
struct BTType
{
	int height;
	bool isBalanced;
	BTType(const int& hei, const bool isB) :height(hei), isBalanced(isB) {}
};

// 检查是否为平衡二叉树
BTType CheckBT(TNode* head)
{
	// 如果当前结点为空，则返回当前结点的层高为0，且当前结点是平衡二叉树
	if (head == NULL) return BTType(0, true);
	auto leftReturn = CheckBT(head->left);
	auto rightReturn = CheckBT(head->right);
	// 计算当前树的总高度
	int height = max(leftReturn.height, rightReturn.height) + 1;
	// 当前树是否为平衡二叉树
	// 条件是：左右树均为平衡的二叉树，同时左右树的高度之差比2小
	bool isBalanced = (leftReturn.isBalanced && rightReturn.isBalanced) && abs(leftReturn.height - rightReturn.height) < 2;
	return BTType(height, isBalanced);
}

void main()
{
	TNode* tN = ConstructUBT();
	cout << "检查，" << (CheckBT(tN).isBalanced == true ? "是平衡二叉树" : "不是平衡二叉树") << endl;
	system("pause");
}
```

### 2.5 通用递归套路处理二叉树问题

**步骤1：**分析需要返回什么样的信息，构建构造体；

**步骤2：**流水账代码。

**性质：**可以解所有的树型DP问题，即部分不会影响整体的问题，比如如果是求中位数，从左树上要的中位数和从右树上要的中位数，并不能确定当前树中的中位数，则这种问题不能用递归套路解。



# 图Graph

## 1. 表达方式

### 1.1 邻接表法



### 1.2 邻接矩阵法



**注：表达图的方式有很多，特别对于一些特殊的图。**

### 1.3 具体形式

**图的具体表达**

``` c plu
class Graph
	{
	public:
		unordered_map<int, Node*> nodes;	// 图中的所有结点
		unordered_set<Edge*> edges;			// 图中的所有边
		Graph() {}
		~Graph()
		{
			for_each(nodes.begin(), nodes.end(), [=](pair<int, Node*> node) {
				// 迭代器遍历，逐个释放结点的存储内容
				delete node.second;
				});
			for_each(edges.begin(), edges.end(), [=](Edge* edge) {
				// 迭代器遍历，逐个释放边的存储内容
				delete edge;
				});
		}
	};
```

**节点的具体表达**

``` c plu
class Node
{
    int value;	// 结点的数据，即当前结点是哪一个结点
    int in;		// 结点的入度
    int out;	// 结点的出度
    list<*Node> nexts;	// 下一个结点
    list<*Edge> edges;	// 该结点从属的边
    Node(const int& value)
    {
        this->value=value;
        in =0;
        out =0;
    }
}
```

**边的具体表达**

``` c plu
// 有向边，无向边可以通过两条有向边拼接
class Edge
{
    int weight;		// 边的权重
    Node *from;		// 边的起始结点
    Node *to;		// 边的终止结点
    Edge(const int& weight, const Node& from, const Node& to)
    {
        this->weight = weight;
        this->from = from;
        this->to = to;
    }
}
```

### 1.4 表达转换

​		即将给定类型的结构转换为我们熟悉的结构。

``` c plu
// 将一个二维数组转换为我们的图结构
Graph CreateOrderedGraph(const vector<vector<int>>& matrix)
{
Graph graph;
for (int i = 0; i < matrix.size(); i++)
{
    // matrix中的元素分别为
    // matrix[][0] 表示边的起始点from的key值
    // matrix[][1] 表示边的终止点to的key值
    // matrix[][2] 表示边的权值
    int from = matrix[i][0];
    int to = matrix[i][1];
    int weight = matrix[i][2];

    if (graph.nodes.find(from) == graph.nodes.end())
    {
        // 如果图中的结点不含有当前给定的结点（用key值判断）
        // 则在堆区上创建一个结点，以给定的key为结点的key，推入到当前的图中
        graph.nodes.insert(make_pair(from, new Node(from)));
    }
    if (graph.nodes.find(to) == graph.nodes.end())
    {
        graph.nodes.insert(make_pair(to, new Node(to)));
    }
    // 取出两个结点的地址
    Node* fromNode = graph.nodes[from];
    Node* toNode = graph.nodes[to];
    // 在堆区创建边
    Edge* newEdge = new Edge(weight, fromNode, toNode);
    // 当前的toNode是fromNode的下一个结点，故将toNode作为fromNode的直接后继
    fromNode->nexts.push_back(toNode);
    fromNode->out++;
    toNode->in++;
    // 将当前创建的边放到当前from结点中
    fromNode->edges.push_back(newEdge);
    // 将当前创建的边放到图的边中用于维护
    graph.edges.insert(newEdge);
}
return graph;
}

Graph CreateUnorderedGraph(const vector<vector<int>>& matrix)
{
    // 此时主要需要注意的是，一条边要同时从属于两个结点
    Graph graph;
    for (int i = 0; i < matrix.size(); i++)
    {
        // matrix中的元素分别为
        // matrix[][0] 表示边的起始点from的key值
        // matrix[][1] 表示边的终止点to的key值
        // matrix[][2] 表示边的权值
        int from = matrix[i][0];
        int to = matrix[i][1];
        int weight = matrix[i][2];

        if (graph.nodes.find(from) == graph.nodes.end())
        {
            // 如果图中的结点不含有当前给定的结点（用key值判断）
            // 则在堆区上创建一个结点，以给定的key为结点的key，推入到当前的图中
            graph.nodes.insert(make_pair(from, new Node(from)));
        }
        if (graph.nodes.find(to) == graph.nodes.end())
        {
            graph.nodes.insert(make_pair(to, new Node(to)));
        }
        // 取出两个结点的地址
        Node* fromNode = graph.nodes[from];
        Node* toNode = graph.nodes[to];
        // 在堆区创建边，创建以fromNode作为from的边和以toNode作为from的边
        Edge* fromEdge = new Edge(weight, fromNode, toNode);
        Edge* toEdge = new Edge(weight, toNode, fromNode);
        // 当前的toNode是fromNode的下一个结点，故将toNode作为fromNode的直接后继
        fromNode->nexts.push_back(toNode);
        fromNode->out++;
        toNode->in++;

        // 由于无向图可以看作双向的，所以进行一波镜像操作
        toNode->nexts.push_back(fromNode);
        toNode->out++;
        fromNode->in++;

        // 将当前创建的边放到当前from和to结点中
        fromNode->edges.push_back(fromEdge);
        toNode->edges.push_back(toEdge);
        // 将当前创建的边放到图的边中用于维护
        graph.edges.insert(fromEdge);
        graph.edges.insert(toEdge);
    }
    return graph;
}
```

## 2 算法总结

### 2.1 图的宽度优先遍历<img src="C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230318193349603.png" alt="image-20230318193349603" style="zoom:67%;" />

​		如图所示，解决上述无向图的宽度优先遍历，如果从结点1开始遍历，数据的结果应当为
$$
1 \{236\}\{45\}7
$$
式中，一个花括号内的数值可以相互交换位置。

​		如果从结点7开始遍历，数据的结果应当为
$$
75\{46\}\{123\}
$$
​		如果从结点4开始遍历，数据的结果应当为
$$
4\{35\}\{167\}2
$$


**构造数据**

``` c plus
// 构造数据
vector<vector<int>> ConstructUnorderedGraph()
{
    // matrix[][0] 表示边的起始点from的key值
    // matrix[][1] 表示边的终止点to的key值
    // matrix[][2] 表示边的权值
    vector<vector<int>> matrix;
    // 构造第一条边
    vector<int> arr{ 1,2,3 };
    matrix.push_back(arr);
    // 构造第二条边
    arr[0] = 2; arr[1] = 6; arr[2] = 9;
    matrix.push_back(arr);
    // 构造第三条边
    arr[0] = 1; arr[1] = 6; arr[2] = 12;
    matrix.push_back(arr);
    // 构造第四条边
    arr[0] = 1; arr[1] = 3; arr[2] = 10;
    matrix.push_back(arr);
    // 构造第五条边
    arr[0] = 3; arr[1] = 4; arr[2] = 13;
    matrix.push_back(arr);
    // 构造第六条边
    arr[0] = 6; arr[1] = 5; arr[2] = 6;
    matrix.push_back(arr);
    // 构造第七条边
    arr[0] = 4; arr[1] = 5; arr[2] = 24;
    matrix.push_back(arr);
    // 构造第八条边
    arr[0] = 5; arr[1] = 7; arr[2] = 7;
    matrix.push_back(arr);
    return matrix;
}
```

**代码实现**

``` c plu
// 宽度优先遍历-Breadth First Search
// 注，可以从任何一个结点开始
void GraphBFS(Node* node)
{
	if (node == NULL) return;
	// 辅助队列，进行宽度优先
	queue<Node*> que;
	// 推入首结点
	que.push(node);
	// 辅助集合，用于去重
	set<Node*> st;
	st.insert(node);
	while (!que.empty())
	{
		Node* tmp = que.front();
		que.pop();
		// 进行结点操作
		cout << tmp->value << ", ";
		// 将当前结点的所有next结点都做判断，看是否需要推入到队列和集合中
		for (auto it = tmp->nexts.begin(); it != tmp->nexts.end(); it++)
		{
			if (st.find(*it) == st.end())
			{
				// 注：真等于才表示当前集合没有包含，不要搞错了
				// 如果当前结点没有放入去重集合中
				// 集合中记录该结点
				st.insert(*it);
				// 队列中加入该结点
				que.push(*it);
			}
		}
	}
}
```

**主函数代码**

``` c plu
void main()
{
	// 构造一个数据矩阵
	auto matrix = Graph::ConstructUnorderedGraph();
	// 基于数据矩阵构造图
	auto graph = Graph::CreateUnorderedGraph(matrix);
	// 基于某个结点遍历无向图，结点1开始
	Graph::GraphBFS(graph.nodes[1]);
	cout << endl;
	// 基于某个结点遍历无向图，结点7开始
	Graph::GraphBFS(graph.nodes[7]);
	cout << endl;
	// 基于某个结点遍历无向图，结点4开始
	Graph::GraphBFS(graph.nodes[4]);
	cout << endl;
	system("pause");
}
```

### 2.2 图的深度优先遍历

**基本思想：**栈和集合实现，其遵循以下规则

**规则1：**如果一个结点没有在集合中，说明我们要走这条路，并且要一直沿着这条路走下去，那么将它的上一个结点先压栈，再压入当前结点，这样，我们就可以保证，当走完这条路径并返回后，还有余地，可以找到上一个结点并去走下一条路径；

**规则2：**如果一个结点没有在集合中，将其加入集合；

``` c plu
// 深度优先遍历-Depth First Search
void GraphDFS(Node* node)
{
	if (node == NULL) return;
	stack<Node*> stk;
	set<Node*> st;
	st.insert(node);
	stk.push(node);
	cout << node->value << ", ";
	while (!stk.empty())
	{
		Node* tmp = stk.top();
		stk.pop();
		for (auto it = tmp->nexts.begin(); it != tmp->nexts.end(); it++)
		{
			if (st.find(*it) == st.end())
			{
				// 说明当前结点不在去重集合中，则可以跟着这条路径一直往下走
				// 且由于要跟着这条路径一直走，需要在循环最后break掉以返回上层循环
				st.insert(*it);
				// 由于找到了一个结点可以沿着继续走，我们就有必要记录上一个结点以沿着当前结点访问完之后可以查找下一条路径
				stk.push(tmp);
				stk.push(*it);
				// 因为(*it)才是指针，输出当前结点的结果
				cout << (*it)->value << ", ";
				break;
			}
		}
	}
}

void main()
{
	// 构造一个数据矩阵
	auto matrix = Graph::ConstructUnorderedGraph();
	// 基于数据矩阵构造图
	auto graph = Graph::CreateUnorderedGraph(matrix);
	// 基于某个结点深度遍历无向图，结点1开始
	Graph::GraphDFS(graph.nodes[1]);
	cout << endl;
	// 基于某个结点深度遍历无向图，结点7开始
	Graph::GraphDFS(graph.nodes[7]);
	cout << endl;
	// 基于某个结点深度遍历无向图，结点4开始
	Graph::GraphDFS(graph.nodes[4]);
	cout << endl;
	system("pause");
}

```

### 2.3 拓扑排序算法

​		其实就是一个有向图。也就是说，对于一些问题，它们有一些前置条件，我们要保证先完成了前置条件，然后进行后续的工作。

**规则1：**入度为0的点绝对是在最前面的；

**规则2：**然后逐个隐去当前结点对后续结点的影响，然后找新的入度为0的点，然后循环重复即可。

**思路：**准备一个队列，把入度为0的结点推入到队列中，再准备一个Hash表，每次访问一个结点之后，都将其对应的后续结点的入度全部减少1。

​		针对以下结构的拓扑排序：

<img src="C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230318205440245.png" alt="image-20230318205440245" style="zoom:67%;" />

**排序结果应当为：**
$$
1\{23\}\{46\}57
$$

``` c plu
// 拓扑排序
list<Node*> TopoSorted(const Graph& graph)
{
    if (graph.nodes.empty())
        throw string("The graph is empty!");
    queue<Node*> que;
    list<Node*> result;
    // hash表的key表示对应结点，value表示当前结点的入度
    unordered_map<Node*, int> hash;
    for (auto it = graph.nodes.begin(); it != graph.nodes.end(); it++)
    {
        // 先遍历结点，构造哈希表
        // 用结点的地址和结点的入度作为哈希表的元素
        hash.insert(make_pair(it->second, it->second->in));
        if (it->second->in == 0)
        {
            // 在构造hash表的过程中，需要同时查找出来入度为0的结点，作为起始结点
            que.push(it->second);
        }
    }
    while (!que.empty())
    {
        Node* tmp = que.front();
        que.pop();
        result.push_back(tmp);
        // 弹出结点之后，将对应后续结点的入度减1
        for (auto it = tmp->nexts.begin(); it != tmp->nexts.end(); it++)
        {
            // 对应的入度减1，并且如果在-1之后，结点对应的入度为0了，则将其推入到队列中
            if (--hash[*it] == 0)
                que.push(*it);
        }
    }
    return result;
}

void main()
{
	// 构造一个数据矩阵
	auto matrix = Graph::ConstructUnorderedGraph();
	// 基于数据矩阵构造图
	auto graph = Graph::CreateOrderedGraph(matrix);
	// 基于某个结点深度遍历无向图，结点1开始
	auto result = Graph::TopoSorted(graph);
	// 遍历结果，查看拓扑排序结果
	for_each(result.begin(), result.end(), [=](Graph::Node *node) {
    	cout << node->value << ", ";
    	});
	cout << endl;

	system("pause");
}
```

### 2.4 针对无向图的其它算法

**最小生成树：**保证连通性并且所有边的权值之和最小。两种算法来生成最小生成树。

#### Kruskal算法

**思路：**从边的角度考虑，每次挑最小的边，只要当前边选上没有形成环，就要这条边，直到遍历所有的边。

**关键点：**如何判断当前是否形成环。采用并查集的形式进行判断，如果当前加入的边的两个结点不处于同一个集合，则当前加入边必然不会使得原结构形成环，反之会形成环。

**案例：**

![image-20230319112058357](C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230319112058357.png)

即考虑上述图的最小生成树，得到的几条边的权值为2、4、7、10000。

**构造数据**

``` c plus
// 构造数据
vector<vector<int>> ConstructMSTData()
{
    // matrix[][0] 表示边的起始点from的key值
    // matrix[][1] 表示边的终止点to的key值
    // matrix[][2] 表示边的权值
    vector<vector<int>> matrix;
    // 构造第一条边
    vector<int> arr{ 1,2,7 };
    matrix.push_back(arr);
    // 构造第二条边
    arr[0] = 1; arr[1] = 4; arr[2] = 100;
    matrix.push_back(arr);
    // 构造第三条边
    arr[0] = 1; arr[1] = 5; arr[2] = 2;
    matrix.push_back(arr);
    // 构造第四条边
    arr[0] = 5; arr[1] = 4; arr[2] = 4;
    matrix.push_back(arr);
    // 构造第五条边
    arr[0] = 2; arr[1] = 4; arr[2] = 1000;
    matrix.push_back(arr);
    // 构造第六条边
    arr[0] = 2; arr[1] = 3; arr[2] = 10000;
    matrix.push_back(arr);
    return matrix;
}
```

**并查集结构的简单实现与调试：**

``` c plu
// 简单实现并查集，主要差距在操作速度
class MySets {
public:
    // 主要的数据结构，其key是结点地址，value是该结点所在的集合
    unordered_map<Node*, set<Node*>*> SetMap;
    MySets(const list<Node*>& nodes)
    {
        // 用一个结点列表来初始化这个并查集
        for (auto& node : nodes)
        {
            // 创建一个临时集合，在初始状态下，该集合只包含一个结点
            set<Node*>* tmpSet = new set<Node*>{node};
            // 将该结点及其对应结合放到并查集中
            SetMap.insert(make_pair(node, tmpSet));
        }
    }
    
    void Print()
    {
        cout << "// ======================================== Print Start ======================================== //" << endl;
        for (auto it = SetMap.begin(); it != SetMap.end(); it++)
        {
            cout << "// ==================== Node Start ==================== //" << endl;
            cout << "Node Address: " << (*it).first << ", Node value: " << (*it).first->value << endl;
            cout << "Corresponding Set: " << it->second << endl;
            for (auto itt = it->second->begin(); itt != it->second->end(); itt++)
            {
                cout << "Node Address: " << (*itt) << ", Node value: " << (*itt)->value << endl;
            }
            cout << "// ==================== Node End ==================== //" << endl;
        }
        cout << "// ======================================== Print End ======================================== //" << endl << endl;
    }
    
  	MySets::~MySets()
	{
		// 循环释放空间，释放的仅仅是各个set中存储的地址（指针），并不会释放指针指向的空间！
		// 这里有个很容易忘记的地方，现在有若干个元素共用一个set空间，所以有可能造成重复释放
		set<set<Node*>*> st;	// 一个辅助集合，判断某个空间是否被释放过
		for (auto it = SetMap.begin(); it != SetMap.end(); it++)
			if (st.find(it->second) == st.end())
			{
				// 如果该集合没有被释放过
				delete it->second;
				st.insert(it->second);
			}		
	}
    
    // 查看两个结点是否在同一个集合中
	bool MySets::IsSameSet(Node* from, Node* to)
	{
		// 直接返回对应集合的地址即可
		set<Node*>* setFrom = this->SetMap[from];
		set<Node*>* setTo = this->SetMap[to];
		return setFrom == setTo;
	}

	// 将两个结点对应的集合进行合并
	void MySets::Union(Node* from, Node* to)
	{
		// 先以取到两个集合的地址
		set<Node*>* setFrom = SetMap[from];
		set<Node*>* setTo = SetMap[to];
		// 如果本身两个元素就属于一个集合，则不用进行合并
		if (setFrom == setTo) return;
		// 将to的集合合并到from的集合中
		for (auto it = setTo->begin(); it != setTo->end(); it++)
		{
			// SetMap[*it]取到的是当前*it对应结点（setTo中的结点）所属的集合，更改其地址为setFrom，意为这些元素现在都从属于新的集合
			setFrom->insert(*it);
			SetMap[*it] = setFrom;
		}
		// 绝对不要释放任何的结点，因为在操作过程中，我们没有加入任何新的结点，所有结点都是由原本的graph在维护
		// 绝对不要直接删除对应的SetMap元素，而是释放对应的集合即可，而且还要考虑，是否进行了集合的合并
		// 如果本身集合就只有一个，那么此时不能够进行内存空间的释放
		delete setTo;
	}
};

// 具体调试代码
void main()
{
	// 构造一个数据矩阵
	auto matrix = ConstructMSTData();
	// 基于数据矩阵构造图
	auto graph = CreateUnorderedGraph(matrix);
	// 全程操作用指针实现，但是不修改指针指向空间的值
	list<mGraph::Node*> lisNodes;
	vector<mGraph::Node*> vecNodes;
	for_each(graph.nodes.begin(), graph.nodes.end(), [&](const pair<int, mGraph::Node*>& node) {
		lisNodes.push_back(node.second);
		vecNodes.push_back(node.second);
		});
	// 由于我们的并查集初始化采用的是list结点数据，所以先要创建一个list
	MySets unionFind(lisNodes);
	unionFind.Print();
	unionFind.Union(vecNodes[0], vecNodes[1]);
	unionFind.Print();
	system("pause");
}
```

**Kruskal算法具体实现**

``` c plus
set<Edge*> KruskalMST(const Graph& graph)
{
    // 全程操作用指针实现，但是不修改指针指向空间的值
    list<Node*> lisNodes;
    for_each(graph.nodes.begin(), graph.nodes.end(), [&](const pair<int, Node*>& node) {
        lisNodes.push_back(node.second);
        });
    // 由于我们的并查集初始化采用的是list结点数据，所以先要创建一个list
    MySets unionFind(lisNodes);
    // 然后我们需要造一个小根堆，来实现边value的排序（可以这样想，我们需要的是升序，所以对优先级队列反着取，用greater）
    priority_queue<Edge*, vector<Edge*>, EdgeComparator> heap;
    for_each(graph.edges.begin(), graph.edges.end(), [&](Edge* const edge) {
        // 注意，一般我们用到的都是指针常量而非常量指针
        // 常量指针会造成很多麻烦，很多时候会导致赋值不成功
        // 但指针常量仅仅要求对应的指针不能被赋值，这也更加符合我们对问题的认识
        heap.push(edge);
        });
    // 注：此处放入结果的顺序是基于数据地址的排序
    set<Edge*> result;
    while (!heap.empty())
    {
        // 弹出一条边，查看其两个结点所在集合的关系
        Edge* tmp = heap.top();
        heap.pop();
        if (!unionFind.IsSameSet(tmp->from, tmp->to))
        {
            // 如果该边的两个结点不在同一集合，则肯定不会形成环，则进入该操作，将边推入到结果集合中
            result.insert(tmp);
            // 合并该边上两个结点所在集合
            unionFind.Union(tmp->from, tmp->to);
        }
    }
    return result;
}

void main()
{
	// 构造一个数据矩阵
	auto matrix = ConstructMSTData();
	// 基于数据矩阵构造图
	auto graph = CreateUnorderedGraph(matrix);
	// 全程操作用指针实现，但是不修改指针指向空间的值
	list<mGraph::Node*> lisNodes;
	vector<mGraph::Node*> vecNodes;
	for_each(graph.nodes.begin(), graph.nodes.end(), [&](const pair<int, mGraph::Node*>& node) {
    	lisNodes.push_back(node.second);
    	vecNodes.push_back(node.second);
    	});
	// 基于某个结点深度遍历无向图，结点1开始
	auto result = mGraph::KruskalMST(graph);
	// 遍历结果，查看拓扑排序结果
	for_each(result.begin(), result.end(), [=](mGraph::Edge* edge) {
    	cout << edge->weight << ", ";
    	});
	cout << endl;
	system("pause");
}
```

#### Prim算法

**思路：**从节点的角度考虑问题。每次拿出若干结点（最初从一个结点开始），找出所有和其相关的边，并看，哪些边对应的对点没有被使用过（不在当前集合中），选出权值最小的边（这就是我们需要的边），并拿到其对应点放到表示使用过结点的集合中。

**和Kruskal算法的区别：**Prim算法中，每次只会把一个新点纳入到集合中，而不会出现一次把两个已经局部连通的结构合并在一起的情况**（因为K算法是以边为单位，所以有可能出现多个局部连通的情况）**。

**步骤1：**找到任意一个点作为起始点；

**步骤2：**把该点的所有连通边全部放到优先级队列，即解锁当前结点相关的所有边（小根堆中，说明是升序排列）；

**步骤3：**从优先级队列中弹出边（权值最小），查看其对点是否在已使用的点集合中，若没有，要这条边，并再把对点的所有边全部推入到优先级队列中（又根据一个结点解锁了新的边）；

**步骤4：**反复从步骤1开始执行，因为每一次根据一个结点延申出去，只能找到和该结点连通的所有边，故如果本身问题针对的是森林，则需要遍历原来的所有结点，直到找到下一个不在已使用集合中的结点。

``` c plus
set<Edge*> PrimMST(const Graph& graph)
{
    set<Edge*> result;
    // 准备一个优先级队列，用于每一次弹出当前解锁的最小边
    priority_queue<Edge*, vector<Edge*>, EdgeComparator> heap;
    // 准备一个set，用于记录使用过的结点
    unordered_set<Node*> usedNodes;
    for (auto it = graph.nodes.begin(); it != graph.nodes.end(); it++)
    {
        // 该循环用于完成森林结构的情况，即原图有多个局部连通区域
        if (usedNodes.find(it->second) == usedNodes.end())
        {
            // 将任选的结点推入到已使用set中
            usedNodes.insert(it->second);
            for (auto itt = it->second->edges.begin(); itt != it->second->edges.end(); itt++)
            {
                // 将当前结点的所有相关边都放到优先级队列中
                heap.push(*itt);
            }
            while (!heap.empty())
            {
                Edge* tmpE = heap.top();
                heap.pop();
                // 注意一个问题，结点所维护的边一定是将其作为from的那个边，所以看另一个结点则直接拿to结点即可
                Node* tmpN = tmpE->to;
                // 如果得到的新节点没有在原本的set中，则将其所有边都放入到优先级队列中，并说明该边是结果所需的
                if (usedNodes.find(tmpN) == usedNodes.end())
                {
                    result.insert(tmpE);
                    usedNodes.insert(tmpN);
                    for (auto itt = tmpN->edges.begin(); itt != tmpN->edges.end(); itt++)
                    {
                        heap.push(*itt);
                    }
                }
            }
        }

    }
    return result;
}
```

**主函数的实现和之前的K算法一样。**

#### Djikstra（单元最短路径）

**问题解释：**规定出发点，然后找到到所有结点的距离的最小值（不可达的距离置为∞）。

**思路：**先创建一个表，其记录规定点到所有点的距离，并把规定点到所有点的距离都置为∞（到自己为0），然后从表中选出距离最小的那一个，从那一个位置看，此时是否可以更新表中的数据，即找到比当前表中距离更短的路径。<font color = red>**该算法仅适用于无负数的情况，更严格地说，不能有累加和为负数的环。其原理在于每次选出表中最小的数据，就是以当前的局部最小距离去算，以经过该点到它相连的所有点的路径中，能否找到一条比之前更短的路径。** </font>

**注：**在实际代码中，无穷其实代表这个结点到规定点的距离还没有被推入到哈希表中。

**案例：**

<img src="C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230318193349603.png" alt="image-20230318193349603" style="zoom:67%;" />

以结点1开始的话，到各个点的最终距离为
$$
2:3,\  3:10,\  4:23,\  5:18,\  6:12,\  7:25
$$
以结点7开始的话，到各个点的最终距离为
$$
1:25,\ 2:22,\ 3:35,\ 4:31, \ 5:7,\ 6:13
$$

**基本代码**

``` c plus
// 最小单元算法，用于查找图中各个点到指定点的最短距离
unordered_map<Node*, int> Dijkstra1(Node* const head)
{
    // 这个哈希表用于记录各个结点的到指定结点的距离，如果一个结点不在哈希表中，说明当前结点和指定结点之间不连通
    unordered_map<Node*, int> distanceMap;
    // 这个哈希集合用于记录已经使用过的结点，如果一个结点已经使用，那么就算当前在距离表中，到该点的距离是最小的，我们也不取用这个点
    unordered_set<Node*> usedNodes;
    // 将指定节点到指定结点的距离设为0，推入到距离表中
    distanceMap.insert(make_pair(head, 0));
    Node* minNode = GetMinDistanceNode(distanceMap, usedNodes);
    while (minNode != NULL)
    {
        // 只要还能找到满足要求的点，过程就可以继续，到最后所有结点都已经使用了，此时就返回空
        // 将找到的距离最小结点推入到使用过的结点集合中
        usedNodes.insert(minNode);
        // 得到从指定结点到该距离最小结点的实际距离
        int minDistance = distanceMap[minNode];
        // 然后要遍历从该结点开始，去往其它相连的所有结点的边，并尝试更新这些点的距离
        for (auto it = minNode->edges.begin(); it != minNode->edges.end(); it++)
        {
            // 拿到toNode
            Node* toNode = (*it)->to;
            if(distanceMap.find(toNode)== distanceMap.end())
            {
                // 说明当前结点还没有被更新过距离，即当前它的距离是正无穷，则一定可以更新距离
                distanceMap[toNode] = minDistance + (*it)->weight;
            }
            else
            {
                // 说明当前结点已经更新过距离，所以需要比较一下，是否真的需要更新距离
                distanceMap[toNode] = min(minDistance + (*it)->weight, distanceMap[toNode]);
            }
        }
        // 循环末尾，找出下一个距离指定结点最近的结点
        minNode = GetMinDistanceNode(distanceMap, usedNodes);
    }
    return distanceMap;
}

void main()
{
    // 构造一个数据矩阵
    auto matrix = ConstructUnorderedGraph();
    // 基于数据矩阵构造图
    auto graph = CreateUnorderedGraph(matrix);
    // 以1为起点，计算最小单元距离
    auto distanceMap = Dijkstra1(graph.nodes[1]);
    cout << "To Node 1" << endl;
    for (auto it = distanceMap.begin(); it != distanceMap.end(); it++)
    {
        cout << "The Node: " << it->first->value << ", The Distance: " << it->second << endl;
    }
    // 以7为起点，计算最小单元距离
    distanceMap = Dijkstra1(graph.nodes[7]);
    cout << endl << "To Node 7" << endl;
    for (auto it = distanceMap.begin(); it != distanceMap.end(); it++)
    {
        cout << "The Node: " << it->first->value << ", The Distance: " << it->second << endl;
    }
    system("pause");
}
```

**输出结果：**

![image-20230324132633717](C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230324132633717.png)

**堆加速**

**问题描述：**系统提供的优先级队列不提供修改非堆顶元素之后重新构建堆的操作，而在最小单元问题中，我们需要不停修改堆中的元素并重新构建堆，所以需要自己重新构造堆的方法。

**错误案例**

``` c plus
// 弹出函数，值得注意的是，弹出结点之后，距离哈希表中直接删除对应数据，之后再也不会用到它
// 但是对结点索引表，不直接删除对应数据，而是将对应结点的index改为-1，这样可以表示当前结点进入过小根堆，但是当前已经被弹出
NodeRecord GraphMinHeap::pop()
{
    // ******************** 错误案例 ******************** //
    // 其它的不知道，但是小根堆中的第一个结点必然是值最小的结点
    NodeRecord result = NodeRecord(nodes[0], distanceMap[nodes[0]]);
    // 交换第一个和最后一个结点的位置，然后对换到第一个位置的结点进行Heapify操作
    // 将交换前第一个位置结点的索引改为-1
    // ***** 这里不能够先改，必须把对应结点先放到最后，然后再改，因为Swap中还会用到nodeIndexMap中的索引值，这样写会导致交换错误进行
    nodeIndexMap[nodes[0]] = -1;
    // 这里需要注意，是先索引0和索引size - 1位置的结点进行位置交换，然后要把size--，之后才能进行Heapify，否则错误
    // 所以可以直接先--size，然后直接0和size位置交换
    Swap(0, size - 1);
    size--;
    Heapify(nodes[0]);
    // 用键在Map中查找，并删除对应距离数据，此时的最后一个数据其实是size - 1，但是我们要删除的是已经置换到size位置的元素
    distanceMap.erase(distanceMap.find(nodes[size]));
    return result;
    // ******************** 错误案例 ******************** //
}
```

**堆的构造和功能释义：**

``` c plus
// 最小单元算法，堆加速实现
// 结点记录类，我们本身有一个图的结点类Node，但这个结点记录可以具体记录各个结点到指定结点的距离
// 主要用作pop函数的返回值
class NodeRecord
{
public:
    Node* node;
    int distance;
    NodeRecord(Node* const nd, const int& dis) :node(nd), distance(dis) {};
};
// 根据问题而定的小根堆
class GraphMinHeap
{
public:
    // 构造函数，明显什么参数都不给最合适吧
    GraphMinHeap(const int& graphSize) { nodes = vector<Node*>(graphSize, NULL); }
    // 查看一个结点当前是否在小根堆中
    bool IfInHeap(Node* const& node) const;
    // 查看一个结点是否进入过小根堆（如果进入过，之后将不再基于该结点的距离更新其它结点的距离）
    bool IfEntered(Node* const& node) const;
    // 交换小根堆中两个结点的位置，不仅如此，我们还需要交换对应nodeIndexMap中结点的对应关系
    void Swap(const int& index1, const int& index2);
    // HeapInsert操作，从下往上的操作
    // 值得注意的是，我们需要考虑这个地方的形参到底是用索引还是用结点地址，这需要我们根据后续操作来协调
    // 个人感觉肯定是给结点，然后拿到索引
    void HeapInsert(Node* const& node);
    // Heapify操作，从上往下的操作
    void Heapify(Node* const& node);
    // 弹出函数，值得注意的是，弹出结点之后，距离哈希表中直接删除对应数据，之后再也不会用到它
    // 但是对结点索引表，不直接删除对应数据，而是将对应结点的index改为-1，这样可以表示当前结点进入过小根堆，但是当前已经被弹出
    NodeRecord pop();
    // 返回当前小根堆的尺寸
    int Size();
    // 返回当前小根堆是否为空
    bool IfEmpty();
    // 关键函数，给定结点（为什么是结点，可以想到，当你通过一个结点找到其相邻的元素时，得到的就是其它结点的地址）
    // 和给定结点到源结点的新距离，然后这个函数会执行合适的处理，判断是否需要更新距离表中的值
    void AddOrUpdateOrIgnore(Node* const& node, const int& distance);
private:
    // 这一个哈希表用于给定结点地址，返回对应结点在数组中的index
    unordered_map<Node*, int> nodeIndexMap;
    // 这一个哈希表用于给定结点地址，返回对应结点距离指定结点的距离
    // 一个比较有意思的地方在于，以结点的地址为key，则不管我们怎么去调数组中的结点顺序，我们始终可以从这个哈希表中得到正确的结果
    unordered_map<Node*, int> distanceMap;
    // 实际存储结点依然用的是一个数组
    vector<Node*> nodes; 
    // 记录当前小根堆的尺寸
    int size = 0;
};
// GraphSize的意思是图的结点个数
unordered_map<Node*, int>Dijkstra2(Node* const head, const int& graphSize);

// =================== 堆加速方法实现Dijkstra =================== //
// 查看一个结点当前是否在小根堆中
bool GraphMinHeap::IfInHeap(Node* const& node) const
{
    // 如果一个节点进入过索引表，并且其索引不为-1，则它肯定还在小根堆中未被弹出
    // 因为定义了const，所以Map[]的访问方式失败，但是at可以成功访问
    return IfEntered(node) && (nodeIndexMap.at(node) != -1);
}

// 查看一个结点是否进入过小根堆（如果进入过，之后将不再基于该结点的距离更新其它结点的距离）
bool GraphMinHeap::IfEntered(Node* const& node) const
{
    // 直接看结点索引表中是否有记录
    // 不为end说明进入过这个表，返回真
    return nodeIndexMap.find(node) != nodeIndexMap.end();
}

// 交换小根堆中两个结点的位置，不仅如此，我们还需要交换对应nodeIndexMap中结点的对应关系
void GraphMinHeap::Swap(const int& index1, const int& index2)
{
    // 1. 调换结点索引表中结点的对应索引，这个要在前面
    this->nodeIndexMap[nodes[index1]] = index2;
    this->nodeIndexMap[nodes[index2]] = index1;
    // 2. 调换数组中元素的位置
    Node* tmpN = nodes[index1];
    nodes[index1] = nodes[index2];
    nodes[index2] = tmpN;
}

// HeapInsert操作，从下往上的操作，当前目标是一个小根堆
// 值得注意的是，我们需要考虑这个地方的形参到底是用索引还是用结点地址，这需要我们根据后续操作来协调
// 个人感觉肯定是给结点，然后拿到索引
void GraphMinHeap::HeapInsert(Node* const& node)
{
    if (IfEmpty())return;
    // 拿到结点的下标
    int index = nodeIndexMap[node];
    while (distanceMap[nodes[index]] < distanceMap[nodes[(index - 1) / 2]])
    {
        // 这个循环必然会跳出，因为就算到顶，最终的判断也是自己是否小于自己，此时判断为假，跳出循环
        Swap(index, (index - 1) / 2);
        index = (index - 1) / 2;
    }
}

// Heapify操作，从上往下的操作，当前目标是一个小根堆
void GraphMinHeap::Heapify(Node* const& node)
{
    // 有个很大的问题在于，在一个结点被弹出后堆为空，此时还会将元素nodes[0]进行Heapify操作，此时index为-1，会引起错误
    // 所以如果堆的元素个数为0，则直接返回
    if (IfEmpty())return;
    // 拿到当前结点对应的index 
    int index = this->nodeIndexMap[node];
    // 拿到左孩子的index
    int left = index * 2 + 1;
    while (left < size)
    {
        // 拿到子结点中比较小的那一个的index
        // 这里最好要先判断left + 1 < size，否则可能会超出访问界限吧
        // 也就是说要同时满足右孩子存在并且到右结点的距离比较小，才取右孩子
        int smallIndex = (left + 1 < size) && (distanceMap[nodes[left]] > distanceMap[nodes[left + 1]]) ? left + 1 : left;
        //smallIndex = distanceMap[nodes[smallIndex]] < distanceMap[nodes[index]] ? smallIndex : index;
        //if (smallIndex == index)
        //	// 说明小根堆到位，不需要继续调整
        //	break;
        if (distanceMap[nodes[index]] < distanceMap[nodes[smallIndex]])
            break;
        cout << index << "hhh" << endl;
        cout << node->value << "node value" << endl;
        Swap(index, smallIndex);
        // 先把当前结点换为小结点
        index = smallIndex;
        // 然后拿到下一次的左孩子
        left = smallIndex * 2 + 1;
    }
}
// 弹出函数，值得注意的是，弹出结点之后，距离哈希表中直接删除对应数据，之后再也不会用到它
// 但是对结点索引表，不直接删除对应数据，而是将对应结点的index改为-1，这样可以表示当前结点进入过小根堆，但是当前已经被弹出
NodeRecord GraphMinHeap::pop()
{
    // 如果本身堆为空，也直接返回，保险
    if (IfEmpty()) throw string("The heap is empty");
    NodeRecord result = NodeRecord(nodes[0], distanceMap[nodes[0]]);
    Swap(0, size - 1);
    nodeIndexMap[nodes[size - 1]] = -1;
    distanceMap.erase(distanceMap.find(nodes[size - 1]));
    size--;
    Heapify(nodes[0]);
    return result;
}

// 返回当前小根堆的尺寸
int GraphMinHeap::Size()
{
	return size;
}

// 返回当前小根堆是否为空
bool GraphMinHeap::IfEmpty()
{
	return size == 0;
}

// 关键函数，给定结点（为什么是结点，可以想到，当你通过一个结点找到其相邻的元素时，得到的就是其它结点的地址）
// 和给定结点到源结点的新距离，然后这个函数会执行合适的处理，判断是否需要更新距离表中的值
void GraphMinHeap::AddOrUpdateOrIgnore(Node* const& node, const int& distance)
{
    if (!IfEntered(node))
    {
        // 先把size++
        size++;
        // 如果当前给定结点没有加入过小根堆中，则直接更新距离（相当于把距离从无穷大缩小到一个基本值 + 边的权值）
        distanceMap.insert(make_pair(node, distance));
        // 把元素先插在最后一个位置上，然后通过Heap Insert操作将其交换到合适位置
        nodeIndexMap.insert(make_pair(node, size - 1));
        // 结点推入数组，这个地方绝对不能用push_back，因为数组要按照size维护的大小来放在指定的位置
        // 否则Heapify和HeapInsert包括nodeIndexMap中存的index和实际数据对应的index全是混乱的
        nodes[size - 1] = node;
        // Heap Insert操作，构建小根堆
        HeapInsert(node);
    }
    else if (IfInHeap(node))
    {
        // 如果当前给定结点正在小根堆中，则可能需要更新其对应的距离值
        // 否则说明该结点已经被弹出，则不需要对其进行任何操作
        // 取更小的那个值
        distanceMap[node] = distanceMap[node] < distance ? distanceMap[node] : distance;
        // 修改之后有可能堆的结构会改变，因为当前结点的distance值变小了，所以只需往上进行Heap Insert操作
        HeapInsert(node);
    }
}

    // 值得注意的是，返回值就是指针，而内存空间的维护交给Graph类
unordered_map<Node*, int>Dijkstra2(Node* const head, const int& graphSize)
{
    // 首先构建小根堆
    GraphMinHeap gmh(graphSize);
    // 将头结点加入，注：实际上Heapify和HeapInsert操作可以考虑设置为私有方法
    gmh.AddOrUpdateOrIgnore(head, 0);
    unordered_map<Node*, int> result;
    while (!gmh.IfEmpty())
    {
        // 在小根堆不为空的情况下执行循环
        // 弹出堆顶元素，其包含当前距离最小的结点和对应距离
        NodeRecord nr = gmh.pop();
        // 弹出的结果直接放在result中
        result.insert(make_pair(nr.node, nr.distance));
        for (auto& edge : nr.node->edges)
        {
            //cout << "From Node: " << nr.node->value << ", To Node: " << edge->to->value << endl;
            // 遍历弹出结点的所有后续结点，为它们赋予新的距离，当然，操作是一样的，特化的操作已经封装在了函数内部
            // 其中，通过对应边得到对面结点
            gmh.AddOrUpdateOrIgnore(edge->to, nr.distance + edge->weight );
        }
    }
    return result;
}
```

**主函数：**

``` c plus
void main()
{
    // 构造一个数据矩阵
    auto matrix = ConstructUnorderedGraph();
    // 基于数据矩阵构造图
    auto graph = CreateUnorderedGraph(matrix);
    // 以1为起点，计算最小单元距离
    auto distanceMap = Dijkstra2(graph.nodes[1],graph.nodes.size());
    cout << "To Node 1" << endl;
    for (auto it = distanceMap.begin(); it != distanceMap.end(); it++)
    {
        cout << "The Node: " << it->first->value << ", The Distance: " << it->second << endl;
    }
    // 以7为起点，计算最小单元距离
	distanceMap = Dijkstra2(graph.nodes[7], graph.nodes.size());
    cout << endl << "To Node 7" << endl;
    for (auto it = distanceMap.begin(); it != distanceMap.end(); it++)
    {
        cout << "The Node: " << it->first->value << ", The Distance: " << it->second << endl;
    }
    system("pause");
}
```



# 实际问题

## 1. 荷兰国旗问题

### 问题1 

（1）给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N)。不要求有序。

#### 思路

设有一个下标Index，初始值为0，其用于指示当前小于等于区域的最右侧单元再往后一个，初始值为0也就是说当前的小于等于区域为空。

**规则1：** 如果arr[i] <= num，则arr[i]和arr[Index]的值交换，Index++，i++；

**规则2：** 如果arr[i] > num，直接i++；

**规则3：** i越界则停止。

#### 代码

``` c plus
// 荷兰国旗问题1
void NetherlandsIssue1(vector<int>& arr, const int& num)
{
	int Index_Smaller = 0;
	for (int i = 0; i < arr.size(); i++)
	{
		if (arr[i] <= num)
		{
			// 如果当前数组元素比num小，则将其放到“小区域”中，即和当前指代小区域位置Index_Smaller对应元素进行互换
			Swap(arr, i, Index_Smaller++);
		}
	}
}

void main()
{
	vector<int> arr = RandVector(10,20,10);
	cout << "原数组：" << endl;
	ShowVector(arr);
	NetherlandsIssue1(arr, 15);
	cout << "新数组：" << endl;
	ShowVector(arr);
	system("pause");
}
```



### 问题2 

（1）给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N)。不要求有序。

#### 思路

​    不妨设两个下标Index_Smaller，Index_Bigger，此处Index_Bigger的下标初始化为数组长度-1，用于指示比num大的数字区域，并有新的规则：

**规则1：** 如果arr[i] < num，则arr[i]和arr[Index_Smaller]的值交换，Index_Smaller++，i++；

**规则2： **如果arr[i] > num，则arr[i]和arr[Index_Bigger]的值交换，Index_Bigger--；

**规则3：** 如果arr[i] = num，则i++；

**规则4：** i比Index_Bigger大则停止。

**注：**

**①如果是分为小和中，这个时候就会有点小问题，如果当比num小的元素没有，就需要特殊处理一下；**

**②规则2中，如果是因为元素比num大而交换位置，不能使i++，因为这个时候从后面区域换过来的数还没有进行比较；**

**③规则4中，i必须要比Index_Bigger大才停止，因为Index_Bigger指示的是大于区域的往前面一个元素，即当前的Index_Bigger对应元素也必须要进行判断和比较。**

#### 代码

```c plus
// 荷兰国旗问题2
void NetherlandsIssue2(vector<int>& arr, const int& num)
{
	int Index_Smaller = 0;
	int Index_Bigger = arr.size() - 1;
	for (int i = 0; i <=Index_Bigger ; i++)
	{
		// 这里循环结束条件一定要取到等号
		if (arr[i] < num)
		{
			// 如果当前数组元素比num小，则将其放到“小区域”中，即和当前指代小区域位置Index_Smaller对应元素进行互换
			Swap(arr, i, Index_Smaller++);
		}
		else if (arr[i] > num)
		{
			// 此处对i进行--操作，以使得下一次进入循环可以继续判断当前位置上刚刚从后面换过来的元素的大小
			Swap(arr, i--, Index_Bigger--);
		}
	}
}

void main()
{
	vector<int> arr = RandVector(10,20,10);
	cout << "原数组：" << endl;
	ShowVector(arr);
	NetherlandsIssue2(arr, 15);
	cout << "新数组：" << endl;
	ShowVector(arr);
	system("pause");
}
```



## 2. 堆排序拓展题目

### 问题1

&emsp;&emsp;已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数组进行排序。

#### 思路 

&emsp;&emsp;准备一个大小为k+1的小根堆（比如k=6，那么此时index为6的数移动到index为0的位置最多需要6次，而再往后的数字不可能在0位置上，**那么0~6范围内必然有一个数在0位置上**），然后从第一个元素开始构建小根堆，那么第一次构建小根堆的时候需要$klogk$的时间复杂度，那么此时，0位置上必然就是排好序的状态。然后每次根据数组的情况，每次多往小根堆内加入一个数组，并对新数执行Heap Insert操作，此时又重新形成小根堆，1位置也排好序...除了第一次，之后每一次排序的时间复杂度仅$logk$，那么该算法的最终时间复杂度为$N \times logk$。

#### 代码实现

``` c plus
void main()
{
	// C++本身提供的优先级队列算法的效果在于，你每次弹出一个数，都是其最小的数
	// 说明每次你添加或删除一个数，它都会自动重新调整为堆
	// 实际上，C++中的优先级队列只是对原容器（比如vector<int>）加上了一些限定，且其默认的优先级队列是大根堆
	priority_queue<int, vector<int>, greater<int>> Heap; // 这样创建的是小根堆，有点反直觉
	// 人为构造一个k为2的数组
	vector<int> arr{2,3,1,4,6,5,10,8,7};
	// 用于指示往arr中放有序数时候的位置
	int index = 0;
	for (int i = 0; i < arr.size(); i++)
	{
		if (Heap.size() == 3)
		{
			// 先得到值
			arr[index++] = Heap.top();
			// 然后pop出堆顶的值
			Heap.pop();
		}
		Heap.push(arr[i]);
	}
	while (Heap.size() != 0)
	{
		// 先得到值
		arr[index++] = Heap.top();
		// 然后pop出堆顶的值
		Heap.pop();
	}
	cout << "有序数组：" << endl;
	ShowVector(arr);
	system("pause");
}
```

#### 性质

**扩容复杂度：** 每次扩容的的代价为$N$，但扩容的次数为$logN$，所以分摊到每次扩容的复杂度为
$$
\frac{NlogN}{N}=logN
$$
**使用系统堆结构：** 仅能进行有限的操作，强行使用某些方法会使得实现代价很高。所以有些情况下，必须要手写堆。

### 比较器

&emsp;&emsp;简而言之，就是函数重载，然后使得结构数据之间能够排序，直接看下面的代码：

``` c plus
struct Student
{
	string name;
	int age = 0;
};

// 定义一个仿函数
struct GreaterStudent
{
	bool operator() (const Student& st1, const Student& st2)
	{
		return st1.age > st2.age;
	}
};

void main()
{
	Student st1{ "James", 2 };
	Student st2{ "Lebron", 3 };
	Student st3{ "Curry", 1 };
	Student st4{ "Kevin", 4 };
	Student st5{ "Jordon", 6 };
	Student st6{ "Lee", 5 };
	Student st7{ "Durant", 10 };
	Student st8{ "Love", 8 };
	Student st9{ "Micheal", 7 };

	vector<Student> arr{ st1, st2, st3, st4, st5, st6, st7, st8, st9 };
	// 采用我们自己定义的排序规则来构建小根堆，这个位置似乎必须放仿函数（因为它需要输入一个类型而非函数名）
	priority_queue<Student, vector<Student>, GreaterStudent> heap;
	int index = 0;
	for (int i = 0; i < arr.size(); i++)
	{
		if (heap.size() == 3)
		{
			arr[index++] = heap.top();
			heap.pop();
		}
		heap.push(arr[i]);
	}
	while (!heap.empty())
	{
		arr[index++] = heap.top();
		heap.pop();
	}
	for (int i = 0; i < arr.size(); i++)
	{
		cout << "Name: " << arr[i].name << ", Age: " << arr[i].age << endl;
	}
	system("pause");
}
```

这段代码用了greater，但实现的却是小根堆，如果依次弹出数据，得到的是升序结果。

​		**而前面为啥说C++的优先级队列有点反直觉呢，看下面的两段代码，其效果是实现降序：**

``` c plus
vector<int> arr{ 3,2,4,1,5,7,8,9,10 };
sort(arr.begin(), arr.end(), greater<int>());
ShowVector(arr);
```

``` c plu
struct Student
{
	string name;
	int age = 0;
};

// 定义一个仿函数
struct GreaterStudent
{
	bool operator() (const Student& st1, const Student& st2)
	{
		return st1.age > st2.age;	// 该定义和C++库中的greater定义也相同
	}
};

void main()
{
	Student st1{ "James", 2 };
	Student st2{ "Lebron", 3 };
	Student st3{ "Curry", 1 };
	Student st4{ "Kevin", 4 };
	Student st5{ "Jordon", 6 };
	Student st6{ "Lee", 5 };
	Student st7{ "Durant", 10 };
	Student st8{ "Love", 8 };
	Student st9{ "Micheal", 7 };
	vector<Student> arr{ st1, st2, st3, st4, st5, st6, st7, st8, st9 };
	sort(arr.begin(), arr.end(), GreaterStudent());
	for (int i = 0; i < arr.size(); i++)
	{
		cout << "Name: " << arr[i].name << ", Age: " << arr[i].age << endl;
	}
	system("pause");
}
```

此处greater的效果在于“大的放前面”，那对堆来说本应该是“大的放上面”，即形成大根堆，但此时实际上形成的是小根堆。



## 3. 表的相关题目

### 1. 判断一个链表是否为回文结构

**[题目]** 给定一个单链表的头结点head，请判断该链表是否为回文结构

**[例子]** 1->2->1，返回true；1->2->2->1，返回true......

**[要求]** 时间复杂度 $O(N)$，空间复杂度 $O(1)$

#### 思路

**基本方案：** 利用栈，先全部入栈，然后弹出，逐个比对，此时时间复杂度满足，但空间复杂度达到 $O(N)$

``` c plus
// 回文问题1——栈实现
bool Plalindrome1(list<int>& lis)
{
	stack<int> stk;
	for (auto it = lis.begin(); it != lis.end(); it++)
	{
		// 将元素依次压入栈
		stk.push(*it);
	}
	for (auto it = lis.begin(); it != lis.end(); it++)
	{
		if (*it == stk.top())
			// 如果栈弹出的元素和迭代器遍历到的结果相同，弹出栈顶元素
			stk.pop();
		else
			// 有一个对不上则返回假
			return false;
	}
	// 所有对比都为真则返回真
	return true;
}

void main()
{
	list<int> lis{ 1,23,3,4,5,6,7,6,5,4,3,23,1 };
	if (Plalindrome1(lis))
	{
		cout << "列表是回文" << endl;
	}
	else
	{
		cout << "列表不是回文" << endl;
	}
	system("pause");
}
```

**改进1：**使用快慢指针，快指针一次走两步，慢指针一次走一步，块指针走到底，满指针走到中间，此时开始，可以**仅将链表的右半部分压入栈**，可以降低空间消耗，**特别注意边界条件**

``` c plus
// 回文问题2——快慢指针+栈实现
bool Plalindrome2(Node* head)
{
	// 如果只有头指针或只有要给元素则直接返回真
	if (head == NULL || head->next == NULL) return true;
	stack<int>stk;
	Node* slwP = head->next;	// 慢指针，初始指向第一个元素结点
	Node* fstP = head;			// 快指针，初始指向头结点
	// 主要是要考虑边界条件，特别是当元素比较少的时候，其实此时就考虑2个元素、3个元素和4个元素的情况即可
	// 我们的目标是，快指针越界的时候，慢指针指在后半区的第一个元素
	while (fstP->next != NULL && fstP->next->next != NULL)
	{
		// 慢指针走一步，快指针走两步
		slwP = slwP->next;
		fstP = fstP->next->next;
	}
	// 此时慢指针必然指向中间元素靠后的那一个元素
	// 然后从该慢指针开始压栈
	while (slwP != NULL)
	{
		stk.push(slwP->data);
		slwP = slwP->next;
	}
	// 然后开始弹出栈中的元素
	slwP = head->next;
	while (!stk.empty())
	{
		if (slwP->data != stk.top())
			return false;
		slwP = slwP->next;
		stk.pop();
	}
	return true;
}

void main()
{
	vector<int> arr{ 4,2,2,4 };
	Node* lis = InitList(arr);
	if (Plalindrome2(lis))
	{
		cout << "列表是回文" << endl;
	}
	else
	{
		cout << "列表不是回文" << endl;
	}
	system("pause");
}
```

**改进2：** 使用快慢指针，但此时，一旦慢指针达到了链表中部，其之后的操作是将后面的链表指向置反，而非压栈，此时不需要额外的空间

``` c plus
// 回文问题3——原地方法实现
bool Plalindrome3(Node* head)
{
	if (head->next->next == NULL || head->next == NULL) return true;
	Node* fstP = head;
	Node* slwP = head->next;
	while (fstP->next != NULL && fstP->next->next != NULL)
	{
		fstP = fstP->next->next;
		slwP = slwP->next;
	}
	// 将就fstP存一下slwP的下一个元素
	fstP = slwP->next;
	// 将中间元素的next指向空，作为之后比较时候的循环退出条件
	slwP->next = NULL;
	while (fstP != NULL)
	{
		// fstP指向的是slwP的下一个结点，此时我们要将slwP的下一个结点指向当前的slwP结点
		// 为了防止fstP的下一个结点的信息丢失，我们必须存储它
		Node* tmpP = fstP->next;
		// 将fstP与slwP连接
		fstP->next = slwP;
		// slwP往后移动一个
		slwP = fstP;
		// fstP往后移动一个
		fstP = tmpP;
	}
	// 记录一下最后一个位置
	Node* tmpP = slwP;
	// 如果中间没有被置为false，则最终返回true
	bool result = true;
	// 重新从第一个元素开始
	fstP = head->next;
	// 此时slwP指向链表的最后一个元素
	while (slwP != NULL)
	{
		if (slwP->data != fstP->data) result = false;
		// 最好不要真的到下一步，否则此时不好处理，其实无所谓，这里想的太差了
		// 这个时候跳出，可以刚好使得slwP指向中间结点（奇数个数）或中间往后一个结点（偶数个数）
		// 而fstP也指向中间结点（奇数个数）或中间往前一个结点（偶数个数）
		if (slwP->next == NULL) break;
		// 向中间迭代
		slwP = slwP->next;
		fstP = fstP->next;
	}
	// 这种情况下，说明原本只有2个结点，并不会修改原链表结构，则直接输出即可
	if (tmpP->next == NULL) return result;
	slwP = tmpP->next;
	// 将最后一个指针的next域置为空
	tmpP->next = NULL;
	Node* tmpPP = slwP->next;
	// 再重新把链表接回去
	while (tmpPP != NULL)
	{
		// tmpP->next表示tmpP的前一个结点，
		slwP->next = tmpP;
		tmpP = slwP;
		slwP = tmpPP;
		tmpPP = tmpPP->next;
	}
	return result;
}

void main()
{
	vector<int> arr{ 2};
	Node* lis = InitList(arr);
	if (Plalindrome3(lis))
	{
		cout << "列表是回文" << endl;
	}
	else
	{
		cout << "列表不是回文" << endl;
	}
	DestroyList(lis);
	system("pause");
}
```

着实难得一，草了都，看下面两张图表示的边界条件：

<img src="C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230306212935647.png" alt="image-20230306212935647" style="zoom:67%;" />

**更好的写法，不得不说还是脑子不好使啊卧槽，主要是后面的部分**

``` c plus
// 回文问题3——原地方法实现
bool Plalindrome3(Node* head)
{
	if (head->next->next == NULL || head->next == NULL) return true;
	Node* fstP = head;
	Node* slwP = head->next;
	while (fstP->next != NULL && fstP->next->next != NULL)
	{
		fstP = fstP->next->next;
		slwP = slwP->next;
	}
	// 将就fstP存一下slwP的下一个元素
	fstP = slwP->next;
	// 将中间元素的next指向空，作为之后比较时候的循环退出条件
	slwP->next = NULL;
	while (fstP != NULL)
	{
		// fstP指向的是slwP的下一个结点，此时我们要将slwP的下一个结点指向当前的slwP结点
		// 为了防止fstP的下一个结点的信息丢失，我们必须存储它
		Node* tmpP = fstP->next;
		// 将fstP与slwP连接
		fstP->next = slwP;
		// slwP往后移动一个
		slwP = fstP;
		// fstP往后移动一个
		fstP = tmpP;
	}
	// 记录一下最后一个位置
	Node* tmpP = slwP;
	// 如果中间没有被置为false，则最终返回true
	bool result = true;
	// 重新从第一个元素开始
	fstP = head->next;
	// 此时slwP指向链表的最后一个元素
	while (slwP != NULL)
	{
		if (fstP->data != slwP->data)
		{
			result = false;
			break;
		}
		fstP = fstP->next;
		slwP = slwP->next;
	}
	fstP = tmpP->next;
	tmpP->next = NULL;
	// 再重新把链表接回去
	while (fstP != NULL)
	{
		// tmpP->next表示tmpP的前一个结点，
		slwP = fstP->next;
		fstP->next = tmpP;
		tmpP = fstP;
		fstP = slwP;
	}
	return result;
}
```





### 2. 将单链表按值划分成左边小、中间相等、右边大的形式

**[题目]** 给定一个单链表的头节点head，节点的值类型是整型，再给定一个整数pivot。实现一个调整链表的函数，将链表调整为左部分都是值小于pivot的节点，中间部分都是值等于pivot的节点，右部分都是值大于pivot的节点。
**[进阶]** 在实现原问题功能的基础上增加如下的要求

**[要求]** 调整后所有小于pivot的节点之间的相对顺序和调整前一样

**[要求]** 调整后所有等于pivot的节点之间的相对顺序和调整前一样[要求]调整后所有大于pivot的节点之间的相对顺序和调整前一样

**[要求]** 时间复杂度请达到 $O(N)$，额外空间复杂度请达到 $O(1)$

#### 思路

**基本方案：** 直接创建一个对应数组，然后在数组内做一个partition即可

``` c plus
// 单链表分割，辅助数组实现
void ListPartition1(Node* head, const int& pivot)
{
	vector<Node*> nodeVec;
	Node* tmpPoint = head->next;
	while (tmpPoint != NULL)
	{
		nodeVec.push_back(tmpPoint);
		tmpPoint = tmpPoint->next;
	}
	// 小区域的Index
	int Index_Small = 0;
	// 大区域的Index
	int Index_Large = nodeVec.size() - 1;
	for (int i = 0; i <= Index_Large; i++)
	{
		if (nodeVec[i]->data < pivot)
		{
			Node* tmpPP = nodeVec[i];
			nodeVec[i] = nodeVec[Index_Small];
			nodeVec[Index_Small++] = tmpPP;
		}
		else if (nodeVec[i]->data > pivot)
		{
			// 交换但是i的索引不能变
			Node* tmpPP = nodeVec[i];
			nodeVec[i] = nodeVec[Index_Large];
			nodeVec[Index_Large--] = tmpPP;
			i--;
		}
	}
	for (int i = 0; i < nodeVec.size() - 1; i++)
	{
		nodeVec[i]->next = nodeVec[i + 1];
	}
	// nodeVec的最后一个结点指向空
	(*nodeVec.rbegin())->next = NULL;
	// 将头结点的next设置为数组地址的第一个
	head->next = nodeVec[0];
}

void main()
{
	vector<int> arr{ 2,2,4,5,6,8,9,3,2,2,1,5,4,3};
	Node* lis = InitList(arr);
	ListPartition1(lis,6);
	Node* tmpP = lis->next;
	while (tmpP != NULL)
	{
		cout << tmpP->data << " ";
		tmpP = tmpP->next;
	}
	cout << endl;
	system("pause");
}
```

**改进：**

``` c plus
// 单链表分割——原地方法实现
void ListPartition2(Node* head, const int& pivot)
{
	Node* ori = head;	// 记录原头结点的位置
	Node* sH = NULL; // 小于链表的头指针
	Node* sT = NULL; // 小于链表的尾指针
	Node* eH = NULL; // 等于链表的头指针
	Node* eT = NULL; // 等于链表的尾指针
	Node* mH = NULL; // 大于链表的头指针
	Node* mT = NULL; // 大于链表的尾指针
	Node* next = NULL; // 存储下一个结点
	// 将头指针指向第一个数据点
	head = head->next;
	// 然后遍历原来的链表，并且将各个结点放到对应的子链表中去
	while (head != NULL)
	{
		next = head->next;
		// 这一步相当于把原链表的结构完全断开，但是否真的有必要？
		head->next = NULL;
		if (head->data < pivot)
		{
			if (sH == NULL)
			{
				// 如果当前子链表中还未连接任何结点，则将其指向当前head
				sH = head;
				sT = head;
			}
			else
			{
				// 经典尾插
				sT->next = head;
				sT = head;
			}
		}
		else if (head->data == pivot)
		{
			if (eH == NULL)
			{
				eH = head;
				eT = head;
			}
			else
			{
				eT->next = head;
				eT = head;
			}
		}
		else
		{
			if (mH == NULL)
			{
				mH = head;
				mT = head;
			}
			else
			{
				mT->next = head;
				mT = head;
			}
		}
		head=next;
	}
	// 思路
	// ①绝对不动各个区域的头指针，主要是sH和eH，它们可以作为最终返回值时候的判据，若最终发现这两个之中的某个为空，就可以直接舍弃它们
	// ②每一步操作都保证，上个区域的尾指针的next指向下一个区域的首结点，且末尾区域的尾结点指向整个结果链表的最后一个结点
	// 且注意，可以这样理解，每次拼接之后，整体链表的头指针和尾指针都只有一个
	// 然后将三个链表连起来
	if (sT != NULL)
	{
		// 如果小区域存在，直接进来把等于区域的头结点连在小区域尾结点的后面
		sT->next = eH;
		// 执行该语句之后，eT要么指向小于区域的最后一个结点，要么指向其本身区域内的结点（如果有）
		eT = eT == NULL ? sT : eT;
	}
	if (eT != NULL)
	{
		// 只要执行了上一个if语句的内部语句，就一定会执行这一个语句
		eT->next = mH;
	}
	// 如果小于和等于区域均为空，则直接返回mH，此时不管大于区域中是否有结点，结果都正确
	ori->next = sH != NULL ? sH : (eH != NULL ? eH : mH);
	head = ori;
}

void main()
{
	vector<int> arr{ 2,2,4,5,6,8,9,3,2,2,1,5,4,3};
	Node* lis = InitList(arr);
	ListPartition2(lis,6);
	Node* tmpP = lis->next;
	while (tmpP != NULL)
	{
		cout << tmpP->data << " ";
		tmpP = tmpP->next;
	}
	cout << endl;
	system("pause");
}
```



### 3. 复制含有随机指针节点的链表

**[题目]** 一种特殊的单链表节点类描述如下

``` c plus
class dNode
{
    int data;
	Node* next;
	Node* rand;
    dNode(int data)
    {
    	this->data = data;
	}
};
```

​		rand指针是单链表节点结构中新增的指针，rand可能指向链表中的任意一个节点，也可能指向NULL。给定一个由Node节点类型组成的无环单链表的头节点head，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点。
**[要求]** 时间复杂度 $O(N)$，额外空间复杂度 $O(1)$

#### 准备工作

``` c plus
// 带rand指针的链表结点
struct dNode
{
	int data;
	dNode* next;
	dNode* rand;
	dNode(int data = 0)
	{
		this->data = data;
	}
};

// 用数组创建链表
dNode* InitDList(const vector<int>& arr) 
{
	dNode* result = new dNode;
	result->next = NULL;
	result->rand = NULL;	// 将头结点的rand置为空
	vector<dNode*> tmpVec;	// 用这个vec来存储结点，以随机生成rand指向
	for (auto& elem : arr)
	{
		dNode* tmpNode = new dNode(elem);	// 创建结点
		tmpVec.push_back(tmpNode);			// 推入数组
		dNode* tmpP = result->next;
		result->next = tmpNode;				// 新节点接在头结点后面
		tmpNode->next = tmpP;
	}
	dNode* tmpP = result->next;		// 从首元素开始设置，而不设置头结点的rand
	while (tmpP != NULL)
	{
		// 得到一个不与当前结点相等的结点tmpPP，并将其作为当前结点的rand指向
		dNode* tmpPP = tmpVec[RandInt(0, tmpVec.size() - 1)];
		while (tmpP == tmpPP)
			tmpPP = tmpVec[RandInt(0, tmpVec.size() - 1)];
		tmpP->rand = tmpPP;
		tmpP = tmpP->next;
	}
	return result;
}

void ShowDList(dNode* head)
{
	// 从首元素开始遍历
	dNode* tmpP = head->next;
	int index = 0;
	while (tmpP != NULL)
	{
		cout << "The " << ++index << "th Node, its value is: " << tmpP->data << ", and its rand's value is: " << tmpP->rand->data<<endl;
		tmpP = tmpP->next;
	}
}

// 销毁链表
void DestroyDList(dNode* head)
{
	while (head != NULL)
	{
		// 如果当前头结点不为空
		// 创建一个临时指针存储下一个结点
		dNode* tmpPoint = head->next;
		// 删除当前结点数据
		delete head;
		// 迭代操作
		head = tmpPoint;
	}
}
```



#### 思路

**基本方案：** 用Hash表，我这脑子，是用原链表结点的地址作为key，但对应key上的value是新结点

``` c plus
// 复制结点含有任意指针的链表——哈希表实现
dNode* CopyListWithRand1(dNode* head)
{
	// 创建复制结果链表的头结点
	dNode* result = new dNode;
	result->next = NULL;
	// 创建一个key为原链表地址，value为新链表地址的hash表
	unordered_map<dNode*, dNode*> hashMp;
	// oriP用于指代待复制的链表
	dNode* oriP = head->next;
	while (oriP != NULL)
	{
		// 创建新结点
		dNode* newP = new dNode(oriP->data);
		// 哈希表插入对应元素
		hashMp.insert(make_pair(oriP, newP));
		oriP = oriP->next;
	}
	oriP = head->next;
	// 重新遍历原链表，创建新链表的连接关系
	while (oriP != NULL)
	{
		// 很好玩，hashMp取出的都是新复制的结点
		hashMp[oriP]->next = hashMp[oriP->next];
		hashMp[oriP]->rand = hashMp[oriP->rand];
		oriP = oriP->next;
	}
	result->next = hashMp[head->next];
	return result;
}
```

**改进：**将新链表的结点直接接在对应原链表结点的后面，那么遍历的时候就两个结点两个结点地遍历即可

``` c plus
// 复制结点含有任意指针的链表——将新结点连在原对应结点的后面
dNode* CopyListWithRand2(dNode* head)
{
	// 创建复制结果链表的头结点
	dNode* result = new dNode;
	result->next = NULL;
	// 创建临时指针指向首元素结点
	dNode* oriP = head->next;
	while (oriP!= NULL)
	{
		// 复制创建新结点
		dNode* newP = new dNode(oriP->data);
		// 将新节点插入到原对应结点的后面
		dNode* tmpP = oriP->next;
		oriP->next = newP;
		newP->next = tmpP;
		// 继续迭代
		oriP = newP->next;
	}
	oriP = head->next;
	// 重新遍历，建立rand关系
	while (oriP!=NULL)
	{
		// 因为原结点的next就是对应新复制结点，真滴牛皮
		oriP->next->rand = oriP->rand->next;
		// 注意，这里迭代要走两步
		oriP = oriP->next->next;
	}
	oriP = head->next;
	// 记录新链表的头结点
	result->next = oriP->next;
	// 再次遍历，将新链表和原链表分开
	// 仔细思考最后时刻的边界条件，此时原链表最后一个结点的next还接着新链表的最后一个结点，所以需要用->next先读到新链表的最后一个元素
	while (oriP->next->next != NULL)
	{
		dNode* tmpP;
		// tmpP指向对应复制结点
		tmpP = oriP->next;
		// tmpP->next原链表oriP的下一个结点
		oriP->next = tmpP->next;
		// oriP->next->next指向当前新结点的下一个新节点
		tmpP->next = oriP->next->next;
		// 直接指向下一个即可
		oriP = oriP->next;
	}
	// 这一步就把新链表完全断开
	oriP->next = NULL;
	return result;
}

void main()
{
	cout << "===============复制前原链表=================" << endl;
	vector<int>arr{ 5,15,5,8,44,66,7,8,9,10,29 };
	dNode* head = InitDList(arr);
	ShowDList(head);
	cout << "===============复制后新链表=================" << endl;
	dNode* cpHead = CopyListWithRand2(head);
	ShowDList(cpHead);
	cout << "===============复制后原链表=================" << endl;
	ShowDList(head);
	system("pause");
}
```

**注：上述代码的实现和原文不同，可以考虑之后再看一下。**

### 4. 两个单链表相交的一系列问题

**[题目]** 给定两个可能有环也可能无环的单链表，头节点head1和head2。请实现一个函数，如果两个链表相交，请返回相交的第一个节点。如果不相交，返回NULL，其中相交的意思表示两个链表共用一个结点。
**[要求] **如果两个链表长度之和为N，时间复杂度请达到 $O(N)$，额外空间复杂度请达到 $O(1)$。

#### 思路

**问题1：**如何确定一个链表中是否有环。**如果一个单链表有环，沿着链表走，绝对不可能存在NULL。**

**解决方法1：**使用哈希表，可以快速查找当前结点是否已经存在于哈希表内；

**解决方法2：**采用快慢指针的方法。

1）如果链表无环，快指针一定会首先达到NULL；

2）如果链表有环，快指针一定会和慢指针相遇，且快指针和慢指针相遇时候的圈数不会超过两圈；

3）在快慢指针第一次相遇之后，快指针指向第一个元素结点，慢指针停下，然后同时一步一步地走，最后两者一定相遇于入环结点（两个指针的next指向它）。

``` c plus
// 查找链表的第一个入环结点，如果无环返回NULL
Node* GetLoopNode(Node* head)
{
	if (head == NULL || head->next == NULL)return NULL;
	// 现在至少有一个结点
	Node* fstP = head->next;	// 快指针
	Node* slwP = head->next;	// 慢指针
	// 注：对于该问题，fstP->next->next!=NULL和fstP!=NULL条件等价不等价，因为fstP是有可能指向链表的最后一个结点的
	while (fstP != NULL && fstP->next != NULL)
	{
		// 铸币吧，这里要先动，不然直接完蛋
		slwP = slwP->next;
		fstP = fstP->next->next;
		// 如果快指针追上了慢指针，说明有环，跳出循环
		if (fstP == slwP)break;
	}
	// 说明该链表无环
	if (fstP == NULL || fstP->next == NULL) return NULL;
	fstP = head->next;
	while (fstP != slwP)
	{
		fstP = fstP->next;
		slwP = slwP->next;
	}
	return fstP;
}
```

**问题2：**

**情况1：**如果两条链表均无环，那么两者如果相交，则从某一个结点开始往后都为两链表共有。那么可以确定规则：

1）如果两链表的末尾结点不同，那么两者一定不相交；

2）长链表先走两链表长度的差值步，之后再一起走，两链表的遍历一定可以达到同步；

3）返回两个遍历指针的共同指向结点。

**情况2：**不存在一条链表有环一条链表无环且两者还相交的情况。

**情况3：**如果两条链表均有环，此时有三种情况：

1）两者相交且入环结点是一个，这种情况可以简化为无环链表的相交问题，只是要把终止结点分别视为两者的入环结点即可；

2）两者相交且入环结点不同，从两条链表中的任意一个入环结点开始遍历，如果遍历一圈能够找到另一个链表的入环结点，则可以返回两个入环结点中的任意一个；

3）两者不相交，2）情况中，遍历一圈无法识别到另一链表的入环结点。

``` c plus]

// 返回两个链表均无环情况下的相交结点，如果无相交，则返回NULL
Node* NoLoop(Node* head1, Node* head2)
{
	Node* pt1 = head1->next;
	Node* pt2 = head2->next;
	// 用这个数来统计两条链表之间长度的差距
	int n = 0;
	while (pt1->next != NULL)
	{
		// 注意，这里我们的目标是找最后一个结点，所以判断条件是->next
		n++;
		pt1 = pt1->next;
	}
	while (pt2->next != NULL)
	{
		n--;
		pt2 = pt2->next;
	}
	// 如果两条链表的终止结点不同，说明两者必然不相交
	if (pt1 != pt2) return NULL;
	// 然后将pt1指向长链表，pt2指向短链表
	pt1 = n > 0 ? head1->next : head2->next;
	pt2 = pt1 == head1->next ? head2->next : head1->next;
	// n一定需要是一个正数......
	n = abs(n);
	while (n != 0)
	{
		n--;
		pt1 = pt1->next;
	}
	while (pt1 != pt2)
	{
		pt1 = pt1->next;
		pt2 = pt2->next;
	}
	return pt1;
}

// 返回两个链表均有环情况下的相交结点，如果无相交，则返回NULL
Node* BothLoop(Node* head1, Node* loop1, Node* head2, Node* loop2)
{
	if (loop1 == loop2)
	{
		// 如果两有环链表的入环结点相同，此时简化为无环链表求相交结点问题
		// 注：找的是第一个相交结点，而两条链表不一定是在入环结点处才相交
		int n = 0;
		Node* p1 = head1->next;
		Node* p2 = head2->next;
		while (p1 != loop1)
		{	
			n++;
			p1 = p1->next;
		}
		while (p2 != loop2)
		{
			n--;
			p2 = p2->next;
		}
		p1 = n > 0 ? head1->next : head2->next;
		p2 = p1 == head1->next ? head2->next : head1->next;
		n = abs(n);
		while (n != 0)
		{
			n--;
			p1 = p1->next;
		}
		while (p1 != p2)
		{
			p1 = p1->next;
			p2 = p2->next;
		}
		return p1;
	}
	else
	{
		// 此时两者入环结点不同，只需要让一个指针从某个入环结点开始遍历环即可判断
		// 注，此时两者的交叉结点不可能在入环结点
		Node* p1 = loop1->next;
		while (p1 != loop1)
		{
			// 注：这个遍历不会遍历到入环结点！
			// 这里可以返回p1也可以返回loop1，两者均为第一个相交结点，只是loop1离head1更近，而loop2离head2更近
			if (p1 == loop2) return p1;
			p1 = p1->next;
		}
		return NULL;
	}
}

// 查找两条链表是否有相交结点
Node* GetIntersectNode(Node* head1, Node* head2)
{
	Node* loop1 = GetLoopNode(head1);
	Node* loop2 = GetLoopNode(head2);
	// 如果两者均为无环链表
	if (loop1 == NULL && loop2 == NULL)
		return NoLoop(head1, head2);
	else if ((loop1 != NULL) && (loop2 != NULL))
	{
		// 如果两者均为有环链表
		return BothLoop(head1, loop1, head2, loop2);
	}
	else
		// 其它情况均无交点
		return NULL;
}
```

**测试主函数——无环**

``` c plus
void main()
{
	srand(time(0));
	vector<int>arr1{ 3,4,6,8,9,1 };
	vector<int>arr2{ 33,43,55,64 };
	// ======= 无环链表测试 ======= //
	Node* list1 = InitList(arr1);
	Node* pt1 = list1->next;
	// 基于链表创建一个结点数组
	vector<Node*> vec_list1;
	while (pt1 != NULL)
	{
		vec_list1.push_back(pt1);
		pt1 = pt1->next;
	}
	Node* list2 = InitList(arr2);
	// 将链表2的最后一个结点的next指针指向链表1的任意某个结点
	EndPointer(list2)->next = vec_list1[0, RandInt(0, vec_list1.size() - 1)];
	ShowList(list1);
	cout << "==================================================" << endl;
	ShowList(list2);
	cout << "================= 查找结果 =================" << endl;
	Node* interNode = GetIntersectNode(list1, list2);
	ShowNode(interNode);
	system("pause");
}
```

**测试主函数——有环**

``` c plus
void main()
{
	srand(time(0));
	vector<int>arr1{ 3,4,6,8,9,1 };
	vector<int>arr2{ 33,43,55,64 };
	// ======= 有环链表测试 ======= // 
	Node* list1 = InitList(arr1);
	Node* pt1 = list1;
	// 基于链表创建一个结点数组
	vector<Node*> vec_list1;
	while (pt1 != NULL)
	{
		vec_list1.push_back(pt1);
		pt1 = pt1->next;
	}
	// 将原来的list1连成一个循环列表
	LoopList(list1);
	cout<< endl;
	Node* list2 = InitList(arr2);
	// 将链表2的最后一个结点的next指针指向链表1的任意某个结点
	EndPointer(list2)->next = vec_list1[0, RandInt(0, vec_list1.size() - 1)];
	ShowList(list1);
	cout << "==================================================" << endl;
	ShowList(list2);
	cout << "================= 查找结果 =================" << endl;
	Node* interNode = GetIntersectNode(list1, list2);
	ShowNode(interNode);
	// 输出20个list1元素
	pt1 = list1->next;
	for (int i = 0; i < 20; i++)
	{
		cout << pt1->data << " ";
		pt1 = pt1->next;
	}
	cout << endl;
	// 输出20个list2元素
	pt1 = list2->next;
	for (int i = 0; i < 20; i++)
	{
		cout << pt1->data << " ";
		pt1 = pt1->next;
	}
	system("pause");
}
```

## 4. 二叉树的相关题目

### 4.1 查找二叉树的最大宽度

**方法1：采用哈希表记录结点层数作为辅助，这么做的前提条件是宽度优先遍历，故下一层的结点在遍历之前一定可以在map中被确定其对应的层数。**

``` c plus
TNode* ConstructTree()
{
	// 构造一棵二叉树
	TNode* head = new TNode(5);
	head->left = new TNode(3);
	head->right = new TNode(8);
	head->left->left = new TNode(2);
	head->left->right = new TNode(4);
	head->left->left->left = new TNode(1);
	head->right->left = new TNode(7);
	head->right->left->left = new TNode(6);
	head->right->right = new TNode(10);
	head->right->right->left = new TNode(9);
	head->right->right->right = new TNode(11);
	head->left->left->right = new TNode(23);
	// 构造的是这样的树
	//                               5
	//                       3                 8
	//                     2   4            7    10
	//                    1 23             6    9  11
	return head;
}

// 宽度优先遍历——哈希表实现
int MaxWidth(TNode* head)
{
	// 准备一个哈希表，用于保存各个结点对应的层数
	unordered_map<TNode*, int> hsMp;
	// 由于头结点在第一层，则直接将其推入
	hsMp.insert(make_pair(head, 1));
	queue<TNode*> que;
	que.push(head);
	// 用于指示当前在统计的层数，我们不是有个哈希表在记录结点的层数吗，如果两者不同，说明到下一层了，则需要更新curLevel
	int curLevel = 1;
	int curNode = 0;
	int maxNode = INT_MIN;
	while (!que.empty())
	{
		// 结点出队
		head = que.front();
		que.pop();
		if (hsMp[head] == curLevel)
		{
			// 是当前层的结点，则当前层的结点数++
			curNode++;
		}
		else
		{
			// 如果当前出队的结点已经不是当前层结点了，则当前层的指标++
			curLevel++;
			// 并且记录上一层的结点数（看是否是最大）
			maxNode = max(maxNode, curNode);
			// 重置为1，因为此时已经发现了一个结点了
			curNode = 1;
		}

		// 将结点的左右孩子分别入队
		if (head->left != NULL)
		{
			que.push(head->left);
			hsMp.insert(make_pair(head->left, curLevel + 1));
		}
		if (head->right != NULL)
		{
			que.push(head->right);
			hsMp.insert(make_pair(head->right, curLevel + 1));
		}
	}
	// 这个地方必须加这一句，因为在原代码中，每次是在换层的时候才想起去统计上一层的结点结果，但是最后一层无法换层
	maxNode = max(maxNode, curNode);
	return maxNode;
}
```

**方法2：仅使用额外变量，这主要利用了队列可以使得树在遍历的过程中逐层有序的性质，那么我们就可以轻松地记录当前层的最后一个结点，并以此为依据进行换层操作。**

``` c plus
// 宽度优先遍历——非哈希表实现
int MaxWidth2(TNode* head)
{
	int maxNode = INT_MIN;
	// que还是用于遍历二叉树
	queue<TNode*> que;
	que.push(head);
	// 用于记录当前层的最后一个结点（即最右边的结点，由于我们从左往右进队，所有队每一层而言，最后出队的一定是最右边的结点）
	TNode* lastNode = head;
	// 用于记录下一层的最后一个结点，这种传递性，好好体会，很有意思
	TNode* lastNode_NextLevel = NULL;
	// 记录当前层的结点数
	int curNode = 1;
	while (!que.empty())
	{
		// 弹出结点
		head = que.front();
		que.pop();
		// 必须要先把当前结点的左右孩子分别入队才行，并且每一次入队，都更新下一层的最后一个结点
		// 这样才能保证，每一次lastNode在换层更新的时候拿到的真的是下一层的最右方的结点
		// 主要问题在于，当前层最后一个结点不一定存在孩子
		if (head->left != NULL)
		{
			que.push(head->left);
			lastNode_NextLevel = head->left;
		}
		if (head->right != NULL)
		{
			que.push(head->right);
			lastNode_NextLevel = head->right;
		}
		if (head == lastNode)
		{
			// 如果当前弹出结点真的是该层的最后一个结点
			// 重新统计最大结点数
			maxNode = max(maxNode, curNode);
			// 更换对应层的最后一个结点
			lastNode = lastNode_NextLevel;
			// 重置当前层的节点数目，还是得重置为1，因为这样的代码不会统计当前层最后一个结点
			curNode = 1;
		}
		else
		{
			curNode++;
		}
	}
	return maxNode;
}

void main()
{
	// 构造二叉树
	TNode* tN = ConstructTree();
	cout<<"最大宽度为："<<MaxWidth2(tN)<<endl;
	system("pause");
}
```

### 4.2 查找两个结点的最低公共祖先

​		即找到两个结点的第一个共同的直接或间接父节点。根结点和任意其它结点的祖先都是它自己

**方法1：**采用哈希表的方法，思路很简单，看代码

``` c plus
// 寻找两个结点的最低共祖先，哈希表实现
TNode* LocateAncestor1(TNode* head, TNode* dest1, TNode* dest2)
{
	if (head == NULL) return NULL;
	// 需要记录这个头结点，之后要用到
	TNode* root = head;
	// 该哈希表用于存储各个结点的父节点，key值为对应的结点，value值为对应的父节点
	unordered_map<TNode*, TNode*> fatherMap;
	// 先将头结点的father设置为它本身
	fatherMap.insert(make_pair(head, head));
	// 该栈用于实现遍历过程，用前序遍历实现
	stack<TNode*>stk;
	stk.push(head);
	while (!stk.empty())
	{
		// 注：C++中由于pop函数没有返回值，所以先访问top，然后再pop就等价于弹出操作
		head = stk.top();
		stk.pop();
		if (head->right != NULL)
		{
			fatherMap.insert(make_pair(head->right, head));
			stk.push(head->right);
		}
		if (head->left != NULL)
		{
			fatherMap.insert(make_pair(head->left, head));
			stk.push(head->left);
		}
	}
	// 用一个哈希表来记录从结点1往上找的所有祖先结点
	unordered_set<TNode*> fatherSet1;
	// 将本身推进去，此时如果dest1和dest2是同一个结点，也能够得到正确的结果
	fatherSet1.insert(dest1);
	while (dest1 != root)
	{
		TNode* father = fatherMap[dest1];
		fatherSet1.insert(father);
		dest1 = father;
	}
	// 然后沿着结点2往上找，找到第一个在fatherSet1中的结点，则这就是它们的最低共结点
	while (fatherSet1.find(dest2) == fatherSet1.end())
	{
		// 找不到就一直网上找
		dest2 = fatherMap[dest2];
	}
	if (fatherSet1.find(dest2) == fatherSet1.end())
		// 说明没有找到共同的祖先
		return NULL;
	else
		// 则直接返回dest2，说明它此时就是共同祖先
		return dest2;
}
```

**方法2：**递归思想，其实也不难，看代码就懂

``` c plus
// 寻找两个结点的最低共祖先，递归实现
TNode* LocateAncestor2(TNode* head, TNode* dest1, TNode* dest2)
{
	// 这个最基本条件，如果头结点为空，或者它是dest1或者dest2，就直接返回
	if (head == NULL || head == dest1 || head == dest2)return head;
	// 递归，分别在左右子树上面去找dest1和dest2两个结点，如果有，它们肯定会返回对应结点的位置，如果没有肯定返回空
	TNode* leftReturn = LocateAncestor2(head->left, dest1, dest2);
	TNode* rightReturn = LocateAncestor2(head->right, dest1, dest2);
	if (leftReturn != NULL && rightReturn != NULL)
		// 说明以当前结点为起始，往下的子树上，一定会同时存在dest1和dest2
		// 而至于为什么不会把更上面的父亲返回，是因为对二叉树，一个结点最多只有两个分支，所以再往上也仅会返回在这个位置找到的结点地址
		return head;
	// 最后返回两边结点返回值中，不为空的那一个
	return leftReturn ? leftReturn : rightReturn;
}
```

### 4.3 找到二叉树中结点的后继节点

**现在有一个新的二叉树节点结构：**

``` c plus
// ===== 寻找后续结点问题 ===== //
struct TNNode
{
	TNNode* left = NULL;
	TNNode* right = NULL;
	// 和一般的二叉树相比，该树的结点含有parent指针
	TNNode* parent = NULL;
	int data;
	// 现在用的指针常量，也就是说，指针的指向不能改变，这是符合我们直观认知的，即不能进行left = xxx这种句式
	TNNode(const int& data, TNNode* const& parent) :data(data), parent(parent) {};
};

// 构造一个我们需要的二叉树
TNNode* ConstructBT()
{
	// 构造一棵完全二叉树
	TNNode* head = new TNNode(5, NULL);

	head->left = new TNNode(3, head);
	head->right = new TNNode(8, head);

	head->left->left = new TNNode(2, head->left);
	head->left->left->left = new TNNode(1, head->left->left);

	head->right->left = new TNNode(7, head->right);
	head->right->right = new TNNode(10, head->right);

	// 构造的是这样的树
	//                               5
	//                       3                 8
	//                     2                7    10
	//                    1        
	return head;
}
```

**问题：**后继节点即在中序遍历情况下，在当前节点之后遍历的那个节点。

**思路：**如下图所示

<img src="C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230311212531321.png" alt="image-20230311212531321" style="zoom:67%;" />

红色的节点是给定节点，橙色节点是对应的目标节点，分为两种情况：

**1）当前节点有右子树，**那么下一个节点一定在该右子树的最左边节点上（很好想，根访问了肯定访问右子树，进而访问该右子树的最左边结点）；

**2）当前节点无右子树，**那么下一个节点一定在该节点不断网上搜索的过程中，找到第一个节点是其父结点左结点时（否则说明当前结点是右孩子，那么其父节点在之前肯定就被访问过了），对应该结点的父节点，值得注意的是，如果一直找一直找，都找到该树的根结点了，此时依然没有找到一个子结点其是父节点的左孩子的情况，那么此时当前结点就一定是最后的一个结点了。

``` c plus
// 找到给定节点最左边的节点
TNNode* FindRightNode(TNNode* head)
{
	// 不用空判断，必然不为空
	TNNode* pt = head;
	while (pt->left != NULL)
		pt = pt->left;
	return pt;
}

// 查找后继
TNNode* FindNextNode(TNNode* head, TNNode* dest)
{
	TNNode* pt = dest;
	// 如果树是空的，或者给的目标节点是空的，都直接返回空
	if ((head == NULL) || (pt == NULL)) return NULL;
	if (pt->right != NULL)
	{
		// 该节点含有右子树，那么我们要找出这个右子树上的最左边节点
		return FindRightNode(pt->right);
	}
	else
	{
		// 该节点不含有右子树，那么我们要向上找，找到第一个节点是其父节点的左孩子的节点，再返回其父节点
		while (pt->parent != NULL && pt != pt->parent->left)
		{
			pt = pt->parent;
		}
		// 此时直接返回父亲节点，刚好，可以囊括没找到的情况和找到了的情况
		return pt->parent;
	}
}

void main()
{
	// 构造的是这样的树
	//                               5
	//                       3                 8
	//                     2                7    10
	//                    1   
	TNNode* head = ConstructBT();
	// 情况1，找不到后继
	TNNode* dest = head->right->right;
	TNNode* fd1 = FindNextNode(head, dest);
	if (fd1)
	{
		cout << "The dest node's data is: " << dest->data << ", the followed node's data is: " << fd1->data << endl;
	}
	else
		cout << "No followed node!" << endl;
	// 情况2，无右树，后续节点应该是2
	dest = head->left->left->left;
	fd1 = FindNextNode(head, dest);
	if (fd1)
	{
		cout << "The dest node's data is: " << dest->data << ", the followed node's data is: " << fd1->data << endl;
	}
	else
		cout << "No followed node!" << endl;
	// 情况3，有右树，后续节点应该是10
	dest = head->right;
	fd1 = FindNextNode(head, dest);
	if (fd1)
	{
		cout << "The dest node's data is: " << dest->data << ", the followed node's data is: " << fd1->data << endl;
	}
	else
		cout << "No followed node!" << endl;
	system("pause");
}
```



### 4.4 二叉树的序列化和反序列化

**思路：**简而言之，用字符串存储一个二叉树，用#_代表空，data\_表示节点数据。非常简单，任意选取一种遍历的形式，完成序列化和反序列化即可。

``` c plus
// 序列化和反序列化
string SerialByPre(TNode* head)
{
    // 这个边界非常关键
	if (head == NULL) return "#_";
	string result;
	// 前序遍历
	result += (to_string(head->data) + "_");
	result += SerialByPre(head->left);
	result += SerialByPre(head->right);
	return result;
}

// 主要函数
TNode* ReconByPreString(const string& preStr)
{
	// 用"_"分隔符来划分字符串
	vector<string> strVec = mStringHandler(preStr).split("_");
	queue<string> que;
	for (auto& item : strVec)
		que.push(item);
	return ReconByOrederedQueue(que);
}

// 用于用生成的有序队列来挨个弹出队头的元素，然后生成对应的节点
// 这个队列必须是引用方式，因为要在递归的过程中不断变化
// 最好是用队列，用数组也能实现，那么此时每次都要用除了第一个元素以外的所有元素重新构建数组，代价太大
TNode* ReconByOrederedQueue(queue<string>& que)
{
	string str = que.front();
	que.pop();
    // 这个边界非常关键
	if (str == "#")return NULL;
	// 创建新的节点
	TNode* head = new TNode(fromString<int>(str));
	head->left = ReconByOrederedQueue(que);
	head->right = ReconByOrederedQueue(que);
	return head;
}

void main()
{
	TNode* tr = ConstructCBT();
	string str = SerialByPre(tr);
	cout << "The string constructed is: " << str << endl;
	cout << "The pre iterated result:" << endl;
	PreOrderRecur1(tr);
	TNode* trRecon = ReconByPreString(str);
	cout << endl;
	cout << "The pre iterated result reconstructed:" << endl;
	PreOrderRecur1(trRecon);
	cout << endl;
	system("pause");
}
```



### 4.5 折纸问题

**问题简述：**简而言之，将一张长条纸进行对折

**对折一次：**纸条中间出现一条凹痕；

**对折二次：**出现序列：2凹、1凹、2凸

**对折三次：**出现序列：3凹、2凹、3凸、1凹、3凹、2凸、3凸

​		即除了第一次对折，之后的每一次对折，会在**叶子节点**对应的痕的左边产生一条凹痕，而右边产生一条凸痕，则可以采用满二叉树的思想来解这个问题。

``` c plu
// 折纸问题，给出对折的次数，输出折纸的序列关系
void PrintAllFolds(const int& N)
{
	// 第一个参数给1表示从第一层对折对应的痕迹开始打印
	// 最后一个参数表示第一次对折产生的痕迹是凹的
	PrintProcess(1, N, true);
}

// 可以看到函数中，l并不参与任何具体内容的打印，其只是影响打印的次数
// 比如如果l设置为2，那么如果N给3，此时仅会产生对折2次的痕迹结果，因为此时仅仅递归调用一次
// N表示对折的总次数，那么l不能大于N，down为true表示是凹痕，down为false表示是凸痕
void PrintProcess(const int& l, const int& N, const bool& down)
{
	// 对l超过N的情况，此时不能打印了，直接返回
	if (l > N) return;
	// 因为左边一定会产生凹痕，所以第三个参数为true
	PrintProcess(l + 1, N, true);
	// 最终凹痕在纸条上的分布顺序实际上就是中序遍历二叉树的顺序
	cout << (down ? "凹" : "凸") << " ";
	PrintProcess(l + 1, N, false);
}

void main()
{
	PrintAllFolds(4);
	cout << endl;
	system("pause");
}
```



## 5. 前缀树

**概念：**对应于创建前缀码，意为所有的Code都不是其它Code的前缀。

**创建思路：**查看所有字符串，对每一个字符串，看其对应的各个字符能否沿着前缀树中找到，如果找不到，就直接创建新的，新结点的pass值为1，之后每有字符串需要经过它，pass值++；如果能找到，也就是说明当前有另外的字符串要经过它了。

**案例：**比如有以下的数组
$$
['abc', 'ab', 'bc', 'bck']
$$
其最终建立的前缀树为

<img src="C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230321152142934.png" alt="image-20230321152142934" style="zoom:67%;" />



我们可以很容易查询到以'ab'为前缀的词有2个，其就是左树中，'b边'下一个结点的p值。

``` c plu
// 前缀树类
class TrieTree
{
public:
    // 根节点
    TrieNode* root;
    TrieTree()
    {
        root = new TrieNode;
    }
    // 插入结点
    
    void TrieTree::Insert(const string& str)
    {
        // 得到该字符串的所有单个字符
        vector<char> chars = mStringHandler(str).chars();
        // 为了不修改原根结点指针的指向，创建一个新的指针
        TrieNode* tmpN = root;
        // 要插入新结点，则根结点的pass必然++
        tmpN->pass++;
        for (int i = 0; i < chars.size(); i++)
        {
            // index是chars[i]和a之间的ASCLL码差值
            int index = chars[i] - 'a';
            if (tmpN->nexts[index] == NULL)
            {
                // 说明对应字符在当前结点处还没被创建
                TrieNode* newNode = new TrieNode();
                // 把新创建的结点连给上一层的结点
                tmpN->nexts[index] = newNode;
            }
            // tmpN指向下一层的结点，并将其pass++
            tmpN = tmpN->nexts[index];
            tmpN->pass++;
        }
        // 意味着如果没有经过上面的循环，就是根节点直接end++，此时插入了一个空字符
        tmpN->end++;
    }

    int TrieTree::Search(const string& str)
    {
        TrieNode* tmpN = root;
        vector<char> chars = mStringHandler(str).chars();
        for (int i = 0; i < chars.size(); i++)
        {
            int index = chars[i] - 'a';
            if (tmpN->nexts[index] == NULL)
            {
                // 当前结点的下一个没有办法找到对应字符了，说明可以直接返回0，说明没有加入过该词
                return 0;
            }
            // 否则继续找下去
            tmpN = tmpN->nexts[index];
        }
        return tmpN->end;
    }

    int TrieTree::PrefixNumber(const string& pre)
    {
        TrieNode* tmpN = root;
        vector<char> chars = mStringHandler(pre).chars();
        // 和找一个词出现过几次的差距仅仅在于是返回pass还是返回end
        for (auto it = chars.begin(); it != chars.end(); it++)
        {
            int index = *it - 'a';
            if (tmpN->nexts[index] == NULL)
            {
                return 0;
            }
            tmpN = tmpN->nexts[index];
        }
        return tmpN->pass;
    }

    // 删除某个字符串
    void TrieTree::Delete(const string& pre)
    {
        // 先判断是否真的有当前字符串
        if (Search(pre) == 0)return;
        TrieNode* tmpN = root;
        // 记得把头结点的pass--
        tmpN->pass--;
        vector<char>chars = mStringHandler(pre).chars();
        for (int i = 0; i < chars.size(); i++)
        {
            int index = chars[i] - 'a';
            // 如果有一个结点为空了，则直接在这一个if中处理完
            if (--(tmpN->nexts[index]->pass) == 0)
            {
                TrieNode* delN = tmpN->nexts[index];
                // 记得把当前结点的next[index]置为空，说明没有了
                tmpN->nexts[index] = NULL;
                for (int j = i; j < chars.size() - 1; j++)
                {
                    // 拿到下一个结点
                    TrieNode* lastN = delN->nexts[chars[j + 1] - 'a'];
                    // 删除当前结点
                    delete delN;
                    // 更新结点
                    delN = lastN;
                }
                // 删除最后一个结点
                delete delN;
                return;
            }
            tmpN = tmpN->nexts[index];
        }
        // 不需要删除结点的情况下，才需要进行end--
        tmpN->end--;
    }

    // 将当前还存在的结点全部析构
    TrieTree::~TrieTree()
    {
        // 用该队来释放空间
        queue<TrieNode*> que;
        que.push(root);
        while (!que.empty())
        {
            TrieNode* tmpN = que.front();
            que.pop();
            // 通过循环，把所有存在结点全部入队
            for (int i = 0; i < tmpN->nexts.size(); i++)
            {
                if (tmpN->nexts[i] != NULL)
                    que.push(tmpN->nexts[i]);
            }
            // 然后将当前结点释放
            delete tmpN;
        }
    }
    };

void main()
{
    Solutions::TrieTree tt;
    tt.Insert("jamesbrady");
    tt.Insert("jamesharden");
    tt.Insert("jastinbiber");
    tt.Insert("stephencurry");
    tt.Insert("stephenhoopking");
    cout << "The number of prefix james: " << tt.PrefixNumber("james") << endl;
    cout << "The number of prefix ja: " << tt.PrefixNumber("ja") << endl;
    cout << "The number of prefix step: " << tt.PrefixNumber("step") << endl;
    tt.Delete("jastinbiber");
    cout << "The number of prefix ja: " << tt.PrefixNumber("ja") << endl;
    cout << "The number of jamesbrady: " << tt.Search("jamesbrady") << endl;
    tt.Delete("jamesbrady");
    cout << "The number of jamesbrady: " << tt.Search("jamesbrady") << endl;
    cout << "The number of kevindurant: " << tt.Search("kevindurant") << endl;
    system("pause");
}
```

## 6. 贪心算法

**概念：**贪心算法在某一个标准下，优先考虑最满足标准的样本，最后考虑最不满足标准的样本，最终得到一个答案的算法，叫作贪心算法。

​		也就是说，不从整体最优上加以考虑，所做出的是在某种意义上的局部最优解。

**解题策略：**贪心算法的在笔试时的解题套路

1. 实现一个不依靠贪心策略的解法X，可以用最暴力的尝试
2. 脑补出贪心策略A、贪心策略B、贪心策略C...
3. 用解法X和对数器，去验证每一个贪心策略，用实验的方式得知哪个贪心策略正确
4. 不要去纠结贪心策略的证明

### 6.1 会议问题

**问题描述：**一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。给你每一个项目开始的时间和结束的时间（给你一个数组，里面是一个个具体
的项目），你来安排宣讲的日程，要求会议室进行的**宣讲的场次最多**，返回这个最多宣讲场次。

**解题思路：**以所有项目的结束时间点作为标准进行升序排序，然后，每次验证当前时间点是否比序列中最靠前项目的开始时间小，如果是，安排该项目，并将当前时间点置为该项目的结束时间点，循环往复安排即可。

**案例：**如下图所示

![image-20230321201105640](C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230321201105640.png)

最终的结果应该选取上图中的活动1、3、6、7共4种活动即可。

``` c plus
class Program
{
public:
    Program(const int& st, const int& ed) :start(st), end(ed) {}
    int start;
    int end;
};
// 定义项目比较器
class ProgramComparator
{
public:
    bool operator()(const Program& pro1, const Program& pro2)
    {
        // 排序的依据是项目的结束时间
        return pro1.end <= pro2.end;
    }
};

// 贪心算法实现
int BestArrange(const vector<Program>& pros, const int& timePoint)
{
    // 开个新的数组
    auto tmpPros = pros;
    // 记录开了几个会议
    int result = 0;
    // 时间点
    int tmpTimePoint = timePoint;
    // 根据结束时间排序
    sort(tmpPros.begin(), tmpPros.end(), ProgramComparator());
    for_each(tmpPros.begin(), tmpPros.end(), [&](Program pro) {
        cout << "Start time: " << pro.start << ", End time: " << pro.end << endl;
        });
    // 遍历所有项目，看哪些可以安排进去
    for (int i = 0; i < tmpPros.size(); i++)
    {
        if (tmpTimePoint <= tmpPros[i].start)
        {
            cout << "Conference " << i + 1<<", ";
            result++;
            tmpTimePoint = tmpPros[i].end;
        }
    }
    return result;
}

void main()
{
    // 构造数据集
    vector<Program> pros;
    pros.push_back(Program(6, 8));		// 1
    pros.push_back(Program(13, 19));	// 8
    pros.push_back(Program(8, 11));		// 3
    pros.push_back(Program(9, 12));		// 4
    pros.push_back(Program(14, 17));	// 7
    pros.push_back(Program(11, 14));	// 6
    pros.push_back(Program(8, 13));		// 5
    pros.push_back(Program(7, 10));		// 2
    cout << "The most number of the conference that can be completed: " << BestArrange(pros, 6) << endl;
    system("pause");
}
```



### 6.2 字符串拼接问题

**问题描述：**给出一个字符串数组，要求把这些字符串全部拼接起来之后可以实现整体字符串的字典序最小。

**字典序：**在字典中的排序，其遵循以下的规则

​		**规则1：**对长度相同的字符串，逐个比较字符，当某一个位置上，一个字符串对应字符的ASCLL码值比较小的时候，说明该字符串的字典序比较靠前（比较小）；

​		**规则2：**对长度不相同的字符串，把短字符串补成长字符串（用0补），然后以规则1进行对比。

**策略：**

​		在比较两个字符串的拼接的先后顺序时，用以下策略
$$
(a\cdot b) \leq (b\cdot a) \rightarrow a<b\\\
(a\cdot b) > (b\cdot a) \rightarrow a>b
$$
**证明：**

​		先要证明比较具有传递性，然后再证明最小字典序的原理，证明略。

**C++ string自带字典序效果：**

``` c plus
// 定义两个比较器
class LetterComparator_Less
{
public:
	bool operator()(const string& str1, const string& str2)
	{
        // C++中可以直接对string进行大小比较，依据就是两者的字典序
		return str1 < str2;
	}
};

class LetterComparator_Greater
{
public:
	bool operator()(const string& str1, const string& str2)
	{
		return str1 > str2;
	}
};

void main()
{
	string plpsm = "plpsm";
	string abcd = "abcd";
	string abcde = "abcde";
	string bcdef = "bcdef";
	string bcde = "bcde";
	string afhsm = "afhsm";
	string plspm = "plspm";
	string letters[] = { plspm,abcd,abcde,bcdef,bcde,afhsm,plpsm };
	cout << "字符串数组排序前为：" << endl;
	for_each(letters, letters + 7, [&](string str) {
		cout << str << ", ";
		});
	cout << endl;
	sort(letters, letters + 7, LetterComparator_Less());
	cout << "字符串的字典升序排序为：" << endl;
	for_each(letters, letters + 7, [&](string str) {
		cout << str << ", ";
		});
	cout << endl;
	sort(letters, letters + 7, LetterComparator_Greater());
	cout << "字符串的字典降序排序为：" << endl;
	for_each(letters, letters + 7, [&](string str) {
		cout << str << ", ";
		});
	cout << endl;
	system("pause");
}
```

**另外，C++中并不需要自行定义string的比较关系，上面的操作属实多余了，值得注意的是，C++中的字典排序不区分大小写**

``` c plus
void main()
{
	vector<string> strs{ "bames", "Aebron"};
	sort(strs.begin(), strs.end(), greater<string>());
	cout << strs[0] << ", " << strs[1] << endl;
	system("pause");
}
```

**具体贪心算法实现：**

``` c plus
// 贪心算法问题2，字符串拼接问题
class LetterComparator
{
public:
    bool operator()(const string& str1, const string& str2)
    {
        return (str1 + str2) < (str2 + str1);
    }
};

// 拼接出一个字典序最小的字符串
string LetterSplicing(vector<string>& strs)
{
    sort(strs.begin(), strs.end(), LetterComparator());
    string result="";
    for_each(strs.begin(), strs.end(), [&](string str) {
        result += str;
        });
    return result;
}

void main()
{
    // 最终结果应该为：ab ba b bdc cd
    string ab = "ab";
    string bdc = "bdc";
    string cd = "cd";
    string be = "ba";
    string b = "b";
    vector<string> strs{ ab,b,bdc,cd,be };
    cout <<"拼接后的字符串为："<<LetterSplicing(strs) << endl;
    system("pause");
}
```



### 6.3 切金条问题

**问题描述：**一块金条切成两半，需要花费和长度数值一样的铜板的。比如长度为20的金条，不管切成长度多大的两半，都要花费20个铜板。

一群人想整分整块金条，怎么分最省铜板？例如，给定数组 [10，20，30]，代表一共三个人，整块金条长度为10+20+30=60。金条要分成10，20，30三个部分。如果先把长度60的金条分成10和50，花费60：再把长度50的金条分成20和30，花费50；一共花费110铜板。但是如果先把长度60的金条分成30和30，花费60；再把长度30金条分成10和20花费30；一共花费90铜板。输入一个数组，返回分割的最小代价。

**解题思路：哈夫曼编码问题**

**步骤1：**把所有数扔到小根堆里去；

**步骤2：**从小根堆中弹出两个数，将两个数结合，并记录这个和，并累加（现在相当于在做一个分割的逆过程）；

**步骤3：**将刚刚结合得到的数又放到小根堆中，重复23步骤即可。

``` c plus
// 贪心算法问题3，最少铜币问题
int LeastMoneySplitGold(const vector<int>& arr)
{
    // 创建一个小根堆
    priority_queue<int, vector<int>, greater<int>> heap;
    for_each(arr.begin(), arr.end(), [&](const int& num) {
        heap.push(num);
        });
    // sum表示处理过程中总的数和大小
    int sum = 0;
    // cur表示当前弹出两个元素的数和大小
    int cur = 0;
    // 到最后，小根堆会只剩下一个数值，这个数值就是分割前金条的长度
    while (heap.size() > 1)
    {
        // 弹两个数字
        int value1 = heap.top();
        heap.pop();
        int value2 = heap.top();
        heap.pop();
        // 两个数字加起来
        cur = value1 + value2;
        // 累积和
        sum += cur;
        // 当前累积数推到堆中
        heap.push(cur);
    }
    return sum;
}
```



### 6.4 项目利润最大化问题

**问题描述：**有一堆项目，它们对应有两个属性，利润和成本，而我们本身能够做k个项目，初始资金为w，那么求我们通过做这些项目所能收获的最大利润+本金。

**解决思路：**

**规则1：**将项目按照花费放进一个小根堆；

**规则2：**将当前可以进行的**所有项目**弹出小根堆；

**规则3：**将小根堆弹出的项目按照利润放进大根堆；

**规则4：**从大根堆中弹出**一个项目**，然后回到规则2，循环往复，直到耗尽项目次数。

``` c plus
// 贪心算法问题4，项目利润最大化问题
class Project
{
public:
    // 利润
    int profit;
    // 花费
    int cost;
    Project(const int& pro, const int& cos) :profit(pro), cost(cos) {}
};

// 小根堆比较器（用于依次弹出最少花费的项目）
class MinCostComparator
{
public:
    bool operator()(const Project& pro1, const Project& pro2)
    {
        // 由于是小根堆，在C++中反而要在>时返回真
        return pro1.cost > pro2.cost;
    }
};

// 大根堆比较器（用于依次弹出最大利润的项目）
class MaxProfitComparator
{
public:
    bool operator()(const Project& pro1, const Project& pro2)
    {
        // 大根堆，<时返回
        return pro1.profit < pro2.profit;
    }
};

// 用于找出最终能够获得的最大利润
// k表示一共能接多少个项目
// w表示起始资金
// profits和costs顾名思义
int FindMaximizedCapital(const int& k, const int& w, const vector<int>& profits, const vector<int>& costs)
{
    // 记录可以使用的money数目
    int money = w;
    // 花费排序的小根堆
    priority_queue<Project, vector<Project>, MinCostComparator> minHeap;
    // 利润排序的大根堆
    priority_queue<Project, vector<Project>, MaxProfitComparator> maxHeap;
    // 将所有项目放进小根堆
    for (int i = 0; i < profits.size(); i++)
        minHeap.push(Project(profits[i], costs[i]));
    // 以能够进行的项目为基准进行循环
    for (int i = 0; i < k; i++)
    {
        // 弹出所有可以做的项目，并放进大根堆
        // 另外需要注意，有可能会出现小根堆中所有的项目均可解锁的情况，拿不出来的时候就别拿了
        while (!minHeap.empty() && minHeap.top().cost <= money)
        {
            // 放进大根堆，然后弹出小根堆
            maxHeap.push(minHeap.top());
            minHeap.pop();
        }
        // 如果大根堆中没有元素了，说明当前没有其它解锁项目可用了，则直接返回当前的钱的数目
        if (maxHeap.empty())
            return money;
        // 弹出大根堆中的顶层元素（利润最大），直接加到money上，表示我们可以动用的资金
        money += maxHeap.top().profit;
        maxHeap.pop();
    }
    return money;
}

void main()
{
    /// <summary>
    /// 创建这样的项目
    ///		利润	消费
    /// P1:	3		2
    /// P2: 1		4
    /// P3: 2		3
    /// P4: 5		6
    /// P5: 1		2
    /// P6: 3		4
    /// 现在说，只能做4个项目，初始资金为2，那么最多可以做(3, 2), (3, 4), (5, 6), (2, 3)
    /// 对应最终的资金可以变成 2 + 3 + 3 + 5 + 2 = 15
    /// </summary>
    vector<int> profits{ 3, 1, 2, 5, 1, 3 };
    vector<int> costs{ 2, 4, 3, 6, 2, 4 };
    cout << "最大本金+利润为：" << FindMaximizedCapital(4, 2, profits, costs) << endl;
    system("pause");
}
```



### 6.5 补充——堆的应用

**问题描述：**一个数据流中**（即可能会随时插入数据）**，随时可以获得中位数。

**解题思路：**

**规则1：**准备一个大根堆和一个小根堆；

**规则2：**判断，当前拿进来的元素如果比大根堆的堆顶小，则进入大根堆，否则进入小根堆；

**规则3：**判断，当前小根堆和大根堆的元素个数差距是否大于等于2，如果是，把元素数目比较多的那个堆的堆顶元素弹出并插入到另一个堆中；

**规则4：**当需要中位数的时候，看两个堆的元素个数，如果某个堆的元素个数多，直接由该堆弹出堆顶元素，而如果两个堆的元素个数一样多，则两个堆均弹出堆顶元素并求均值。

**原理：**原理非常简单，即用大根堆维护当前数据流的左半部分，用小根堆维护当前数据流的右半部分（默认升序）。

``` C PLUS
// 堆的补充使用问题5，给出数据流的中位数
class MedianQuickArray
{
public:
    // 用一个数组来初始化
    MedianQuickArray::MedianQuickArray(const vector<int>& arr)
    {
    // 把数组的全部元素插入即可
    for_each(arr.begin(), arr.end(), [&](const int& num) {
        AddNumber(num);
        });
    }

    // 插入数据
    void MedianQuickArray::AddNumber(const int& elem)
    {
        if (maxHeap.empty())
        {
            // 如果大根堆没有数据，则直接插入后返回
            maxHeap.push(elem);
            return;
        }
        if (elem <= maxHeap.top())
            // 如果大根堆的堆顶元素比给定的元素大，则插入大根堆
            maxHeap.push(elem);
        else
            // 否则插入小根堆
            minHeap.push(elem);
        // 插入数据后调整堆的大小
        AdjustHeaps();
    }

    // 给出中位数
    int MedianQuickArray::MedianNumber() const
    {
        // 谁元素多谁返回，否则返回两者堆顶的均值
        if (maxHeap.size() > minHeap.size())
            return maxHeap.top();
        else if (minHeap.size() > maxHeap.size())
            return minHeap.top();
        else
            return (maxHeap.top() + minHeap.top()) / 2;
    }

private:
    // 调整堆的尺寸
    void MedianQuickArray::AdjustHeaps()
    {
        // 谁的元素多，谁弹一个元素给另一个堆
        if (maxHeap.size() >= minHeap.size() + 2)
        {
            minHeap.push(maxHeap.top());
            maxHeap.pop();
        }
        else if (minHeap.size() >= maxHeap.size() + 2)
        {
            maxHeap.push(minHeap.top());
            minHeap.pop();
        }
    }
    // 大根堆，维护数组右半部分（因为每次弹出的元素都是中间元素）
    priority_queue<int, vector<int>, less<int>> maxHeap;
    // 小根堆，维护数组左半部分（因为每次弹出的元素都是中间元素）
    priority_queue<int, vector<int>, greater<int>> minHeap;
};

void main()
{
	vector<int> arr{ 4,2,4,5,7,8,9,5,10,15,3,6 };
	MedianQuickArray mqa(arr);
	// 将原数组排序
	sort(arr.begin(), arr.end(), less<int>());
	for_each(arr.begin(), arr.end(), [&](const int& num) {
		cout << num << ", ";
		});
	cout << endl;
	// 此时元素个数为偶数，结果为 5 + 6/2 = 5
	cout << "中位数为：" << mqa.MedianNumber()<<endl;
	mqa.AddNumber(16);
	// 加入16之后，此时元素个数为奇数，结果应该为6
	cout << "中位数为：" << mqa.MedianNumber() << endl;
	system("pause");
}
```



## 7. N皇后问题

**问题描述：**N皇后问题是指在N*N的棋盘上要摆N个皇后，要求任何两个皇后不同行、不同列也不在同一条斜线上。给定一个整数N，返回N皇后的摆法有多少种。
n=1，返回1。
n=2或3，2皇后和3皇后问题无论怎么摆都不行，返回0。
n=8，返回92。

**问题思路1：**利用递归思路，和一个函数IsValid来判断，在前i-1层都满足N皇后问题的前提下，当前研究的第i层中，把第i个皇后放在j位置时，是否满足N皇后问题的要求。并且值得注意的是，整个过程仅需要一个数组，因为是深度优先遍历，并不需要考虑耦合影响，并且IsValid函数中也仅仅使用到给定数目的数组元素。

``` c plus
// ================== N皇后问题 ================== //
// 无常数优化解法
int NQueen1(const int& n)
{
    if (n < 1) return 0;
    // record[i] = j表示有一个皇后放在i行j列，初始化为n维的{-1, -1, -1, -1, ...}
    vector<int> record(n, -1);
    return NQueen1_Process(0, record, n);
}

// 过程函数，i表示当前在放第i行的皇后，record记录了前i-1行的皇后位置，n表示总的皇后问题规模
int NQueen1_Process(const int& i, vector<int>& record, const int& n)
{
    // 基本返回量非常关键，i = n的时候，不是说在放最后一行，而是最后一行的再下一行
    // 如果能够走到这一步，说明当前深度优先遍历成功，此时皇后问题有一解，则返回1
    if (i == n) return 1;
    int result = 0;
    // 行数i已经给定了，此处的循环是遍历列数j
    for (int j = 0; j < n; j++)
    {
        // 可以想到，在i = n - 1的时候，只要IsValid为真，就可以不断给result++，此时返回给i = n - 2的函数
        // 对应的仅仅是某一组i从0 ~ n - 2行对应列放置方法都有效的前提下，可以产生的所有的解的数目
        if (IsValid(record, i, j))
        {
            // 当前层的摆放方法如果不和之前层的冲突，则修改record的值
            record[i] = j;
            result += NQueen1_Process(i + 1, record, n);
        }
        // 只要有一步不满足条件就直接过，因为往下继续检查也没有意义
    }
    return result;
}

// 检查有效函数，record表示前i-1行的皇后摆放方法，i，j表示当前皇后的摆放位置，返回这种皇后摆法是否有效
bool IsValid(const vector<int>& record, const int& i, const int& j)
{
    // 如果i为0，此时j放在任意一行都可以，之后再看能否删掉这一步边界边界条件，看来是不能删掉的
    if (i == 0) return true;
    // 此外，由于IsValid是渐进增长的一个函数，所以只需要检查最新的元素是否满足与之前元素的条件，而不需要挨个检查
    // 所以 k 只需要到 i - 1
    for (int k = 0; k <= i - 1; k++)
    {
        if (j == record[k] || (abs(j - record[k]) == abs(i - k)))
        {
            // 如果当前元素和前 i - 1 行元素中有任意一个共列（肯定不共行）、或者在相同对角线上，则返回false
            return false;
        }
    }
    // 通过所有检查才返回true
    return true;
}

void main()
{
	// 问题规模定义
	int N = 8;
	int startTime = clock();
	// 计算结果数目
	float result = NQueen1(N);
	float endTime = clock();
	cout << N << "皇后问题合法摆放方法有：" << result <<"种" << endl;
	cout << "消耗时间：" << endTime - startTime << endl;
	system("pause");
}
```

**常数项优化版本：**该问题很难在数量级上进行优化，但是可以减少常数项时间的耗时，并带来明显的增速效果。

**增速思路：**采用位运算的方法，

``` c plus
// 位运算优化，只支持0~32位皇后问题
int NQueen2(const int& n)
{
    if (n < 1 || n > 32) return 0;
    // 如果真的要64位，就用-1（改为二进制就全是1）
    // 否则用1按位往左移动n次，然后-1，这个很好想，不赘述
    int limit = n == 32 ? -1 : (1 << n) - 1;
    return NQueen2_Process(limit, 0, 0, 0);
}
// limit表示当前皇后问题的规模，比如2位皇后问题对应的limit为0000`00011
// coLim表示上层皇后对列的限制
// leftLim表示上层皇后对左对角线摆放的限制
// rightLim表示上层皇后对右对角线摆放的限制
// 值得注意的是，leftLim和rightLim可以通过层的增加而不断累积和传递（leftLim向左位移，rightLim向右位移）
int NQueen2_Process(const int& limit, const int& coLim, const int& leftLim, const int& rightLim)
{
    /****** 错误示范，一定不是所有位置被限制则判断方法可行，因为一行中的皇后会给后续的每一行增加3个限制位置
    则完全有可能出现没有每一行摆满皇后而已经完全被限制的情况 ******/
    //int allLim = coLim | leftLim | rightLim;
    // 如果所有可能的位置都被限制了，则说明当前摆放可行
    //if (allLim == limit) return 1;
    /**************************************************************************************************/

    // 仅仅当列限制和limit相同，说明当前每一行真的都摆了皇后
    if (coLim == limit)return 1;
    // 求出当前所有可以取皇后的位置，即所有的限制取反交上问题规模
    int access = limit & (~(coLim | leftLim | rightLim));
    int result = 0;
    while (access != 0)
    {
        // 从当前可以摆放皇后位置的最右边那一个挨个取，直到全部被限制，这是一个横向过程（列），下面的递归是一个纵向的过程（行）
        int mostRightAccess = access & (~access + 1);
        access -= mostRightAccess;
        // 因为当前在mostRightAccess放了一个新的皇后，所以将其考虑到后续限制条件中
        result += NQueen2_Process(
                    limit,
                    coLim | mostRightAccess,
                    (leftLim | mostRightAccess) << 1,
                    (rightLim | mostRightAccess) >> 1
                );
    }
    return result;
}

void main()
{
    for (int i = 0; i <= 14; i++)
    {
        cout << "// ======= " << i << "皇后问题的可能摆放方法 ======= //" << endl;
        cout << "Solution1: " << NQueen1(i) << ", Solution2; " << NQueen2(i) << endl;
    }
    system("pause");
}
```



## 8. 暴力递归——尝试

1. 把问题转化为规模缩小了的同类问题的子问题

2. 有明确的不需要继续进行递归的条件**（base case)**

3. 有当得到了子问题的结果之后的

4. 决策过程不记录每一个子问题的解

**关键：**一定要学会怎么去尝试，因为这是动态规划的基础，这一内容我们将在提升班讲述。

### 8.1 汉诺塔问题

**问题：**有三个柱子1、2、3，初始有若干个圆盘都在同一个柱子上，且要求大圆盘不能位于小圆盘之上，则求将当前柱子上的所有圆盘放到另一个柱子上的路径。

**思路：**设当前目的是将i个圆盘从from柱移动到to柱上，那么整个过程分为

​	**步骤1：**将前i-1个圆盘移动到other柱上；

​	<font color = red>**步骤2：**将i圆盘移动到to柱上；</font>

​	<font color = red>**步骤3：**将i-1个圆盘移动的到to柱上；</font>

​	**步骤4：**递归求解。

**注意：**步骤2和3非常值得理解，因为是递归求解的方法，而步骤2和3就是对所有规模问题都适用的规则，那么只要步骤23定义的规则满足问题的需求，那么最终所有的过程都会满足问题的要求。

``` c plus
// 汉诺塔问题
void Hanoi(const int& i, const string& from, const string& to, const string& other)
{
    if (i == 1)
    {
        cout << "Move pile 1(count from top to bottom) from " << from << " to " << to << endl;
    }
    else
    {
        // 对i-1层，其还是从from开始，但是此时其目的地是当前层的other，其other是当前层的to
        Hanoi(i - 1, from, other, to);
        cout << "Move pile " << i << "(count from top to bottom) from " << from << " to " << to << endl;
        // 在把i层的盘子移动到to之后，我们再将原来的i-1层从other上移到to
        Hanoi(i - 1, other, to, from);
    }
}
```

### 8.2 打印字符串包括空字符的所有子序列

**问题描述：**求出字符串的所有子集。

**方法1：**新字符串方法

``` c plus
int index = 0;
// 打印所有子字符串问题，大概思考就能知道，字符串有多长，就会产生多少次分支
void AllSubString(const string& motherString, const int& i, const string& lastString)
{
    // 明显的，最终结果应当有2的原字符串长度次数个
    if (i == motherString.size()) cout << "The " << ++index << "th substring is: " << lastString << endl;
    else
    {
        // 两种情况分别为要第i个字符和不要第i个字符
        AllSubString(motherString, i + 1, lastString + motherString[i]);
        AllSubString(motherString, i + 1, lastString);
    }
}
```

**方法2：**复用字符串方法

``` c plus
// 方法2，复用空间的方法，因为我们其实是从一个完整的源字符串开始的，所以可以先把字符串的某一位设置为空，任其递归，完成后再将那个字符改回来
// 不过值得注意的是，此时的motherString长度是没变的，只是有的位置被设置为空
void AllSubString2(string& motherString, const int& i)
{
    if (i == motherString.size()) cout << "The " << ++index << "th substring is: " << motherString << endl;
    else
    {
        // 什么处理的都不做直接下去，得到的就是要当前字符的结果
        AllSubString2(motherString, i + 1);
        // 记录当前位置的字符
        char tmp = motherString[i];
        motherString[i] = 0;
        // 得到的是不要当前字符的字符串
        AllSubString2(motherString, i + 1);
        // 把字符变回来
        motherString[i] = tmp;
    }
}
```

**注：**这种方法的关键思想就是栈，这里面隐式地利用了系统栈的形式，感觉上也有深度优先的思想在里面（这也是最后要把字符复原的原因），慢慢体会。

### 8.3 打印一个字符串的所有不重复的排列

**思路：**从0位置开始，把所有字符都挨个放到0位置上来（也包括其自身，这样可以减少一句语句的调用，使得代码更规范），基于这个思路，在各个分支中从1位置、2位置...每个位置都把后续所有可能的字符放到该位置来并继续递归。

​		值得注意的是，如果当前位置已经放过某个字符了，后续就不需要将相同的字符放在该位置来再递归下去，这样会产生重复的排列结果。

``` c plus
// 得到字符全部不重复排序问题
void AllStringSequences(const string& motherString)
{
    string ms = motherString;
    vector<string> result;
    Process_AllStringSequences(ms, 0, result);
    // 这里sort似乎并不能使用list容器
    sort(result.begin(), result.end(), less<string>());
    int index = 0;
    for_each(result.begin(), result.end(), [&](const string& str) {
        cout << "The " << ++index << "th string is; " << str << endl;
        });
}
// 分支限界，提前根据约束条件杀死所有不可能产生的情况，而不是遍历所有情况后再去除不可能的情况（优化常数项）
void Process_AllStringSequences(string& motherString, const int& i, vector<string>& result)
{
    if (i == motherString.size()) result.push_back(motherString);
    else
    {
        // 用于判断某个字符是否已经在当前位置使用过
        vector<bool> ifChecked(26, 0);
        for (int j = i; j < motherString.size(); j++)
        {
            if (ifChecked[motherString[j] - 'a'] == false)
            {
                // 说明当前字符还未被检查过
                ifChecked[motherString[j] - 'a'] = 1;
                // 将所有后续未放到过i位置（不包括重复的字符）的字符都放到i位置上来，然后继续递归
                SwapWithinString(motherString, i, j);
                Process_AllStringSequences(motherString, i + 1, result);
                // 然后把两个位置的字符交换回来，再次强调，这是因为深度优先过程中，前一种情况不能影响后一种同级别的情况
                SwapWithinString(motherString, i, j);
            }
        }
    }
}
// 交换字符串中的字符
void SwapWithinString(string& str, const int& i, const int& j)
{
    char tmp = str[i];
    str[i] = str[j];
    str[j] = tmp;
}
```

### 8.4 纸牌博弈问题

​		给定一个整型数组arr，代表数值不同的纸牌排成一条线。玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后拿，但是每个玩家每次只能拿走最左或最右的纸牌，玩家A和玩家B都绝顶聪明。请返回最后获胜者的分数。
**[举例]**

**情况1：**

1. arr=[1, 2, 100, 4]。开始时，玩家A只能拿走1或4。如果开始时玩家A拿走1，则排列变为[2, 100, 4]，接下来玩家B可以拿走2或4，然后继续轮到玩家A...

2. 如果开始时玩家A拿走4，则排列变为[1，2，100]，接下来玩家B可以拿走1或100，然后继续轮到玩家A...

3. 玩家A作为绝顶聪明的人不会先拿4，因为拿4之后，玩家B将拿走100。所以玩家A会先拿1，

4. 让排列变为[2, 100, 41]，接下来玩家B不管怎么选，100都会被玩家A拿走。玩家A会获胜，分数为101。所以返回101。

**情况2：**

1. arr=[1, 100, 2]。开始时，玩家A不管拿1还是2，玩家B作为绝顶聪明的人，都会把100拿走。玩家B会获胜分数为100。所以返回100。

**思想是简单的，但问题在于先手和后手之间明显有一个协调关系，也就是说，先手在保证自己拿到当前问题最大解的情况下，如何可以保证让后手拿到当前问题的最小解。**

``` c plus
// 先后手选牌问题
int CardInline_Win1(const vector<int>& arr)
{
    if (arr.empty())return 0;
    return max(First(arr, 0, arr.size() - 1), Second(arr, 0, arr.size() - 1));
}
// 先手的情况
int First(const vector<int>& arr, const int& i, const int& j)
{
    // 在一个选择的先手问题中，仅有一个选择
    if (i == j) return arr[i];
    // 作为当前规模问题的先手，我们有资格选择拿走左边的结果或是右边的结果，然后把我们会继续称为当前问题规模-1问题的后手
    // 当然，我们会选择拿走之后的最大情况，我好奇的地方就在此
    // 明明作为先手，我们当前只是保证自己能拿到最大值，那么对后手拿到最小值的限制是从哪里来的？
    return max(arr[i] + Second(arr, i + 1, j), arr[j] + Second(arr, i, j - 1));
}
// 后手的情况
int Second(const vector<int>& arr, const int& i, const int& j)
{
    // 在一个选择的后手问题中，那个选择是拿不到的
    if (i == j)return 0;
    // 作为当前规模问题的后手，我们是下一个小规模问题的先手
    return min(First(arr, i + 1, j), First(arr, i, j - 1));
}
```

**更详细的解释如下：**

<img src="C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230325212426213.png" alt="image-20230325212426213" style="zoom:80%;" />

​		**如上图所示，其实这个问题中正儿八经是遍历了所有可能情况的，但是在具体取哪一条路径的问题上，是有说法的。还有，画成上面那种形式的图需要这样理解：对自己是先手的情况，选一个数字，这个数字属于自己，需要累加，并从原数组中去除该数；对自己是后手的情况，直接从原数组中去除该数字。另外，还有一个值得注意的问题是，在每一层中，实际上只有一方在选数字，所以最终选择出来的结果不重复也不漏选。**

### 8.5 栈的逆序

​		给一个栈，请逆序这个栈，不能申请额外的数据结构，只能使用递归函数如何实现？

**思路：**先实现一个函数，它能够弹出当前栈的栈底元素，因为当栈仅能弹出栈顶元素的情况下，我们是没办法使其逆序的，但一旦我们有了可以弹出栈底元素的方法，则从栈底依次弹出元素，再结合系统栈，就能实现栈的逆序。

``` c plus
// 无额外空间实现栈的逆序
void StackReverse(stack<int>& stk)
{
    if (stk.empty()) throw string("The given stack has already been empty!");
    // 依次弹出栈底元素放在系统栈，然后再依次把栈底元素压回到原栈
    int stackBottom = Pop_Stack_Bottom(stk);
    if (stk.empty())
        // 如果弹出之后栈为空，则直接把弹出的元素依次压回去，此时先弹出的栈底元素后入栈，即实现了栈的逆序
        stk.push(stackBottom);
    else
    {
        // 如果弹出之后栈不为空，继续弹
        StackReverse(stk);
        // 递归完成之后，把原来弹出的元素压回去
        stk.push(stackBottom);
    }
}

// 弹出栈的栈底元素
// 思路还是很简单的，利用系统栈，依次弹出原栈的元素并存在系统栈中，直到弹出了最后一个栈的元素
// 返回这个元素，并将系统栈中的元素再依次压回到原栈
int Pop_Stack_Bottom(stack<int>& stk)
{
    if (stk.empty()) throw string("The given stack has already been empty!");
    // 弹出栈顶元素，除了basecase，这个栈顶元素都要被压回到栈中
    int stackTop = stk.top();
    stk.pop();
    if (stk.empty())return stackTop;
    else
    {
        // 继续弹出
        int result = Pop_Stack_Bottom(stk);
        // 执行递归开始返回的时候，原栈是空的，此时我们就可以将系统栈中的元素压回到原栈
        stk.push(stackTop);
        // 需要返回沿途返回上来的栈底元素
        return result;
    }
}

void main()
{
    // 此时栈的弹出顺序为 9, 8, 4, 6, 5, 3
    stack<int> arr; // 栈无法访问迭代器
    arr.push(3);
    arr.push(5);
    arr.push(6);
    arr.push(4);
    arr.push(8);
    arr.push(9);
    stack<int>dupliArr = arr;
    while (!arr.empty())
    {
        cout << arr.top()<<", ";
        arr.pop();
    }
    cout << endl;
    StackReverse(dupliArr);
    while (!dupliArr.empty())
    {
        cout << dupliArr.top() << ", ";
        dupliArr.pop();
    }
    cout << endl;
    system("pause");
}
```

### 8.6 字符数字的对应问题

​		规定1和A对应、2和B对应、3和C对应...

​		那么一个数字字符串比如"111"，就可以转化为"AAA"、"KA"和"AK"。

​		给定一个只有数字字符组成的字符串str，返回有多少种转化结果。

**问题解释：**其实就是因为11既可以对应一个第11个字符K也可以对应两个第1个字符A。

**规则1：**令0 ~ (i-1)位置已经确定（确定了如何转换），如果i位置的数是1~2，它有可能与后面一个数字组合，但是如果i位置的数是3~9，则它只能自己转化为对应的数。进一步的，如果i位置是1，那么此时有可能和后面的任意一个数字组合，但是如果i位置是2，其只能在部分情况下和后一个元素组合。

**规则2：**令0 ~ (i-1)位置已经确定（确定了如何转换），如果i位置的数字是0，那么此时依据之前确定的转换方式，不会产生任何有效的结果（单独的0无法转换为任何的字符），则直接返回0。

``` c plus
// 字符对应问题
int NumberConvert(const string& str, const int& i)
{
    if (i == str.size())
        // 终止位置，说明当前的取法有效
        return 1;
    if (str[i] == '0')
        // 访问到一个单独的0字符，则返回0
        return 0;
    if (str[i] == '1')
    {
        // 统计单独作为字符的情况
        int result = NumberConvert(str, i + 1);
        // 统计组合的情况
        if (i + 1 < str.size())
            result += NumberConvert(str, i + 2);
        return result;
    }
    else if (str[i] == '2')
    {
        // 统计单独作为字符的情况
        int result = NumberConvert(str, i + 1);
        // 统计组合的情况
        if (i + 1 < str.size() && str[i + 1] <= '6' && str[i + 1] >= '0')
            result += NumberConvert(str, i + 2);
        return result;
    }
    else
        // 这种情况下，仅当前数字直接转换为对应字母的方法
        // 至于这里为什么没有结果的叠加，其实是因为该问题引起多解的情况仅在于某个字符为1和2的时候
        return NumberConvert(str, i + 1);
}

void main()
{
    // 此时可能的情况为：
    // ABAAA, ABKA, ABAK, LAAA, LKA, LAK, AUAA, AUK
    // 共8种
    cout << NumberConvert("12111") << endl;
    system("pause");
}
```

### 8.7 袋子装东西问题

**问题描述：**给定两个长度都为N的数组weights和values，weights[i]和values[i]分别代表i号物品的重量和价值。给定一个正数bag，表示一个载重bag的袋子，你装的物品不能超过这个重量。返回你能装下最多的价值是多少？

**问题思路：**挨个尝试即可。

​		有两种类似的方法来完成这种过程，两种方法的区别在于可变参数的个数不同，值得注意的是 ，为了更加简便地把算法改成动态规划的结构，要尽量选择可变参数形式简单、可变参数个数少的实现方法。

**方法1：**

``` c plus
// 挑选商品问题
int MaxValue1(const vector<int>& weights, const vector<int>& values, 
    const int& alreadyWeight, const int& i, const int& totalWeight)
{
    if (alreadyWeight > totalWeight)
        // 如果拿了的商品重量大于可拿的商品，该情况说明不能拿更多了
        // 但是这里不能返回0，因为相当于是在拿了上一层的商品之后超出了结果，说明上一层的商品是不能够拿的
        // 所以返回上一层商品的负值，将其多加的结果删去
        // 并且截断了拿i商品的情况的搜索进行
        return -values[i - 1];
    if (i == weights.size())
        // 终止情况，值得注意的是，我们该方法没有连带着总价值递归
        return 0;
    return max(
        // 不要当前i位置商品的情况
        MaxValue1(weights, values, alreadyWeight, i + 1, totalWeight),
        // 要当前i位置商品的情况
        values[i] + MaxValue1(weights, values, alreadyWeight + weights[i], i + 1, totalWeight)
    );
}
```

**方法2：**

``` c plus
int MaxValue2(const vector<int>& weights, const vector<int>& values,
    const int& alreadyWeight, const int& alreadyValue, const int& i, const int& totalWeight)
{
    if (alreadyWeight > totalWeight)
        // 如果拿了的商品重量大于可拿的商品，该情况说明不能拿更多了，直接返回0
        // 为什么这里返回0就可以，因为此时返回的是统计的总价格，相当于不仅截断了搜索的继续，并且把总价值置为0
        // 那么其就不会再对结果产生任何影响，因为不包含i位置商品且有可能包含后续商品的情况本身就在我们的考虑范围内（在i函数中的另一分支）
        return 0;
    if (i == weights.size())
        // 终止情况，值得注意的是，我们该方法连带着总价值递归
        return alreadyValue;
    return max(
        // 不要当前i位置商品的情况
        MaxValue2(weights, values, alreadyWeight, alreadyValue, i + 1, totalWeight),
        // 要当前i位置商品的情况
        MaxValue2(weights, values, alreadyWeight + weights[i], alreadyValue + values[i], i + 1, totalWeight)
    );
}

void main()
{
    // 明显应该拿 120-40, 200-50, 400-10, 300-100，刚好凑满200，此时的value为1020
    //vector<int> values{ 120,200,400,60,300,40 };
    //vector<int> weights{ 40,50,10,60,100,30 };
    vector<int> values=RandVector(200,400,20);
	vector<int> weights = RandVector(10, 150, 20);
    int totalWeight = 2000;
	cout << "能拿商品的最大价值为——方法一：" << MaxValue1(weights, values, 0, 0, totalWeight) << endl;
	cout << "能拿商品的最大价值为——方法二：" << MaxValue2(weights, values, 0, 0, 0, totalWeight) << endl;
    system("pause");
}
```





