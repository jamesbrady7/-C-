# 1. 滑动窗口

## 1.1 固定长度覆盖数组问题

**[题目]** 给定一个有序数组arr，代表数轴上从左到右有 n 个点 arr[0]、arr[1]、... arr[n-1]。给定一个正数 L，代表一根长度为 L 的绳子，求绳子最多能覆盖其中的几个点。

**值得注意的是，**容易证明，最优解必然存在于长绳某一段在对应结点上的某种情况，故不需要考虑长绳两端均在非 arr 结点的情况。

**解题思路1：**将固定长度的右端放在数组中的某个位置，然后找出其对应左侧应在在的位置，然后找出数组中大于等于左端点的第一个点**（二分法**），然后记录从该点到最右侧点的所有点的个数即可。该方法需要遍历 n 个点，其中每个点还需要执行二分操作，故最终的时间复杂度为 $log(NlogN)$。

**代码：**

``` c plus
// 长绳覆盖点问题，式中，arr 是有序的
// 方案1，以长绳右端为准
int maxPoints1(const vector<int>& arr, const int& L)
{
    // 至少可以覆盖一个点
    int result = 1;
    for (int i = 0; i < arr.size(); i++)
    {
        // 对于右端覆盖的点 i，基于绳长找出数组中，大于等于其左端位置且距离左端位置最近的点位
        int nearest = nearestIndex(arr, i, arr[i] - L);
        result = max(result, i - nearest + 1);
    }
    return result;
}
// 给定当前长绳的右端点 R
// 长绳的右端点 - 长绳的长度 -> 长绳左端所在位置 = value
// 和有序数组 arr
// 找出数组中比当前长绳左端位置大的最近的点，那么从该点的 index 到 长绳右端点的 index 就是能覆盖的点的个数
int nearestIndex(const vector<int>& arr, const int& R, const int& value)
{
    int leftPoint = 0;
    int index = R;
    int rightPoint = R;
    while (leftPoint <= rightPoint)
    {
        // 得到的是 L 和 R 的中间位置
        int midPoint = leftPoint + ((rightPoint - leftPoint) >> 1);
        if (arr[midPoint] >= value)
        {
            index = midPoint;
            // mid 是判断过的，所以可以直接跳过 mid
            rightPoint = midPoint - 1;
        }
        else
            leftPoint = midPoint + 1;
    }
    return index;
}
```

**解题思路2：**利用滑动窗口，

**代码：**

``` c plus
// 方案2，滑动窗口，以长绳左端为准，每一步把长绳左端放在 arr 的一个端点上，然后查看长绳的右端可不可以向右边延申
// 此时滑动窗口左右端都是不回退的，所以最终的时间复杂度是 log(N)
int maxPoints2(const vector<int>& arr, const int& L)
{
    int rightPoint = 0;
    int result = 0;
    for (int leftPoint = 0; leftPoint < arr.size(); leftPoint++)
    {

        while (rightPoint < arr.size() && arr[rightPoint] - arr[leftPoint] <= L)
            // 在右边已经到边界了，则不要再增加右边界
            rightPoint++;
        // 此时找到了以 leftPoint 为滑动窗口的左端，以 L 为标准能够延申到的最远的右端 rightPoint，则可以求出此时的覆盖长度
        // 值得注意的是，此时其实 leftPoint 向右多延申了一个，所以不要 + 1
        result = max(rightPoint - leftPoint, result);
        // 仔细想想，这里的 right 似乎需要回退，但其实是不需要的，因为就算用回退的方式多计入了一种情况
        // 这种情况最多也只是和之前的一种情况计算得到的结果相同而已，不会影响最终的最大值
        if (rightPoint == arr.size())
            // 此时已经计入了所有的情况了，此时滑动窗口在不断被压缩，没有继续记录的必要
            break;
    }
    return result;
}
void main()
{
	for (int i = 0; i < 20; i++)
	{
		vector<int> arr = RandVector_NoRepeat(1, 1000, 500, true);
		sort(arr.begin(), arr.end(), less<int>());
		//ShowVector(arr);
		int result1 = maxPoints1(arr, 250);
		int result2 = maxPoints2(arr, 250);
		cout << "The max points got by method 1: " << result1 << ", ";
		cout << "The max points got by method 2: " << result2 << endl;
		if (result1 != result2)
			cout << "Fuck all!" << endl;
	}
    system("pause");
}
```



# 2. 打表法

## 2.1 买苹果问题

**[题目]** 小虎去附近的商店买苹果，好诈的商贩使用了捆绑交易，只提供 6 个每袋和 8 个每袋的包装包装不可拆分**（每个袋子必须装这么多）**。可是小虎现在只想购买恰好个苹果，小虎想购买尽量少的袋数方便携带。如果不能购买恰好 n 个苹果，小虎将不会购买。输入一个整数n，表示小虎想购买的个苹果，返回最小使用多少袋子。如果无论如何都不能正好装下，返回 -1。

**解题思路1：**以 8 为基准，先定出用 8 袋的个数，剩下的苹果用 6 袋去凑，如果凑得出来则返回对应袋子个数，否则返回 -1，另外，如果剩余的袋子数超过 6 和 8 的最小公倍数即 24，就没有必要继续检查，这是很明显的，因为此时剩余的袋子中，更优的选择方法**（如果可以）**一定在之前已经考虑过**（将最小公倍数部分拿出来，这一部分用 8 袋填满，得到的结果一定比将这一部分用 6 袋装要好）**。

**代码：**

``` c plus
// 苹果装袋问题
// 方案1，普通解法
int minBags1(const int& appleNumber)
{
    if (appleNumber < 0)
        return -1;
    int bag6Number = -1;
    // 可以看作是地板除
    int bag8Number = appleNumber / 8;
    int rest = appleNumber - bag8Number * 8;
    while (bag8Number >= 0 && rest < 24)
    {
        int restUse6 = minBagBase6(rest);
        if (restUse6 != -1)
        {
            // 说明这种方案可行
            // 并且要直接 break 掉，因为再继续循环，得到的也不会是最优解（因为 8 袋数目在不断减少）
            bag6Number = restUse6;
            break;
        }
        rest = appleNumber - (--bag8Number) * 8;
    }
    return bag6Number == -1 ? -1 : bag6Number + bag8Number;
}
// 输入一个数字，如果这个数字可以被 6 整除，则返回对应的商（6 袋的个数），否则返回 -1，表示方案无法实现
int minBagBase6(const int& rest)
{
    return rest % 6 == 0 ? rest / 6 : -1;
}
```

**解题思路2——打表法：**一种不太常规的方法，通过原始解法，从不同的输入来观察得到的输出，直接硬捏出来的一个求解表达式。该方法仅适用于部分明显有规律的整数输入整数输出的问题。如下图所示

![image-20230426230654033](C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230426230654033.png)

​		明显看到，apple 个数在 18 之前**（确实是 18 之前，不是 12 之前）**，确实没啥规律，但一旦大于等于 12，对于偶数而言，以 8 为一个循环，每当 apple 个数增量超过 8，则结果 ++，对奇数而言，直接返回 -1。

**代码：**

``` c plus
// 方案2，打表法
int minBags2(const int& appleNumber)
{
    if (appleNumber & 1 != 0)
        // 说明最低位上的数不为 0，则该数一定是奇数
        return -1;
    if (appleNumber < 18)
    {
        // 此时未被排除的数为 2、4、6、8、10、12、14、16，对这些数强行处理
        // 2、4 的结果都是 -1
        return appleNumber == 0 ? 0 : (appleNumber == 6 || appleNumber == 8) ? 1 :
            (appleNumber == 12 || appleNumber == 14 || appleNumber == 16) ? 2 : -1;
    }
    return (appleNumber - 18) / 8 + 3;
}
void main()
{
    for (int i = 0; i < 10000; i++)
    {
	/*	cout << "Apple number: " << i << ", " << "Bag number method1: " << minBags1(i) << endl;
		cout << "Apple number: " << i << ", " << "Bag number method2: " << minBags2(i) << endl;*/
        if (minBags1(i) != minBags2(i))
            cout << "Not right!" << endl;
    }

    system("pause");
}
```

## 2.2 吃草问题

**[题目]** 先手后手都绝顶聪明，只能吃 4 的次方数量的草，即 0、1、4、16...，每一次不能不吃草，那么给定一个草的数量 N，某一步中无法吃到有效份草的选手失败，也就是说不是在比谁吃的草多，比如如果草的数量为 0，那么一上来先手就没有吃到有效份草，则直接宣布后手胜利。

**解题思路1——递归：**

``` c plus
// 吃草问题
// 方案1，普通解法
string graze1(const int& grassNumber)
{
    // 利用的是先后手交替的关系，其实这个函数的主体部分似乎总是针对先手而言
    // 先后手交替的逻辑是通过压栈来实现的
    // 但在 i 步如 A 作为先手，那 i + 1 步中自然是 B 作为先手，所以在 i + 1 步中如果是先手 B 获胜，那么返回到 i 步中就应该是后手 B 获胜...
    //	0	1	2	3	4	5
    //	后	先	后	先	先	先
    // 至于为什么选 0 ~ 4 作为 base case，因为更大的数都可以通过减去若干个 4 的次幂数而将问题缩到这个范围内
    if (grassNumber < 5)
        return (grassNumber == 0 || grassNumber == 2) ? "后" : "先";
    // 先手决定吃的草
    int base = 1;
    while (base <= grassNumber)
    {
        if (graze1(grassNumber - base) == "后")
            return "先";
        // 这个地方 break 掉也是有说法的
        // 在当前步作为先手的那一方，试完了所有可能吃的草的量 4^k 之后依然没有发现胜利的方法（没有提前返回），那自然其必然输
        // 其实不加这一句倒也问题不大，就算这里不 break 掉，base *= 4 之后也会因为循环条件而 break 掉，对逻辑上是没有多少区别的
        // 所以这一步的主要效果确实是防止数据溢出，只要给定的 grassNumber 不溢出，那么我们的判断就绝对不会溢出
        if (base > grassNumber / 4)
            break;
        base *= 4;
    }
    return "后";
}
```

**解题思路2——打表法：**

``` c plus
// 方案2，打表法
string graze2(const int& grassNumber)
{
    if (grassNumber % 5 == 0 || grassNumber % 5 == 2)
        return "后";
    else
        return "先";
}
void main()
{
    for (int i = 0; i < 50; i++)
    {
		if (graze1(i) != graze2(i))
			cout << "Not right!" << endl;
    }

    system("pause");
}
```



# 3. 预处理技巧

## 3.1 方块染色问题

**[题目]** 牛牛有一些排成一行的正方形。每个正方形已经被染成红色或者绿色。牛牛现在可以选择任意一个正方形然后用这两种颜色的任意一种进行染色，这个正方形的颜色将会被覆盖。牛牛的目标是在完成染色之后，每个红色 R 都比每个绿色 G 距离最左侧近。牛牛想知道他**最少**需要涂染几个正方形。

<font color =red>**注：要求左边至少有一个红色，当然，也可以写一个无该要求的版本，很简单。**</font>

**如样例所示：**s = RGRGR，我们涂染之后变成 RRRGG 满足要求了，涂染的个数为 2，没有比这个更好的涂染方案。

**解题思路：**遍历，按照 左边 1 个位置染红、左边 2 个位置染红、左边 3 个位置全部染红......其它位置全部染绿的方式来统计，找到需要染色的最小值即可。此外，建立两个数组，一个统计 0 ~ i 上原本有多少个绿色方块，一个统计 i ~ N - 1 上原本有多少个红色方块，则可以这两个数组快速计算结果**（空间换时间）**。

**代码：**

``` c plus
// 方块染色问题
int minPaint(const string& s)
{
    if (s.empty())
        return 0;
    // right 数组用于统计 i ~ N - 1 上有多少个 R，方便统计在这个区间上有多少个 R 需要被染成 G
    vector<int> right(s.size());
    *right.rbegin() = (*s.rbegin() == 'R') ? 1 : 0;
    for (int i = right.size() - 2; i >= 0; i--)
    {
        // 后一个位置统计的 R 总数 + 当前位置是不是 R
        // 这里一定要把后面的三目表达式括号起来，不然是错误的，注意这个问题
        right[i] = right[i + 1] + (s[i] == 'R' ? 1 : 0);
    }
    // right[0] 表示的是如果把所有方块都染成 G 需要染多少次色
    int result = INT_MAX;
    // 用于统计 0 ~ i 上有多少个 G，方便统计在这个区间上有多少个 G 需要被染成 R
    int left = 0;
    for (int i = 0; i < s.size() - 2; i++)
    {
        // i 从 0 开始就保证了左侧必然有一个位置是 R
        left += (s[i] == 'G' ? 1 : 0);
        // 到 i 位置全部染红，i + 1 ~ N - 1 全部染绿
        result = min(result, left + right[i + 1]);
    }
    // 因为上面只循环到 N - 2 位置，此时还需要统计如果所有位置都染红的情况
    result = min(result, left + (*s.rbegin() == 'G' ? 1 : 0));
    return result;
}
void main()
{
    string test = "GGGGGGGR";
    cout << "The minumum number to paint is: " << minPaint(test) << endl;   // 应该输出 2
    test = "GGGGGGRR";
    cout << "The minumum number to paint is: " << minPaint(test) << endl;   // 应该输出 3
    test = "GGGGGRRR";
    cout << "The minumum number to paint is: " << minPaint(test) << endl;   // 应该输出 4
    test = "GGGGRRRR";
    cout << "The minumum number to paint is: " << minPaint(test) << endl;   // 应该输出 4
    test = "GGGRRRRR";
    cout << "The minumum number to paint is: " << minPaint(test) << endl;   // 应该输出 3
    test = "GGRRRRRR";
    cout << "The minumum number to paint is: " << minPaint(test) << endl;   // 应该输出 2
    test = "GRRRRRRR";
    cout << "The minumum number to paint is: " << minPaint(test) << endl;   // 应该输出 1
    test = "RRRRRRRR";
    cout << "The minumum number to paint is: " << minPaint(test) << endl;   // 应该输出 0
    system("pause");
}
```

## 3.2 矩阵边界问题

**[题目]** 给定一个 $N \times N$ 的矩阵 matrix，只有 0 和 1 两种值，返回边框全是 1 的最大**正方形**的边长长度。

例如：
$$
\begin{matrix}
0 & 1 & 1 & 1 & 1\\
0 & 1 & 0 & 0 & 1\\
0 & 1 & 0 & 0 & 1\\
0 & 1 & 1 & 1& 1\\
0 & 1 & 0 & 1 &1\\
\end{matrix}\
$$
其中边框全是 1 的最大正方形的大小为 $ 4 \times 4$，所以返回 4。

**值得注意的是：**矩阵的任意子矩阵的个数数量级为 $O(N^4)$，任意子方阵的个数数量级为 $O(N^3)$。

**解题思路：**依然需要遍历所有可能产生的方阵，此时的数量级依然是 $O(N^3)$，并且由于在每个位置还需要判断该方阵是否满足边界全为 1，此时需要进一步循环，则问题的最终规模为 $O(N^4)$，而为了简化问题，考虑使用两个矩阵，一个用来统计该位置包含本身在内，右边连续 1 的个数，而另一个用来统计该位置包含本身在内，下面连续 1 的个数，在有了这两个矩阵之后，判断一个方阵是否边界全 1 的时候，就可以把最内层的循环优化掉，不过问题规模依然是 $O(N^3)$。比如有
$$
\begin{matrix}
0 & 1 & 1 & 1 & 1\\
0 & 1 &0 &0 &1\\
0&1&0&0&1\\
0&1&1&1&1\\
0&1&0&1&1\\
\end{matrix}\
\rightarrow \ 
right = \ 
\begin{matrix}
0 & 4 & 3 & 2 & 1\\
0 & 1 & 0 & 0 & 1\\
0 & 1 & 0 & 0 & 1\\
0 & 4 & 3 & 2 & 1\\
0 & 1 & 0 & 2 & 1\\
\end{matrix}\
$$
以及
$$
\begin{matrix}
0 & 1 & 1 & 1 & 1\\
0 & 1 & 0 & 0 & 1\\
0 & 1 & 0 & 0 & 1\\
0 & 1 & 1 & 1 & 1\\
0 & 1 & 0 & 1 & 1\\
\end{matrix}\
\rightarrow \ 
right = \ 
\begin{matrix}
0 & 5 & 1 & 1 & 5\\
0 & 4 & 0 & 0 & 4\\
0 & 3 & 0 & 0 & 3\\
0 & 2 & 1 & 2 & 2\\
0 & 1 & 0 & 1 & 1\\
\end{matrix}\
$$
**代码：**

``` c plus
// 矩阵边界问题
void setBorderMap(vector<vector<int>>& m, vector<vector<int>>& right, vector<vector<int>>& down)
{
    int r = m.size();
    int c = m[0].size();
    // 设置最边界的数值（右下角的矩阵元素）
    if (m[r - 1][c - 1] == 1)
    {
        right[r - 1][c - 1] = 1;
        down[r - 1][c - 1] = 1;
    }
    for (int i = r - 2; i >= 0; i--)
    {
        // 设置最后一列的数值
        if (m[i][c - 1] == 1)
        {
            // 值得注意的是，只有当为 1 的时候才累加或设置，不为 1 的时候该位置保持 0
            // 如果 i 行最后一列的数为 1，则 right 矩阵这一列的那个位置就应当是 1，而 down 矩阵需要累加
            right[i][c - 1] = 1;
            down[i][c - 1] = down[i + 1][c - 1] + 1;
        }
    }
    for (int i = c - 2; i >= 0; i--)
    {
        // 设置最后一行的数值
        if (m[r - 1][i] == 1)
        {
            right[r - 1][i] = right[r - 1][i + 1] + 1;
            down[r - 1][i] = 1;
        }
    }
    for (int i = r - 2; i >= 0; i--)
        // 外层循环是行
        for (int j = c - 2; j >= 0; j--)
        {
            // 设置其它所有位置的数值
            if (m[i][j] == 1)
            {
                right[i][j] = right[i][j + 1] + 1;
                down[i][j] = down[i + 1][j] + 1;
            }
        }
}
// 主要函数
int getMaxBorderSize(vector<vector<int>>& m)
{
    // 右和下矩阵全部初始化为 0
    vector<vector<int>> right = vector<vector<int>>(m.size(), vector<int>(m[0].size(), 0));
    vector<vector<int>> down = vector<vector<int>>(m.size(), vector<int>(m[0].size(), 0));
    // 然后设置矩阵
    setBorderMap(m, right, down);
    for (int size = min(m.size(), m[0].size()); size > 0; size--)
    {
        // 值得注意的是，size 最小取到 1 即可
        // 取矩阵行列中尺寸的小值，作为最大的子方阵尺寸
        // 从大子方阵往小取的好处就在于这里，如果找到了一个可行的子方阵，则可以直接返回，因为之后的方阵只会越来越小
        if (hasSizeOfBorder(size, right, down))
            return size;
    }
    // 没有找到则返回 0 
    return 0;
}
// 给定子方阵的尺寸 size，判断在原 m 中是否可以产生 size 大小的方阵边界，此时用 right 和 down 信息就可以得到结果
bool hasSizeOfBorder(int size, vector<vector<int>>& right, vector<vector<int>>& down)
{
    for (int i = 0; i < right.size() - size + 1; i++)
        // 打个比方，right 的尺寸是 2，那么 size 为 1 的时候，明显应该循环 2 次，则可以定出边界条件为 right.size() - size + 1
        for (int j = 0; j < right[0].size() - size + 1; j++)
        {
            // size 给定，现在是遍历所有可能形成 size 大小方阵的情况，来判断该位置上能否形成边界全 1 的方阵
            if (right[i][j] >= size 
                && right[i + size - 1][j] >= size
                && down[i][j] >= size
                && down[i][j + size - 1] >= size)
                return true;
        }
    return false;
}
void main()
{
    int result = -1;
    vector<vector<int>> mat;
    while (result != 5)
    {
        mat = Rand01Matrix(6, 6, 1);
        result = getMaxBorderSize(mat);
        if (result >= 4)
        {
            ShowMatrix(mat);
            cout << "The max 1 border is: " << result << endl;
            cout << "// ========================================= //" << endl;
        }
    }
    system("pause");
}
```



# 4. 其它问题

## 4.1 随机数返回问题

**[题目]** 给定一个函数 f，可以1～5 的数字等概率返回一个。请加工出1～7的数字等概率返回一个的函数 g；

给定一个函数 f，可以 a～b 的数字等概率返回一个。请加工出 c～d 的数字等概率返回一个的函数 g；

给定一个函数 f，以 p 概率返回 0，以 1～p 概率返回 1。请加工出等概率返回 0 和 1 的函数 g。

**解题思路：**

​		对前两个问题，先加工出等概率随机掷出 0 和 1 的函数，然后通过二进制来拼接成需要的结果；对第三个问题，非常简单 01 和 10 的概率都是 $p(1-p)$，所以若掷出其中任意一个，则返回 0，若掷出另一个则返回 1。

**代码1——随机数 01 生成器：**

```  c plus
// 投掷随机数问题
// 已知一个函数可以在给定范围 A ~ B 任意随机均匀生成范围内的某一个数，现该函数可以基于此等概率随机生成 0 和 1
int rand01_AToB(const int& A, const int& B)
{
    if (((A - B + 1) & 1) != 0)
    {
        int randValue = RandInt(A, B, true);
        // 此时说明原本给定的随机数范围内存在奇数个数，此时有一个数不能用，不妨就设是最后一个数
        while (randValue == B)
            randValue = RandInt(A, B, true);
        // 如果得到的数小于中位数，则返回 0，否则返回 1
        return randValue < ((A + B) / 2) ? 0 : 1;
    }
    else
    {
        // 此时说明原本给定的随机数范围内存在偶数个数，此时所有数都能用
        return RandInt(A, B, true) <= ((A + B) / 2 )? 0 : 1;
    }
}
void main()
{
    int _number0 = 0;
    int _number1 = 0;
    int totalNumber = 100000;
    for (int i = 0; i < totalNumber; i++)
    {
        int result = rand01_AToB(1, 5);
        if (result == 0)
            _number0++;
        else
            _number1++;
    }
    cout <<"The Frequency of 0: " << (1.0*_number0)/(1.0* totalNumber) << ", The Frequency of 1: " << (1.0 * _number1) / (1.0 * totalNumber) << endl;
    system("pause");
}
```

**代码2——随机生成给定范围 C ~ D 中的数字**

``` c plus
// 给定范围 C ~ D，通过一个可以均匀随机生成 0 和 1 的函数（给定原范围为 A ~ B），随机返回 C ~ D 范围内的数
int rand_CToD(const int& A, const int& B, const int& C, const int& D)
{
    // 等概率生成 C ~ D，实际上等价于等概率生成 0 ~ (D - C)
    // 然后我们只需要找出能刚好覆盖住 D - C 的数字，即找到 2^n - 1 中离 D - C 最近的那个数字
    // 比如 D - C 对应的二进制数为 000110010111，那么我们给出的数应当为 000111111111，在这么多位上随机投掷，并只取投在范围内的数字
    // 实际上只需要取 n = ceiling(lg(D - C + 1)/lg2) 即可，就得到了可以覆盖 D - C 的那个数字
    int realRightBorder = D - C;
    int n = (int)ceil(log2l(D - C + 1));
    int result;
    do
    {
        result = 0;
        // 在这个循环中拿到随机数
        for (int i = 0; i < n; i++)
        {
            result += (rand01_AToB(A, B) << i);
        }
    } while (result > realRightBorder);
    return result + C;
}
void main()
{
    int totalNumber = 100000;
    int A = 10;
    int B = 19;
    int C = 100;
    int D = 120;
    // 用这个数组来统计
    map<int, int> countArr;
    for (int i = 0; i < totalNumber; i++)
    {
        // 随机产生一个目标范围内的数
        int result = rand_CToD(A, B, C, D);
        // 用有序表进行统计
        if (countArr.find(result) != countArr.end())
            countArr[result]++;
        else
            countArr.insert(make_pair(result, 1));
    }
	for (auto it = countArr.begin(); it != countArr.end(); it++)
    {
        cout << "The Frequency of " << it->first << ": " << (1.0 * it->second) / (1.0 * totalNumber) << endl;
    }
    system("pause");
}
```

**代码3——将不均匀的 01 随机修正为均匀的 01 随机**

``` c plus
// 以 P 的概率投出 0，否则投出 1
int rand01P(const double& P)
{
    double value = RandDouble(0, 1, 1);
    // 如果掷出的结果比 P 大，则返回 1，否则返回 0
    return value >= P;

}
// 将不均匀的 0 1，将转换为均匀的随机 0 1
int rand01_Issue2(const double& P)
{
    vector<int> result(2, 0);
    do
    {
        result[0] = rand01P(P);
        result[1] = rand01P(P);
    } while (result[0] == result[1]);
    // 此时 10 返回 0，01 返回 1，则完成了概率均匀化
    return result[0] == 1 && result[1] == 0 ? 0 : 1;
}
void main()
{
    int totalNumber = 100000;
    int _number0_nonuniform = 0;
    int _number1_nonuniform = 0;
    int _number0_uniform = 0;
    int _number1_uniform = 0;
    double P = 0.95;
    for (int i = 0; i < totalNumber; i++)
    {
        if (rand01P(P) == 1)
            _number1_nonuniform++;
        else
            _number0_nonuniform++;

        if (rand01_Issue2(P) == 1)
            _number1_uniform++;
        else
            _number0_uniform++;
    }
    cout << "// =========================== nonuniform condition =========================== //" << endl;
    cout << "The Frequency of 0: " << (1.0 * _number0_nonuniform) / (1.0 * totalNumber) \
        << ", The Frequency of 1: " << (1.0 * _number1_nonuniform) / (1.0 * totalNumber) << endl;
    cout << "// =========================== uniform condition =========================== //" << endl;
    cout << "The Frequency of 0: " << (1.0 * _number0_uniform) / (1.0 * totalNumber) \
        << ", The Frequency of 1: " << (1.0 * _number1_uniform) / (1.0 * totalNumber) << endl;
    system("pause");
}
```

**生成结果：**

![image-20230427163551328](C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230427163551328.png)

## 4.2 括号配对问题

### 4.2.1 问题一

**[题目]** 一个完整的括号字符串定义规则如下：

① 空字符串是完整的。

② 如果 s 是完整的字符串，那么（s）也是完整的。

③ 如果 s 和 t 是完整的字符串，将它们连接起来形成的 st 也是完整的。

例如，"（（））"，"" 和 "（）"是完整的括号字符串，"（））（" ，"（）（" 和 "）"是不完整的括号字符串。

牛牛有一个括号字符串 s，现在需要在其中**任意位置尽量少地添加括号**，将其转化为一个完整的括号字符串。请问牛牛至少需要添加多少个括号。

**解题思路：**从左到右遍历 s，非常简单，给一个初始化为 0 的 count，则有两个规则**判断这个 s 是否完整：**

​		**规则1：**遍历过程中，如果有左括号出现，则 count++，有右括号出现，则 count--；

​		**规则2：**遍历过程中，count 不能小于 0，因为此时说明当前位置右括号的数目多于左括号，因为后面再多配左括号也无法改变当前位置右括号多的事实，则 s 一定不完整；

​		**规则3：**遍历完成后，count 必须为 0，这点很好理解。

​		则要添多少个括号，一个很明显的规则和一个不那么明显的规则，最需要注意的就是，只要中间有任意一个位置的右括号多于左括号了，此时必须马上对其进行平衡，而不能说等到最后直接看 count 的结果，**比如 "（））（" ，此时看到最后的时候，count 为 0，但是明显括号不平衡**，所以只要中间右括号多了，马上给左括号与之配对，然后最后再看需要添加多少个右括号**（右括号直接全部添加到最后的位置都可以进行配对，但是左括号不具有这个特征）**：

​		**规则1：**如果 count 在结束的时候 > 0，此时说明左括号比右括号多 count 个，此时只需要添加 count 个数的右括号即可；

​		**规则2：**如果 count 在过程中，如果其为 0 的时候碰到了右括号，此时说明当前遍历到的位置的右括号是没有左括号与之配对的，那么此时我们马上给这个右括号一个左括号进行配对，那么此时 count 不变，代表其依然平衡，然后给一个变量 ans 来记录当前添加了几个左括号。最终再看，在添加左括号匹配的情况下，当前 s 还多了几个左括号，这个时候我们再末尾添上右括号进行平衡即可。 

**代码：**

``` c plus
// 括号平衡问题
int parenthesesIssue(const string& str)
{
    int count = 0;
    int ans = 0;
    for (int i = 0; i < str.size(); i++)
    {
        if (str[i] == '(')
            count++;
        else
        {
            if (count == 0)
                ans++;
            else
                count--;
        }
    }
    return ans + count;
}

void main()
{
    cout << parenthesesIssue("(()))") << endl;  // 1 个
    cout << parenthesesIssue(")))") << endl;    // 3 个
    cout << parenthesesIssue("))(((") << endl;  // 5 个
    system("pause");
}
```

### 4.2.2 问题二

**[题目]** 一个合法的括号匹配序列有以下定义：

① 空串 " " 是一个合法的括号匹配序列；

② 如果 "X" 和 "Y" 都是合法的括号匹配序列，"XY" 也是一个合法的括号匹配序列；

③ 如果 "X" 是一个合法的括号匹配序列，那么 "（X）" 也是一个合法的括号匹配序列；

④ 每个合法的括号序列都可以由以上规则生成。

例如：" "，"（）"，"（）"，"（（（）））"都是合法的括号序列

对于一个合法的括号序列我们又有以下**定义它的深度：**

① 空串 " " 的深度是0

② 如果字符串 "X" 的深度是 x，字符串 "Y" 的深度是 y，那么字符串 "XY" 的深度为

max(x，y)、如果 "x" 的深度是 x，那么字符串 "（X）" 的深度是 x + 1

例如："（）（）（）" 的深度是 1，“（（（）））“ 的深度是 3。牛牛现在给你一个合法的括号序列，需要你计算出其深度。

**解题思路：**很明显，按照问题 1 的思路，count 达到的最大值就是深度，这个问题本身极其简单，因为它要求括号序列本身是合法的，所以不存在说在一个整体不合法括号序列中找最大合法括号子序列深度的情况。

**代码：**

``` c plus
// 括号深度问题，查看一个括号串中的最大深度
// 判断一个括号串是否是有效的
bool isValid(const string& str)
{
    if (str.empty())
        return false;
    int status = 0;
    for (int i = 0; i < str.size(); i++)
    {
        if (str[i] != ')' && str[i] != '(')
            // 如果字符串中出现了非括号字符，直接返回 false
            return false;
        else if (str[i] == '(')
            status++;
        else if (str[i] == ')' && (--status) < 0)
            return false;
    }
    // 如果在上面的过程中没有返回 false，还不能说明括号串有效
    // 虽然此时 status 不会小于 0，但是其是有可能大于 0 的，即有可能左括号比右括号多
    return status == 0;
}
// 计算深度
int parentheseDepth(const string& str)
{
    if (!isValid(str))
        return 0;
    int count = 0;
    int maxDepth = 0;
    for (int i = 0; i < str.size(); i++)
    {
        if (str[i] == '(')
            // 因为已经保证了括号串有效，所以统计 count 的最大值即可
            maxDepth = max(maxDepth, ++count);
        else
            count--;
    }
    return maxDepth;
}
void main()
{
    string parentheseStr("(((()()()())))");
    cout << "The depth of the string is:" << parentheseDepth(parentheseStr) << endl;

    system("pause");
}
```

### 4.2.3 问题三

**[题目]** 找最长的有效括号子串（默认输入的字符串一定只包含右括号和左括号）。

**解题思路：**这种一维问题的通用思路在于，对每一个位置求一个结果，然后求出所有结果的最大或最小值。比如对该问题，可以求出**以每个位置括号结尾**的所有括号子串中最长有效子串的长度。

**代码：**

``` c plus
// 问题三. 最长有效括号子串问题
int maxValidParentheseLength(const string& str)
{
    if (str.empty())
        return 0;
    vector<int>dp(str.size(), 0);
    int pre = 0;
    int result = 0;
    for (int i = 1; i < str.size(); i++)
    {
        if (str[i] == ')')
        {
            // 仅当当前位置的括号是右括号的时候，以当前括号结尾的括号串才有可能是有效的
            // 否则以当前位置结尾的括号子串的有效长度必然是 0，而最初我们已经将所有 dp 元素都初始化为 0，所以不需要做任何修改
            // pre 算出来的是当前位置往前一个位置，查询以该位置为结尾的子串最长的有效括号串的长度，然后跳到使得其无效的那个括号串的位置
            pre = i - dp[i - 1] - 1;
            if (pre >= 0 && str[pre] == '(')
                // 如果 pre 已经小于 0 了，那说明当前位置依然找不到有效的括号串
                // 一个比较有趣的关系在于，找出来的 pre 位置的 dp[pre] 必然为 0
                // 但这个位置却有可能把 dp[pre - 1] 和 dp[i - 1] 位置的有效子串给连接起来
                dp[i] = dp[i - 1] + 2 + (pre > 0 ? dp[pre - 1] : 0);
        }
        result = max(result, dp[i]);
    }
    return result;
}
void main()
{
    string parentheseStr("((((((((()()()()))()())"); 
    cout << "The max valid length of the str is: " << maxValidParentheseLength(parentheseStr) << endl;   // 输出 18
    system("pause");
}
```



## 4.3 数组差值问题

**[题目]** 给定一个数组 arr，求差值为 k 的去重数字对。比如 arr = [0, 5, 3, 7, 2, 0]，此时要求找 k 为 2 的数字对，明显有 [5, 3]、[5, 7]、[0, 2]，去重的意思是虽然数组中有两个 0，但是我们只记录一对 [0, 2]。

**解题思路：**直接用哈希表，把数组中的所有数字全部放到哈希表里面去，然后遍历哈希表，比如到 3 就在哈希表里面找有没有 5，到 1 就在哈希表里面找有没有 3，这样不会出现重复统计。

**代码：**

``` c plus
// 数组对问题
int pairNumber_k(const vector<int>& arr, const int& k)
{
    unordered_set<int> hashSet;
    // 把 arr 的所有数据 copy 到哈希表中
    for_each(arr.begin(), arr.end(), [&](const int& number) {
        hashSet.insert(number);
        });
    int result = 0;
    for (auto it = hashSet.begin(); it != hashSet.end(); it++)
    {
        if (hashSet.find((*it) + k) != hashSet.end())
        {
            result++;
            cout << "The pair" << result << " is: (" << *it << ", " << (*it) + k << ")" << endl;
        }
    }
    return result;
}

void main()
{
	vector<int> arr = RandVector(1, 20, 20, true);
    cout << "The arr is: " << endl;
    ShowVector(arr);
    cout << "The number of the difference_k pair: " << pairNumber_k(arr, 3) << endl;;
    system("pause");
}
```

## 4.4 两个数组的平均值问题

**[题目]** 给一个包含 n 个整数元素的集合 a，一个包含 m 个整数元素的集合 b。定义 magic 操作为，从一个集合中取出一个元素，放到另一个集合里，且操作过
后每个集合的平均值都大大于于操作前。注意以下两点：

1）不可以把一个集合的元素取空，这样就没有平均值了；

2）值为 x 的元素从集合 b 取出放入集合 a，但集合 a 中已经有值为 x 的元素，则 a 的平均值不变（因为集合元素不会重复），b 的平均值可能会改变（因为 x 被取出了）；

3）其实前面两点中已经提到，此问题中的集合，表示给定数据结构中不能存在相同的元素。

问最多可以进行多少次 magic 操作？

**解题思路：**很明显（自己简单分析就能明白），如果两个数组的平均值相同，此时没有办法进行 magic 操作，而如果两个数组的平均值一个大一个小，明显从大平均值的数组中，拿出 **(小平均值, 大平均值)** 这个开区间内的数放到小平均值数组中就可以使得两个数组的平均值都变大**（小平均值的数组中不能存在该元素）**，**而此时没有办法从小平均值的数组中拿出任何数来实现目标的 magic 操作（拿小的，另一个数组平均值减小，拿大的自己会减小）。**

​		<font color = red>**关键：如何来使得 magic 操作次数尽量大，实际上可以注意到，magic 的操作空间取决于大平均值和小平均值的差值，所以在 magic 操作使得两个数组的平均值都提升的过程中，我们应当尽量使得大平均值数组的提升幅度大，而小平均值数组的提升幅度小，进而来提升 magic 的操作空间，所以我们自然每次应该从大平均值数组中的候选数中，挑最小的那一个放到小平均值数组中。**</font>

``` c plus
// 大小均值数组问题
// 因为我们需要修改这两个数组，所以不妨直接以值传递
int pairArrayAverageProblem(vector<int> arr1, vector<int> arr2)
{
    // 要求两个数组都不为空
    if (arr1.empty() || arr2.empty())
        return -1;
    // 统计两个数组的总值并计算均值
    int sum1 = 0, sum2 = 0;
    int size1 = arr1.size(), size2 = arr2.size();
    for (int i = 0; i < arr1.size(); i++)
        sum1 += arr1[i];
    for (int i = 0; i < arr2.size(); i++)
        sum2 += arr2[i];
    double aver1 = average(sum1, size1);
    double aver2 = average(sum2, size2);
    // 重定位两个数组
    vector<int>* arr_large_aver;
    vector<int>* arr_small_aver;
    int sum_large, sum_small;
    int size_large, size_small;
    if (aver1 > aver2)
    {
        arr_large_aver = &arr1;
        sum_large = sum1;
        size_large = size1;

        arr_small_aver = &arr2;
        sum_small = sum2;
        size_small = size2;
    }
    else if (aver1 < aver2)
    {
        arr_large_aver = &arr2;
        sum_large = sum2;
        size_large = size2;

        arr_small_aver = &arr1;
        sum_small = sum1;
        size_small = size1;
    }
    else
        // 两个数组的均值相同，则直接返回 0，此时没有办法进行 magic 操作
        return 0;
    cout << "Large average after initail: " << average(sum_large, size_large) << ", small average after initail: " << average(sum_small, size_small) << endl;
    cout << "// ======================================== //" << endl;
    // 对大均值数组进行排序（升序）
    sort(arr_large_aver->begin(), arr_large_aver->end(), less<int>());
    // 用于记录可操作的 magic 次数
    int result = 0;
    // 值得注意的是，在整个过程中不可能出现小均值数组的均值反超大均值数组的情况
    // 因为无论从均值为 large 的数组中，从 (small, large) 这个范围内取出任何的数，都不可能使得小均值数组的均值从 small 跳跃到 large 以上
    // 更不要说 large 在当前操作步中在增长
    // 而每一步操作之后，都只有可能使得大均值数组中 当前操作数之后的数 从不可进行 magic 操作变为可进行 magic 操作的状态
    // 因为大小边界均在上涨，所以我们最多只需要遍历一遍大数组即可
    // 甚至在某一步无法从大数组中取出数字之后，我们就可以直接 break 掉整个循环
    // 另外，值得注意的是，这个过程不可能把大数组拿空，因为大数组原本不为空，当只剩一个元素的时候，其均值就是该数，此时不满足 magic 条件
    for (int i = 0; i < arr_large_aver->size(); i++)
    {
        int cur = arr_large_aver->at(i);
        if (cur > average(sum_small, size_small)
            && cur < average(sum_large, size_large)
            && find(arr_small_aver->begin(), arr_small_aver->end(), cur) == arr_small_aver->end())
        {
            // 满足取值范围并且小数组中没有该数
            // 其实没有必要再创建一个新的哈希 set 来查找，因为理论上二分查找的时间复杂度就是 logN，和哈希表查询的时间是一样的
            result++;
            sum_large -= cur;
            size_large--;
            sum_small += cur;
            size_small++;
            cout << "The magic number: " << cur << ", ";
            cout << "large average after: " << average(sum_large, size_large) << ", small average after: " << average(sum_small, size_small);
            cout << ", the next number: " << (i + 1 == arr_large_aver->size() ? -1 : arr_large_aver->at(i + 1)) << endl;
        }
    }
    return result;
}
// 给定数组的 sum 和数组的元素个数 size，返回 double 类型的平均值，至于为什么是 double 类型自己想，很明显的
double average(const int& sum, const int& size)
{
    return double(sum * 1.0) / double(size * 1.0);
}

void main()
{
	// 6 12 18 24 30 36 均值为 21，总值 126，元素个数 6
	//vector<int> arr1{ 12,6,36,30,18,24 };
	// 2 4 6 8 10 均值为 6，总值 30，元素个数 5
	//vector<int> arr2{ 8,4,2,6,10 };
	// 第一次操作，拿出 12，大数组总值 114，元素个数 5，均值 22.8；小数组总值 42，元素个数 6，均值 7
	// 第二次操作，拿出 18，大数组总值 96，元素个数 4，均值 24；小数组总值 60，元素个数 7，均值 8.57
	// 仅有两次操作，因为下一次要拿就只能拿 24 了，但此时大数组的均值就是 24
    //cout << "The number of the magic operation is: " << pairArrayAverageProblem(arr1, arr2) << endl;

	// 6 12 18 24 30 36 均值为 21，总值 126，元素个数 6
	vector<int> arr1 = RandVector_NoRepeat(50, 100, 20, true);
	// 2 4 6 8 10 均值为 6，总值 30，元素个数 5
	vector<int> arr2= RandVector_NoRepeat(40, 100, 15, true);
	// 第一次操作，拿出 12，大数组总值 114，元素个数 5，均值 22.8；小数组总值 42，元素个数 6，均值 7
	// 第二次操作，拿出 18，大数组总值 96，元素个数 4，均值 24；小数组总值 60，元素个数 7，均值 8.57
	// 仅有两次操作，因为下一次要拿就只能拿 24 了，但此时大数组的均值就是 24
	cout << "The number of the magic operation is: " << pairArrayAverageProblem(arr1, arr2) << endl;
    system("pause");
}
```

## 4.5 有序栈问题

**[题目]** 请编写一个程序，对一个栈里的整型数据，按升序进行排序（即排序前，栈里的数据是无序的，排序后最大元素位于栈顶），要求最多**只能使用一个额外的栈存放临时数据**，但不得将元素复制到别的数据结构中。

**解题思路：**（其实也不是完全不能用其它变量来存储结果，可以用有限个额外的单变量...），准备一个辅助栈，要求这个辅助栈保持**从栈底到栈顶由大到小的顺序**，那么到最后再把辅助栈中的元素全部依次弹回原栈，那么**原栈就可以保持从栈底到栈顶从小到大的顺序。**

**代码：**

``` c plus
// 栈排序问题，为了生成数据方便，我们不妨就输入一个数组
void sortStackByStack(stack<int>& stk)
{
    if (stk.empty())
        return;
    // 辅助栈，因为最终的目标栈升序，所以该栈一定要始终保持降序
    stack<int> supStk;
    while (!stk.empty())
    {
        int top = stk.top();
        stk.pop();
        while (!supStk.empty() && top > supStk.top())
        {
            // 这里需要注意，不仅仅是逻辑可能出错，coding 的时候一定要关注逻辑成立的前提条件
            // 对这里而言，如果辅助栈已经是空的了，则直接往里面推入元素即可
            // 如果当前弹出的 top 比辅助栈的栈顶要大，那如果此时直接把这个元素往辅助栈里面放，则不可能满足辅助栈降序
            // 则此时把辅助栈中的元素挨个弹回到原栈，直到可以把 top 元素放到辅助栈中并保持降序
            stk.push(supStk.top());
            supStk.pop();
        }
        // 把不合规矩的元素全部弹回去之后，就可以压入当前元素
        supStk.push(top);
    }
    // 此时所有元素都已经以降序顺序放到辅助栈中，则挨个将元素弹回原栈即可
    while (!supStk.empty())
    {
        stk.push(supStk.top());
        supStk.pop();
    }
}
void main()
{
	vector<int> arr = RandVector_NoRepeat(10, 200, 40, 1);
	stack<int> stk;
	for (int i = 0; i < arr.size(); i++)
		stk.push(arr[i]);
	sortStackByStack(stk);
	while (!stk.empty())
	{
		// 可以看到，越往后显示的元素越小，这是因为栈其实是从数组的最后一个元素开始弹出值，所以此时最先输出的是大值
		cout << stk.top() << ", ";
		stk.pop();
	}
	cout << endl;
    system("pause");
}
```

## 4.6 数字转字母串问题

**[题目]** 将给定的数转换为字符串，原则如下：1 对应 a，2 对应 b，...26 对应 z，例如 12258 可以转换为 "abbeh"，"aveh"，"abyh"，"Ibeh” and "lyh"，个数为5，编写一个函数，给出可以转换的不同字符串的个数。

**解题思路：**之前做过一道类似的题。从左往右尝试，其实对于每个位置，只有 3 种决策情况，即

​		**情况1：**i 位置为 0，此时以该位置为起点无法产生任何有效的转换方法；

​		**情况2：**i 位置不为 0，且以 i 位置为单独的一个元素进行转换，此时对应后续函数为 F(i + 1)；

​		**情况3：**i 位置不为 0，且以 i 和 i + 1 位置一起构成一个元素进行转换（组合不超过 26 的话），此时对应后续函数为 F(i + 1)。

**方法1——普通递归：**

``` c plus
// === 数组转字符串的方法数问题 === //
// 方法一，递归实现
int numToStrWays_RC(const vector<int>& arr)
{
    if (arr.empty())
        return 0;
    return numToStrWays_RC_process(arr, 0);
}
// 表示从 index 位置往后一共有多少种情况
int numToStrWays_RC_process(const vector<int>& arr, const int& index)
{
    // 终止位置
    if (index == arr.size())
        return 1;
    // 如果一个位置为 0，则必然不能发生转换，这一条路都被断掉
    if (arr[index] == 0)
        return 0;
    int result = 0;
    // 加上当前位置单独转换的情况
    result += numToStrWays_RC_process(arr, index + 1);
    if (index == arr.size() - 1)
        // 如果当前已经在最后一个位置，则不可能和后一个数一起组成一个字母转换
        return result;
    if ((arr[index] * 10 + arr[index + 1]) <= 26)
        // 要当前既不在最后一个位置，并且其和后面一个数字的组合在 26 以内，才能够去加这一部分，否则还是只能返回当前位置单独转换的情况
        result += numToStrWays_RC_process(arr, index + 2);
    return result;
}
```

**方法2——动态规划：**

```  c plus
// 方法二，动态规划
int numToStrWays_DP(const vector<int>& arr)
{
    // 因为 base case 在 index 为 arr.size() 的位置上，所以需要多准备一个格子
    vector<int> dp(arr.size() + 1, 0);
    int N = arr.size();
    dp[N] = 1;
    // 这个 base case 也需要注意，最后一个位置如果不是 0，则一定可以完成且也仅可以完成一种转换，很直观
    dp[N - 1] = arr[N - 1] == '0' ? 0 : 1;
    for (int i = N - 2; i >= 0; i--)
    {
        // 从后往前推
        if (arr[i] != 0)
        {
            // 此时不需要去判断 i 是不是 size() - 1 位置
            dp[i] += dp[i + 1];
            if (arr[i] * 10 + arr[i + 1] <= 26)
            {
                dp[i] += dp[i + 2];
            }
        }
    }
    return dp[0];
}
void main()
{
	vector<int>arr = RandVector(0, 9, 50, 1);
    for_each(arr.begin(), arr.end(), [=](const int& value) {
        cout << value;
        });
    cout << endl;
    cout << "The number of the converting ways is (DP method): " << numToStrWays_DP(arr) << endl;
    cout << "The number of the converting ways is (RC method): " << numToStrWays_RC(arr) << endl;

    system("pause");
}
```

**值得的是，**这个问题中是很可能出现 0 种转换方法的，比如
$$
102\bold{30}12839105
$$
只要在数字串中出现了 x0，并且 x0 > 26 的情况，此时转换方式必然为 0 种。不妨设该位置为 i 位置，因为 dp[i + 1] 必然为 0，而对 dp[i] 而言，明显的，不管其是自己作转换还是和后面的 0 联合作转换，返回值都是 0，则 dp[i] 也必然为 0，而我们知道，这个问题产生多解的地方就在于 i 位置的结果是依赖于 i + 1 位置和 i + 2 位置的，所以一旦有连续两个位置的结果为 0，那么整个问题的结果必然为 0。

## 4.7 二叉树的递归套路

**[题目]** 二叉树每个结点都有一个 int 型权值，给定一棵二叉树，要求计算出从根结点到叶结点的所有路径中**（注意对路径的定义，是向下算路径，还是任意两个结点之间都算路径）**，权值和最大的值为多少。

**解题思路1——非递归套路：**给一个全局变量，用于记录当前的最大路径和，其实关键就是设计一个合理的递归函数，直接看代码：

``` c plus
// === 查找树中路径的权值最大和 === //
// 一个静态变量，用来记录最大值
static int maxDis = INT_MIN;
// 给定根结点即可
int maxDistance1(mTree::TNode* node)
{
    if (node == NULL)
        return 0;
    // 执行该函数即可
    maxDistance_process1(node, 0);
    return maxDis;
}
// node表示当前结点，pre 表示从根节点到当前路径 node 已经得到的权值和
void maxDistance_process1(mTree::TNode* node, const int& pre)
{
    if (node->left == NULL && node->right == NULL)
    {
        // 如果当前结点是叶子结点了，则可以更新最大值
        // 否则不断向下找
        maxDis = max(maxDis, pre + node->value);
        return;
    }
    // 此时必然可以执行下面两个 if 中的某一个
    if (node->left != NULL)
        // 这两个 if 是同级的
        maxDistance_process1(node->left, pre + node->value);
    if (node->right != NULL)
        maxDistance_process1(node->right, pre + node->value);
}
```

**解题思路2——递归套路思想：**直接看代码，不赘述：

``` c plus
// 方法二，递归套路，说的是从子树里面拿到我们需要的数据，然后逐层向上返回的思想
int maxDistance2(mTree::TNode* node)
{
    if (node == NULL)
        return 0;
    return maxDistance_process2(node, 0);
}
// node表示当前结点，pre 表示从根节点到当前路径 node 已经得到的权值和
int maxDistance_process2(mTree::TNode* node, const int& pre)
{
    if (node->left == NULL && node->right == NULL)
        // 对叶子结点，直接返回该路径上的距离和即可，其没的选
        return pre + node->value;
    int maxDis = INT_MIN;
    if (node->left != NULL)
        // 从左边要数据
        maxDis = maxDistance_process2(node->left, pre + node->value);
    if (node->right != NULL)
        // 从右边要数据，并整合出大值，向上返回
        maxDis = max(maxDis, maxDistance_process2(node->right, pre + node->value));
    return maxDis;
}
void main()
{
    // 创建一棵红黑树，用这个红黑树来完成计算
    // 值得注意的是，因为 nilNode 的 value 我们默认设置为 NULL，所以其不影响计算结果，所以就这么写问题不大
    mRedBlackTree rbTree;
	vector<int> arr = RandVector_NoRepeat(1, 100, 35, 1);
    for (int i = 0; i < arr.size(); i++)
        rbTree.insert(arr[i]);
    rbTree.printTree();
    cout << "The max distance is (method 1): " << maxDistance1(rbTree.root) << endl;
    cout << "The max distance is (method 2): " << maxDistance2(rbTree.root) << endl;
    system("pause");
}
```

## 4.8 有序矩阵问题

**[题目]** 矩阵无序，但是行有序，列有序（不妨设都是升序），现在要求快速找出一个数 aim。

<font color =red>**解题思路（错误的）*：**从左上角开始走（矩阵中的最小值），先沿着当前行走，直到发现某一列的第一行比 aim 大，则说明该列以及之后的所有列必然都比 aim 大，则从左边一列，沿着列方向向下走，因为此时右边的所有数都放弃了，则只需要看左边的数，如果左边的数比当前数小，则当前行中，当前列左边的数可全部放弃，因为它们都必然比 aim 小，并继续向下走，**值得注意的是**，每一步踩着的数有可能比 aim 大也可能比 aim 小。</font>

**正确的：**其实就很简单，从右上角开始走，此时向下走，必然导致矩阵元素变大，向左走必然导致矩阵元素变小，那直接按照这个规律走就完事了。另外，如果想要找出所有的 aim 值，其实也很简单，只需要从其左下角的数开始递归查找即可**（左上角都比 aim 小，右下角都比 aim 大，右上角已经走过了，没有结果）**，我们可以实现一下这个操作**（其实原函数实现的是画一个框在右上角，左下角那个元素是 aim 元素这么一个效果）**。

**值得注意的是：**上述实现的是行列严格有序的情况，如果同行同列可能出现相同元素，则需要稍作修改，此时需要从左边或下边的数开始递归查找，并还需要遍历同列下边或同行左边的所有元素看是否有 aim 值，那么这样一个函数可以用来统计一个有序矩阵中有多少个 aim 值，这个在下面函数中实现了。

**例：**比如 aim 为 5，可以看到，实际上是可能出现多个相同数字的。
$$
\begin{matrix}
1 & 3 & 4 & 8 & 9\\
2 & 4 & 7 & 9 & 10\\
3 & 5 & 8 & 10 & 11\\
4 & 7 & 9 & 11 & 12\\
5 & 8 & 10 & 12 & 13\\
\end{matrix}\
$$
**另外，**该方法的时间复杂度为 $O(N + M)$，可以看输出的结果：

![image-20230504151156234](C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230504151156234.png)

**代码：**

``` c plus
// === 矩阵查找问题 === //
// 问题一. 找出有序矩阵中的 aim 值的个数（可以是非严格升序的矩阵）
int aimValueNumInMatrix(const MatrixXi& mat, const int& aim)
{
    // 当前矩阵总的规模
    int rowNumber = mat.rows();
    int colNumber = mat.cols();
    // 当前搜索到的位置
    int curRow = 0;
    int curCol = colNumber - 1;
    int result = 0;
    while (curRow < rowNumber && curCol > -1)
    {

        if (mat(curRow, curCol) == aim)
        {
            result++;
            // 如果在某一个位置发现了对应的元素
            // 则从当前元素下面开始继续找，并搜索该行左边是否还有相等的数
            for (int i = 0; i <= curCol - 1; i++)
                result += (mat(curRow, i) == aim) ? 1 : 0;
            curRow++;
        }
        else if (mat(curRow, curCol) > aim)
            // 如果当前位置的数比 aim 大，则向左继续找
            curCol--;
        else
            // 如果当前位置的数比 aim 小，则向下继续找
            curRow++;
    }
    return result;
}
void main()
{
	int aim1 = 9;
	int aim2 = 10;
	int aim3 = 23;
	int aim4 = 41;
	Eigen::MatrixXi mat = MatrixXi::Zero(6, 7);
	mat << \
		1, 4, 6, 6, 8, 10, 10,
		2, 6, 7, 8, 9, 10, 10,
		3, 10, 11, 12, 15, 23, 23,
		10, 10, 15, 18, 20, 23, 23,
		16, 16, 19, 23, 31, 36, 38,
		20, 23, 23, 30, 32, 40, 40;
	cout << mat << endl;
	cout << "Number of the " << aim1 << " is: " << aimValueNumInMatrix(mat, aim1) << endl;  // 输出 1
	cout << "Number of the " << aim2 << " is: " << aimValueNumInMatrix(mat, aim2) << endl;  // 输出 7
	cout << "Number of the " << aim3 << " is: " << aimValueNumInMatrix(mat, aim3) << endl;  // 输出 7
	cout << "Number of the " << aim4 << " is: " << aimValueNumInMatrix(mat, aim4) << endl;  // 输出 0
	system("pause");
}
```

**[推广]** 一个矩阵，其只含有 0 和 1，并且在每一行，0 全部在左边，而 1 全部在右边，现在请返回 1 最多的那一行。

**解题思路：**从右上角开始走，只要在一行中，左边还有 1，就一直往左边走并记录走过的所有行中，最多有多少个 1；当左边没有 1 了，再往下走，其实思路很简单，看代码就懂。
$$
\begin{matrix}
0 & 1 & 1 & 1 & 1\\
0 & 0 & 1 & 1 & 1\\
0 & 0 & 0 & 0 & 1\\
0 & 1 & 1 & 1 & 1\\
1 & 1 & 1 & 1 & 1\\
\end{matrix}\
$$
**代码：**

``` c plus
// 问题二. 找出 01 矩阵中，1 最多的那一行
list<int> rowMostOne(const MatrixXi& mat)
{
    // 设置基本变量
    int rowNumber = mat.rows();
    int colNumber = mat.cols();
    // 不需要记录当前行，因为行是必然要被遍历的
    int curCol = colNumber - 1;
    list<int> result;
    int max1Number = 0;
    for (int curRow = 0; curRow < rowNumber; curRow++)
    {
        bool flag = 0;
        while(mat(curRow, curCol) == 1)
        {
            // 如果当前位置是 1，则位置向左边移动，并将 max1Number++
            curCol--;
            max1Number++;
            // 只要在这个循环中，对 flag 置 1 了，则说明当前行的 1 比上一行要多，则后续我们需要更新 result
            flag = 1;
        }
        if (curCol == colNumber - 1)
            // 说明当前行没有 1，但依然需要推入这一行
            result.push_back(curRow);
        else if (flag == 0 && mat(curRow, curCol + 1) == 1)
            // 说明当前遇到的这一行和上一行的 1 的个数一样，则需要向 result 中推入该行
            result.push_back(curRow);
        else if (flag == 1)
        {
            // 说明需要更新 result
            result.clear();
            result.push_back(curRow);
        }
        // 如果没有任何一项符合的，说明不需要作任何更新
    }
    return result;
}
void main()
{
	Eigen::MatrixXi mat = MatrixXi::Zero(9, 10);
	mat << \
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
		0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
		0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
		0, 0, 0, 1, 1, 1, 1, 1, 1, 1,
		0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
		0, 0, 0, 0, 1, 1, 1, 1, 1, 1,
		0, 0, 0, 1, 1, 1, 1, 1, 1, 1;
	cout << mat << endl;
	list<int> rows = rowMostOne(mat);
	cout << "The rows who have the most 1 is: ";
	for (auto it = rows.begin(); it != rows.end(); it++)
		cout << "Row index " << *it << ", ";
	cout << endl;
	system("pause");
}
```

## 4.9 洗衣机问题

**[题目]** 有 n 个打包机器从左到右一字排开，上方有一个自动装置会抓取一批放物品到每个打包机上，放到每个机器上的这些物品数量有多有少，由于物品数量不相同，需要工人将每个机器上的物品进行移动从而到达物品数量相等才能打包。每个物品重量太大，**每次只能搬一个物品进行移动**，为了省力，**只在相邻的机器上移动。**请计算在搬动最小轮数的前提下，使每个机器上的物品数量相等。如果不能使每个机器上的物品相同返回 -1。
例如 [1, 0, 5] 表示有 3 个机器，每个机器上分别有 1、0、5 个物品，经过这些轮后：

**第一轮：**[1, 0 <- 5]  => [1, 1, 4]

**第二轮：**[1 <- 1<- 4] => [2, 1, 3] 

**第三轮：**[2, 1 <- 3] => [2, 2, 2]

移动了3轮，每个机器上的物品相等，所以返回 3，例如 [2, 2, 3] 表示有 3 个机器，每个机器上分别有 2、2、3 个物品，这些物品不管怎么移动，都不能使三个机器上物品数量相等，返回 -1。

**解题思路：**首先，先判断能否做到均分，这个很简单，就是物体的和模上机器数，如果为 0，则说明必然能将物体在机器上均分。

然后有这样一个思路：可以知道，如果一个机器上缺物体，则其已有物体减去目标物体数为负数，反之为正数。此时仅关注某一个机器，那么观察其左右两边所有机器综合的物体数，则有以下几种情况：

​		**情况1：**左右均为负数如 a 和 b（绝对值），此时说明两边机器的物体都要从中间位置机器得到，而一个机器在一轮中只能出去 1 件物体，那么此时至少需要 a + b 轮；

​		**情况2：**左右均为正数如 a 和 b，此时说明两边机器的物体都要送到中间来，而一个机器在一轮中能够最多接收左右两边共 2 件物体，则此时至少需要 max( a, b) 轮；

​		**情况3：**左右一正一负，同理至少需要 max(a, b) 轮。

<font color =red>**则对每一个位置算一次，找出最大值，就是我们需要的结果。**</font>

**代码：**

``` c plus
// === 洗衣机问题 === //
int packingMachine(const vector<int>& arr)
{
    if (arr.empty())
        return 0;
    // 然后判断能否整除
    int sum = 0;
    int size = arr.size();
    for_each(arr.begin(), arr.end(), [&](const int& value) {sum += value; });
    if (sum % size != 0)
        // 说明无法将物体均分到各个机器
        return 0;
    int avg = sum / size;
    // 表示已经遍历位置的总和，用于简化求解过程
    int leftSum = 0;
    int result = 0;
    for (int i = 0; i < size; i++)
    {
        // 遍历所有元素，求出每个位置最大的操作数
        // 求出左边的输入（负数，说明需要物体）输出（正数，说明需要往外送物体）值
        int L = leftSum - i * avg;
        int R = (sum - leftSum - arr[i]) - (size - i - 1) * avg;
        if (L < 0 && R < 0)
            // 说明两边都需要中间的机器输送衣服，此时总轮数为两侧绝对值之和
            result = max(result, abs(L) + abs(R));
        else
            // 看文档
            result = max(result, max(abs(L), abs(R)));
        // 循环结束前对遍历位置总和进行处理
        leftSum += arr[i];
    }
    return result;
}
void main()
{
	vector<int> arr{ 100,0,0,0 };
	cout << "The minimum number of the operation is: " << packingMachine(arr) << endl;
	system("pause");
}
```

## 4.10 矩阵相关问题

### 4.10.1 Zigzag打印

**[题目]** Zigzag 方法打印一个矩阵。直接看代码，其实没啥好说的。

**代码：**

``` c plus
// 问题一. zigzag 打印
void printMatrixZigZag(const MatrixXi& mat)
{
    // 给出两个点 (lbR, lbC) 和 (rtR, rtC)，打印这条路径上的所有结果
    // lb(left bottom) 表示的是左下边界，rt(right top) 表示的是右上边界
    int lbR = 0;
    int lbC = 0;
    int rtR = 0;
    int rtC = 0;
    // 第一次是从左下角往右上角打印，所以初始化为 1
    bool ifReverse = 1;
    // 拿到行数和列数
    int rowBound = mat.rows() - 1;
    int colBound = mat.cols() - 1;
    // 明显可以看到
    // 当左下边界没有碰到最大行数时，其应该行数增加，否则列数增加
    // 当右上边界没有碰到最大列数时，其应该列数增加，否则行数增加
    // 可以想到，最大的打印次数为 行数 + 列数 - 1
    // 当然，也可以通过最后两个边界指示的 int 变得完全相同来判断
    for (int i = 0; i < rowBound + colBound + 1; i++)
    {
        print_process(mat, lbR, lbC, rtR, rtC, ifReverse);
        // 如果左下边界碰到了行边界，则边界行数不加列数加
        // 值得注意的是，为了不在同一步中列受到行的影响，列的判断应该在前面
        lbC = (lbR == rowBound ? lbC + 1 : lbC);
        lbR = (lbR == rowBound ? lbR : lbR + 1);
        // 如果右上边界碰到了列边界，则边界列数不加行数加
        // 同理，为了不在同一步中行受到列的影响，行的判断应该在前面
        rtR = (rtC == colBound ? rtR + 1 : rtR);
        rtC = (rtC == colBound ? rtC : rtC + 1);
        ifReverse = !ifReverse;
    }
}
// 给出两个点 (vR, vC) 和 (hR, hC)，打印这条路径上的所有结果
void print_process(const MatrixXi& mat, int lbR, int lbC, int rtR, int rtC, const bool& ifReverse)
{
    if (ifReverse)
    {
        // 如果该参数为真，说明不反转打印，则从 (lbR, lbC) 打印到 (rtR, rtC)
        while (lbR != rtR - 1)
            // hR - 1 是因为 hR 也要打印，而现在的行是减小的
            cout << mat(lbR--, lbC++)<<", ";
    }
    else
    {
        // 如果该参数为假，说明反转打印，则从 (rtR, rtC) 打印到 (lbR, lbC)
        while (rtR != lbR + 1)
            cout << mat(rtR++, rtC--)<<", ";
    }
}
void main()
{
	Eigen::MatrixXi mat = MatrixXi::Zero(4, 4);
	mat << \
		1, 4, 6, 6,
		2, 6, 7, 8,
		3, 10, 11, 12,
		12, 19, 20, 15;
	cout << mat << endl;
	cout << "The zigzag print result is: " << endl;
	printMatrixZigZag(mat);
	cout << endl;

	system("pause");
}
```

**输出结果：**





![image-20230504170521374](C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230504170521374.png)

### 4.10.2 螺旋打印矩阵

**[题目]** 顾名思义。直接看代码。其实所谓宏观调度，就是给定一个大的框架，通过问题的分解来得到答案，而非每一步都去研究细节如何实现。

**解题思路：**写一个函数，可以打印给定左上角和右下角决定的矩阵的边界，当然，主要需要注意仅一行和仅一列两种特殊情况，然后重复调用该函数即可。、

**代码：**

``` c plus
// 问题二. 顺时针螺旋打印
void printMatrixSpiral(const MatrixXi& mat)
{
    // 得到矩阵的尺寸
    int rowNumber = mat.rows();
    int colNumber = mat.cols();
    if (rowNumber == 0 || colNumber == 0)
        return;
    // 确定初始两个点的位置
    // lt 左上角 left top，rb 右下角 right bottom
    int ltR = 0;
    int ltC = 0;
    int rbR = rowNumber - 1;
    int rbC = colNumber - 1;
    while (ltR <= rbR)
    {
        printEdge(mat, ltR, ltC, rbR, rbC);
        ltR++; ltC++;
        rbR--; rbC--;
    }
}
// lt 表示左上角，rb 表示右下角
void printEdge(const MatrixXi& mat, const int& ltR, const int& ltC, const int& rbR, const int& rbC)
{
    if (ltR == rbR)
    {
        // 如果需要打印的边仅有一行
        for (int i = ltC; i <= rbC; i++)
        {
            // 从该行的一行左边打印到右边即可
            cout << mat(ltR, i) << ", ";
        }
    }
    else if (ltC == rbC)
    {
        // 如果需要打印的边仅有一列
        for (int i = ltR; i <= rbR; i++)
        {
            cout << mat(i, ltC)<<", ";
        }
    }
    else
    {
        // 说明是一般的情况，需要打印 4 条边界
        int curR = ltR;
        int curC = ltC;
        // 1. 走完上横向边界
        // 取等的时候不要打印，否则每个角点被打印两次
        for (; curC < rbC; curC++)
            cout << mat(curR, curC) << ", ";
        // 2. 走完右竖向边界
        for (; curR < rbR; curR++)
            cout << mat(curR, curC) << ", ";
        // 3. 走完下横向边界
        for (; curC > ltC; curC--)
            cout << mat(curR, curC) << ", ";
        // 4. 走完左竖向边界
        for (; curR > ltR; curR--)
            cout << mat(curR, curC) << ", ";
    }
}

void main()
{
    Eigen::MatrixXi mat = MatrixXi::Zero(5, 5);
    mat << \
        1, 4, 6, 6, 3,
        2, 6, 7, 8, 4,
        3, 10, 11, 12, 103,
        12, 19, 20, 15, 109, 
        45, 92, 102, 33, 77;
    cout << mat << endl;
    cout << "The spiral print result is: " << endl;
    printMatrixSpiral(mat);
    cout << endl;
    system("pause");
}
```

### 4.10.3 顺时针旋转矩阵问题

**[题目]** 将一个方针中的元素顺时针旋转，比如
$$
\begin{matrix}
1 & 4 & 6 \\
2 & 13 & 8\\
3 & 11 & 9\\
\end{matrix}\
\rightarrow\ 
\begin{matrix}
3 & 2 & 1 \\
11 & 13 & 4\\
9 & 8 & 6\\
\end{matrix}\
$$
**解题思路：**写一个函数，可以旋转给定左上角和右下角决定的矩阵边界。对每一个边界进行分组，每组 4 个元素，这些元素之间按顺序调换位置，组数为矩阵行或列数 - 1。

**代码：**

``` c plus
// 问题三. 顺时针旋转矩阵
void rotateMatrixClockwise(MatrixXi& mat)
{
    int rowNumber = mat.rows();
    int colNumber = mat.cols();
    if (rowNumber == 0 || colNumber == 0)
        return;
    int ltR = 0;
    int ltC = 0;
    int rbR = rowNumber - 1;
    int rbC = colNumber - 1;
    while (ltR < rbR)
    {
        rotateEdge(mat, ltR, ltC, rbR, rbC);
        ltR++; ltC++;
        rbR--; rbC--;
    }
}
void rotateEdge(MatrixXi& mat, const int& ltR, const int& ltC, const int& rbR, const int& rbC)
{
    // 计算组数，每一组有 4 个元素
    int groupNumber = rbR - ltR;
    for (int i = 0; i < groupNumber; i++)
    {
        // 每一次迭代处理一组数据，这一组数据中要处理 4 个位置的元素
        // 各个位置是怎么对应的，用脚想一下就知道，不用多说
        int tempElement = mat(ltR, ltC + i);
        mat(ltR, ltC + i) = mat(rbR - i, ltC);
        mat(rbR - i, ltC) = mat(rbR, rbC - i);
        mat(rbR, rbC - i) = mat(ltR + i, rbC);
        mat(ltR + i, rbC) = tempElement;
    }
}
void main()
{
	Eigen::MatrixXi mat = MatrixXi::Zero(5, 5);
	mat << \
		1, 4, 6, 6, 3,
		2, 6, 7, 8, 4,
		3, 10, 11, 12, 103,
		12, 19, 20, 15, 109, 
		45, 92, 102, 33, 77;
	cout << mat << endl;
	cout << "The clockwise rotate result is: " << endl;
	rotateMatrixClockwise(mat);
	cout << mat << endl;
	cout << endl;
	system("pause");
}
```

## 4.11 质数分解问题

**[题目]** 假设 s 和 m 初始化，s = "a"；m = s；

再定义两种操作，**第一种操作：**
		m = s;
		s = s + s;

**第二种操作：**
		s = s + m;

求最小的操作步骤数，可以将 s 拼接到长度等于 n。比如如果要把长度搞到 4，最快就两步，第二种操作来一次，第一种操作来一次即可，或者调用两回一操作也行。

**解题思路：**

1. **如果给出的目标 n 是质数长度（确实是质数，不是奇数）**，则只调用操作二就是最终结果，这个结论其实是显而易见的，因为此时操作一只能调用 1 次且仅能在第一次操作时调用，因为如果在非第一次调用，此时目标必然含有非 1 和其本身的其它因子，则必然不是质数，而在第一次操作时调用操作一和二其实是等价的，所以不妨直接全部调用操作二，则该结论成立，此时对应的操作数为 n - 1，即调用 n - 1 次操作二;
2. **如果给出的目标 n 是不是质数长度**，其实感觉没有什么道理可言，现在把这个目标 n 分解为其对应的质数乘积（算术基本定律），最终结果为所有质数因子之和减去质数因子的个数。

``` C PLUS
// === 质数分解问题 === //
bool isPrim(const int& n)
{
    // 如果是 1 或者更小的数，则说不是素数
    if (n < 2)
        return false;
    // 只需要在 sqrt(n) 范围内查找即可
    int max = int(sqrt(n * 1.0));
    for (int i = 2; i <= max; i++)
    {
        // i 一定要取到 max，比如 49，sqrt 之后是 7，而其只含有 1、7、49 3个因子，所以一定要检测到 7 才行
        if (n % i == 0)
            return false;
    }
    // 说明没有找到对应的因子，则说明是素数
    return true;
}
// 将一个非质数进行分解，筛选出其对应的非 1 质数因子
vector<int> divsSumAndCount(const int& n)
{
    int sum = 0;
    int count = 0;
    int tmp = n;
    // 这个循环过程倒是挺有意思的
    // 比如 98，其素数因子是 2 × 7 × 7，那么对应几个变量的变化情况为（for 循环一次后，i++ 之前）
    // i = 2, tmp = 49
    // i = 7, tmp = 7
    // i = 7, tmp = 7
    int totalIterate = 0;
    // 然后就跳出循环了
    for (int i = 2; i <= tmp; i++)
    {
        while (tmp % i == 0)
        {
            sum += i;
            count++;
            tmp /= i;
        }
        totalIterate = i;
    }
    // 我平时倒真没注意过循环上限变化的情况
    cout<<"Total iterate time: " << totalIterate << endl;
    return vector<int>{sum, count};
}
// 给定的 n 表示目标字符串的长度
int minOperations(const int& n)
{
    if (n < 2)
        return 0;
    if (isPrim(n))
        return n - 1;
    auto result = divsSumAndCount(n);
    return result[0] - result[1];
}
void main()
{
	cout << "The minimum operation time is: " << minOperations(49) << endl;
	system("pause");
}
```

## 4.12 Top K 问题

**[题目]** 给定一个字符串类型的数组 arr，求其中出现次数最多的前 K 个。

**解题思路一：**大根堆，建立大根堆的最低时间复杂度为 $O(N)$，然后弹出前 K 个即可，而每次调整的时间复杂度为 $O(log(N))$。理论上讲，可以边统计边建立大根堆，但此时理论最大的时间复杂度为 $(O(Nlog(N)))$，因为有可能每一步添加字符串之后都要 Heapify**（值得注意的是，Heapify 是一个把结点向下沉的操作，所以此时要做的事情应该更类似于 Heap Insert）**，当然事实并非如此，但不妨就先完整统计词频，然后再 Heapify，不过动态建立大根堆可以满足 **[补充题目]** 的要求。

``` c plus
vector<node_topK> topK_static_bigRootHeap(const vector<string>& strs, const int& K)
{
    // 创建一个大根堆
    priority_queue<node_topK, vector<node_topK>, topK_comparator_bigRoot> heap;
    // 用该哈希表统计所有出现过的词
    unordered_map<string, node_topK> hash;
    for (int i = 0; i < strs.size(); i++)
    {
        if (hash.find(strs[i]) == hash.end())
            hash.insert(make_pair(strs[i], node_topK(1, strs[i])));
        else
            hash[strs[i]].times++;
    }
    // 然后放到大根堆排序即可
    for (auto it = hash.begin(); it != hash.end(); it++)
        heap.push(it->second);

    vector<node_topK> result;
    for (int i = 0; i < K; i++)
    {
        result.push_back(heap.top());
        heap.pop();
    }
    return result;
}
```

**解题思路二：**一个大小不超过 K 的小根堆，其表示目前出现次数最多的 K 个字符串。每次只需要对比对应字符串出现次数和小根堆堆顶元素的出现次数即可确定当前字符串能够进入小根堆。值得注意的是，如果当前遍历到某个字符串对应的此处是小根堆堆顶元素对应次数，要分情况，如果小根堆元素满了，则不加入该字符串，否则加入，**但话说回来，如果每一步都要从哈希表中查询一个元素，那每一步的时间复杂度不都 $O(logN)$ 了吗。**

``` c plus
// 方法二. 小根堆实现
vector<node_topK> topK_static_smallRootHeap(const vector<string>& strs, const int& K)
{
    // 创建一个小根堆，用于维护统计过程中所有出现的结点信息
    priority_queue<node_topK, vector<node_topK>, topK_comparator_smallRoot> heap;
    // 用该哈希表统计所有出现过的词
    unordered_map<string, node_topK> hash;
    for (int i = 0; i < strs.size(); i++)
    {
        if (hash.find(strs[i]) == hash.end())
            hash.insert(make_pair(strs[i], node_topK(1, strs[i])));
        else
            hash[strs[i]].times++;
    }
    // 然后在遍历哈希表的过程中，始终只维护固定个数的结点
    for (auto it = hash.begin(); it != hash.end(); it++)
    {
        if (heap.size() < K)
            // 小根堆元素个数不够，则直接填充元素即可
            heap.push(it->second);
        else
        {
            // 小根堆元素个数够了，则看当前元素能否干了小根堆顶的元素
            if (it->second.times > heap.top().times)
            {
                // 能干掉则操作，否则不操作
                heap.pop();
                heap.push(it->second);
            }
        }
    }
    vector<node_topK> result(K, node_topK(0, ""));
    int index = K - 1;
    while (!heap.empty())
    {
        // 由于从小根堆中挨个弹出元素得到的是升序的结果，所以我们需要把先弹出的元素放到最后
        result[index--] = heap.top();
        heap.pop();
    }
    return result;
}
```

**对照组：**直接用有序表统计。

``` c plus
// 对数器，遍历法求所有元素，由于词频可能重复，所以用 multimap
multimap<int, string, greater<int>> topK_static_orderedMap(const vector<string>& strs)
{
    // map 用于维护结果
    multimap<int, string, greater<int>> result;
    // 用该哈希表统计所有出现过的词
    unordered_map<string, node_topK> hash;
    for (int i = 0; i < strs.size(); i++)
    {
        if (hash.find(strs[i]) == hash.end())
            hash.insert(make_pair(strs[i], node_topK(1, strs[i])));
        else
            hash[strs[i]].times++;
    }
    for (auto it = hash.begin(); it != hash.end(); it++)
        result.insert(make_pair(it->second.times, it->second.str));
    return result;
}
void main()
{
    vector<string> oriStrs{ 
        "James", "Curry", "Durant", "Kevin", "Lebron", 
        "Jordan", "Kobe", "Harden", "Anthony", "Davis",
        "Billy", "Rarondo", "Jacky", "Jay", "Taylor",
    };
    vector<string> strs;
    int oriStrsSize = oriStrs.size();
    // 所有词出现的总数
    int strsSize = 10000;
    // 目标 K
    int K = 8;
    for (int i = 0; i < strsSize; i++)
    {
        int choice = RandInt(0, oriStrsSize - 1, 1);
        strs.push_back(oriStrs[choice]);
    }
    auto result_bigRootHeap = topK_static_bigRootHeap(strs, K);
    auto result_smallHeap = topK_static_smallRootHeap(strs, K);
    auto result_orderedMap = topK_static_orderedMap(strs);
    cout << "// ===== The top K result by big root heap: ===== //" << endl;
    for (int i = 0; i < result_bigRootHeap.size(); i++)
        cout << "The number " << i + 1 << "th highest frequency string is: " << result_bigRootHeap[i].str\
        <<", the whole time is: " << result_bigRootHeap[i].times << endl;

    cout << "// ===== The top K result by small root heap: ===== //" << endl;
    for (int i = 0; i < result_smallHeap.size(); i++)
        cout << "The number " << i + 1 << "th highest frequency string is: " << result_smallHeap[i].str\
        << ", the whole time is: " << result_smallHeap[i].times << endl;

    cout << "// ===== The top K result by ordered map: ===== //" << endl;
    int i = 1;
    for (auto it = result_orderedMap.begin(); it != result_orderedMap.end(); it++)
        cout << "The number " << i++ << "th highest frequency string is: " << it->second\
        << ", the whole time is: " << it->first << endl;
    system("pause");
}
```

**输出结果：**

<img src="C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230507093655474.png" alt="image-20230507093655474"  />

**[补充题目]** 可以随时加入字符串，而还要动态显示当前的 Top K 词频的字符串。值得注意的是，Top K 中，不会打印所有词频相同的结果，即其最多只打印 K 个。要求 add 的时间复杂度为 $O(logK)$，要求打印函数的时间复杂度不超过 $O(K)$。

**解题思路：**其实 **[题目]** 中的两个方法都能解决该问题，不过此时不能使用系统提供的堆，必须要自己建立，不过话说回来，明明思路二中的小根堆就可以动态显示结果，即每一次更新某一个字符串的词频之后，就将其拿出来和小根堆的堆顶进行比较不就行了吗，**不不不，其实不行**，主要是，如果更新的词是已经在小根堆中的字符串了，此时就不行，因为我们要对非堆顶的元素进行 Heapify。

<font color = red>**不妨就来重新手动写一下堆好了，这里只用小根堆来实现动态实现。**</font>

``` c plus
// 动态 topK 问题
// 动态添加 string
void TopK_Dynamic_SmallRootHeap::add(const string& str)
{
    node_topK* curNode = NULL;
    // 用于表示当前对应 str 在堆上的位置，默认其不在堆上
    int preIndex = -1;
    if (strNodeMap.find(str) == strNodeMap.end())
    {
        // 如果当前 str 在统计词频的过程中是第一次出现，则进入这个判断
        // 先创建一个新的结点，词频数为 1
        curNode = new node_topK(1, str);
        // 说过了，这个表是真正意义上用于统计所有出现词的表，其可以通过 str 映射到实际结点，从而查询到 str 的词频
        strNodeMap.insert(make_pair(str, curNode));
        // 默认当前词不在堆上，至于其会不会上堆，之后会统一进行处理
        nodeIndexMap.insert(make_pair(curNode, -1));
    }
    else
    {
        // 如果当前 str 在统计词频的过程中已经出现过
        curNode = strNodeMap[str];
        curNode->times++;
        // 同时查询之前这个结点在堆中的位置，因为当前该 str 的词频数会改变，进而影响到其当前位于堆中的位置
        preIndex = nodeIndexMap[curNode];
    }
    // 具体进行堆的处理
    if (preIndex == -1)
    {
        // 如果之前对应 str 不在堆上
        if (heapEndIndex == heap.size())
        {
            // 如果堆已经满了，则需要判断当前 str 的词频增加后能否干掉小根堆的堆顶元素（词频最高的 K 个中的词频最低的那一个）
            if (heap[0]->times < curNode->times)
            {
                // 如果在当前 str 的词频增加之后，可以超过门槛，则修改原本小根堆堆顶结点和当前结点的位置
                // 只需要修改堆的配置
                // ① 原本堆顶元素出堆，需要修改 nodeIndexMap 中的结果
                nodeIndexMap[heap[0]] = -1;
                // ② 修改当前结点的位置为 0，后续的调整在 heapify 中进行
                nodeIndexMap[curNode] = 0;
                // ③ 修改堆顶元素为当前结点
                heap[0] = curNode;
                // ④ 从当前元素位置开始 heapify
                heapify(0);
            }
        }
        else
        {
            // 如果堆没有满，则直接把结点插入到最后一个位置然后 heapInsert 即可
            nodeIndexMap[curNode] = heapEndIndex;
            heap[heapEndIndex] = curNode;
            heapInsert(heapEndIndex++);
        }
    }
    else
        // 说明当前 str 在当次词频增加之前就已经在堆中了，则当词频增加之后，其只可能向下 heapify
        heapify(preIndex);
}
// 向下沉的 heapify 操作
void TopK_Dynamic_SmallRootHeap::heapify(const int& index)
{
    int curIndex = index;
    // 计算左右孩子的索引
    int leftSonIndex = curIndex * 2 + 1;
    int rightSonIndex = curIndex * 2 + 2;
    // 其实个人感觉，不初始化反倒容易看出问题，或者初始化为一个怪异的数字比较好
    int smallestIndex = curIndex;
    while (leftSonIndex < heapEndIndex)
    {
        // 先看其左孩子是不是比它小
        smallestIndex = heap[smallestIndex]->times > heap[leftSonIndex]->times ? leftSonIndex : smallestIndex;
        // 再看，在有右孩子的情况下，其右孩子是不是比它小
        smallestIndex = (rightSonIndex < heapEndIndex) && (heap[smallestIndex]->times > heap[rightSonIndex]->times)\
            ? rightSonIndex : smallestIndex;
        // 然后再看对应的最小 index 是不是 cur，如果是，则不需要继续 heapify，直接 break，否则交换位置并继续 heapify
        if (smallestIndex == curIndex)
            break;
        else
        {
            swap(smallestIndex, curIndex);
            curIndex = smallestIndex;
            // 更新左右孩子的 index
            leftSonIndex = curIndex * 2 + 1;
            rightSonIndex = curIndex * 2 + 2;
        }
    }
}
// 向上升的 heap insert 操作
void TopK_Dynamic_SmallRootHeap::heapInsert(const int& index)
{
    int curIndex = index;
    while (curIndex != 0)
    {
        int fatherIndex = (curIndex - 1) / 2;
        if (heap[curIndex]->times < heap[fatherIndex]->times)
        {
            // 如果当前结点的词频比父亲小，则将两者调换位置
            swap(curIndex, fatherIndex);
            // 更新 curIndex
            curIndex = fatherIndex;
        }
        else
            // 说明已经更新到位，则直接 break 掉即可
            break;
    }
}
// 调换两个堆中 index 位置元素的位置
void TopK_Dynamic_SmallRootHeap::swap(const int& index1, const int& index2)
{
    auto tmp = heap[index1];
    heap[index1] = heap[index2];
    heap[index2] = tmp;
    // 调整 nodeIndexMap 中元素的位置
    // 现在 heap[index1] 元素其实是原本的 heap[index2] 元素，将其在 map 中的 index 改为 index1
    nodeIndexMap[heap[index1]] = index1;
    // 现在 heap[index2] 元素其实是原本的 heap[index1] 元素，将其在 map 中的 index 改为 index2
    nodeIndexMap[heap[index2]] = index2;
}
// 输出 topK 元素
vector<node_topK*> TopK_Dynamic_SmallRootHeap::getTopK(const int& K)
{
    vector<node_topK*> result(K, NULL);
    // 直接反向复制就完事，完事个屁，里面不是按顺序的
    copy(heap.rbegin(), heap.rend(), result.begin());
    // 还需要重新排序
    sort(result.begin(), result.end(), comparator_node_topK_greater());
    return result;
}
void TopK_Dynamic_SmallRootHeap::showHeap()
{
    for (auto it = heap.begin(); it != heap.end(); it++)
    {
        cout << (*it) << ", " << (*it)->str << ", " << (*it)->times << endl;
    }
}

void main()
{
	vector<string> oriStrs{ 
		"James", "Curry", "Durant", "Kevin", "Lebron", 
		"Jordan", "Kobe", "Harden", "Anthony", "Davis",
		"Billy", "Rarondo", "Jacky", "Jay", "Taylor",
	};
	vector<string> strs;
	int oriStrsSize = oriStrs.size();
	// 所有词出现的总数
	int strsSize = 10000;
	// 目标 K
	int K = 8;
	// 创建一个自写的小根堆，用于解决动态 topK 问题
	TopK_Dynamic_SmallRootHeap topK_dynamic_heap(K);
	for (int i = 0; i < strsSize; i++)
	{
		int choice = RandInt(0, oriStrsSize - 1, 1);
		strs.push_back(oriStrs[choice]);
		// 动态加入结果
		topK_dynamic_heap.add(strs[i]);
		if ((i + 1) % 1000 == 0)
		{
			cout << "// ========== The " << i + 1 << " words dynamic adding result is: ========== //" << endl;
			auto result_bigRootHeap = topK_static_bigRootHeap(strs, K);
			cout << "// ===== The top K result by static big root heap: ===== //" << endl;
			for (int i = 0; i < result_bigRootHeap.size(); i++)
				cout << "The number " << i + 1 << "th highest frequency string is: " << result_bigRootHeap[i].str\
				<< ", the whole time is: " << result_bigRootHeap[i].times << endl;

			auto result_dynamic_smallRootHeap = topK_dynamic_heap.getTopK(K);
			cout << "// ===== The top K result by dynamic small root heap: ===== //" << endl;
			for (int i = 0; i < result_dynamic_smallRootHeap.size(); i++)
				cout << "The number " << i + 1 << "th highest frequency string is: " << result_dynamic_smallRootHeap[i]->str\
				<< ", the whole time is: " << result_dynamic_smallRootHeap[i]->times << endl;
			cout << endl;
		}
	}
	system("pause");
}
```

## 4.13 猫狗队列问题

**[题目]** 实现一种狗猫队列的结构，要求如下：

用户可以调用 add 方法将 cat 类或 dog 类的实例放入队列中；

用户可以调用 poIIAII 方法，将队列中所有的实例按照进队列的先后顺序依次弹出；

用户可以调用 pollDog 方法，将队列中 dog 类的实例按照进队列的先后顺序依次弹出；

用户可以调用 pollCat 方法，将队列中 cat 类的实例按照进队列的先后顺序依次弹出；

用户可以调用 isEmpty 方法，检查队列中是否还有 dog 或 cat 的实例；

用户可以调用 isDogEmpty 方法，检查队列中是否有 dog 类的实例；

用户可以调用 isCatEmpty 方法，检查队列中是否有 cat 类的实例。

要求以上所有方法时间复杂度都是 $O(1)$ 的

**解题思路：**非常简单的一道题，思路是给 cat 和 dog 数据结构分配一个 count，表示其进队的时机，并且在我们的目标猫狗队列中，创建两个队列分别存储猫和狗，然后要 pollAll 的时候，只需要判断 cat 和 dog 的队首元素的进队时机谁更早，则弹出谁即可。

**代码：**

``` c plus
// 这个代码太简单了没必要粘进来，直接去项目里面看
// 猫狗队列
class DogCatQueue
{
public:
    // 猫狗入队
    void push(const Pet& pet);
    // 从总体队列中推出最早入队的元素，无论猫狗
    Pet pop_either();
    Pet pop_dog();
    Pet pop_cat();
    // 判断队列是否为空
    bool isEmpty_either() const;
    bool isEmpty_dog() const;
    bool isEmpty_cat() const;
    Pet front_either() const;
    Pet front_dog() const;
    Pet front_cat() const;
private:
    queue<PetEnterQueue> dogQueue;
    queue<PetEnterQueue> catQueue;
    int queSize = 0;
};
```

## 4.14 栈的额外操作

**[题目]** 实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。

**要求：**

1. pop、push、getMin 操作的时间复杂度都是 $O(1)$；

2. 设计的栈类型可以使用现成的栈结构。

**解题思路：**用一个大小和当前栈同步的辅助栈，用于在压栈过程中同步存储栈中的最小元素，如果当前压入的元素比辅助栈栈顶元素小，则压入当前元素，否则直接再次压入栈顶元素即可。

**代码：**

``` c plus
// 最小值栈
int mStack::getMinimum() const
{
    if (data_stk.empty())
        throw string("The stack is empty!");
    return support_stk.top();
}
bool mStack::isEmpty() const
{
    return data_stk.empty();
}
int mStack::pop()
{
    if (isEmpty())
        throw string("The stack is empty!");
    int result = data_stk.top();
    // 两个栈要同步删除元素
    data_stk.pop();
    support_stk.pop();
    return result;
}
void mStack::push(const int& data)
{
    data_stk.push(data);
    if (support_stk.empty())
        support_stk.push(data);
    else
        support_stk.push(data < support_stk.top() ? data : support_stk.top());
}
void main()
{
    auto randVector = RandVector(20, 100, 20, 0);
    randVector.push_back(10);
    cout << "The original vector is: " << endl;
    ShowVector(randVector);
    mStack stk;
    for (int i = 0; i < randVector.size(); i++)
    {
        stk.push(randVector[i]);
        cout << "The current minimum element is: " << stk.getMinimum() << endl;
    }
    system("pause");
}
```

## 4.15 栈和列的转换

**[题目]** 如何仅用栈结构实现队列结构？如何仅用队列结构实现栈结构？

**解题思路：**

1. 栈实现队列，用两个栈，一个是原始数据存储栈，一个是倒数据用的辅助栈，遵循两个原则：

   1）辅助栈中有数据的时候不能往里面倒数据栈的信息；

   2）如果要向辅助栈中倒数据，一次性需要把数据栈中的所有数据都倒入辅助栈。

   这样做的原因在于保证辅助栈中维护的始终是入栈有序的顺序关系。需要明确的是，**辅助栈的栈顶应该维护的是最先入栈的元素**。那么如果在辅助栈有数据的时候往里面倒数据，此时辅助栈顶的元素肯定不是最早入栈的元素，有序关系被破坏；规则2）同理。

2. 队列实现栈，用两个队列，这两个队列就不分主次了，每当要弹出数据，将一个队列中的除了队尾的元素全部依次入队到另一个队列，然后弹出最后一个元素即可。而访问栈顶元素即先找出不空的那个队列，然后返回其最后入队的元素即可。

**代码——栈实现队列：**

``` c plus
// === 栈与队列的转化 === //
// 问题一. 栈转换为队列
int QueueFromStack::pop()
{
    if (data_stk.empty() && support_stk.empty())
        throw string("The stack is empty!");
    transform();
    int result = support_stk.top();
    support_stk.pop();
    return result;
}
void QueueFromStack::push(const int& data)
{
    transform();
    data_stk.push(data);
}
int QueueFromStack::front() const
{
    if (data_stk.empty() && support_stk.empty())
        throw string("The stack is empty!");
    return support_stk.top();
}
bool QueueFromStack::isEmpty() const
{
    return data_stk.empty() && support_stk.empty();
}
// 倒数据操作
void QueueFromStack::transform()
{
    if(support_stk.empty())
        // 在辅助栈为空的情况下才进行倒数据操作，并且要将当前数据栈中的所有元素全部倒进去
        while (!data_stk.empty())
        {
            int data = data_stk.top();
            data_stk.pop();
            support_stk.push(data);
        }
}
void main()
{
	auto randVector = RandVector(20, 100, 20, 0);
	queue<int> que;
	QueueFromStack queFromStack;
	for (int i = 0; i < randVector.size(); i++)
	{
		que.push(randVector[i]);
		queFromStack.push(randVector[i]);
	}
	while (!queFromStack.isEmpty())
	{
		cout << "System queue: " << que.front()<<", ";
		que.pop();
		cout << "Own queue: " << queFromStack.pop() << endl;
	}
	system("pause");
}
```

**代码——队列实现栈：**

``` c plus
// 问题二. 队列转换为栈
void StackFromQueue::push(const int& data)
{
    if (isEmpty())
        // 都空往 1 里面放
        queue1.push(data);
    else if (queue1.empty())
        // 1 空 2 不空往 2 里面放
        queue2.push(data);
    else
        // 2 空 1 不空往 1 里面放
        queue1.push(data);
}
int StackFromQueue::pop()
{
    if (isEmpty())
        throw string("The stack is empty!");
    int result;
    if (queue1.empty())
    {
        // 1 空 2 不空
        while (queue2.size() > 1)
        {
            int data = queue2.front();
            queue1.push(data);
            queue2.pop();
        }
        // 最后一个元素用于返回
        result = queue2.front();
        queue2.pop();
    }
    else
    {
        // 2 空 1 不空
        while (queue1.size() > 1)
        {
            int data = queue1.front();
            queue2.push(data);
            queue1.pop();
        }
        result = queue1.front();
        queue1.pop();
    }
    return result;
}
int StackFromQueue::top() const
{
    if (isEmpty())
        throw string("The stack is empty!");
    int result;
    if (queue1.empty())
        // 1 空 2 不空
        return queue2.back();
    else
        // 2 空 1 不空
        return queue1.back();
}
bool StackFromQueue::isEmpty() const
{
    return queue1.empty() && queue2.empty();
}
void main()
{
	auto randVector = RandVector(20, 100, 20, 0);
	stack<int> stk;
	StackFromQueue stackFromQueue;
	for (int i = 0; i < randVector.size(); i++)
	{
		stk.push(randVector[i]);
		stackFromQueue.push(randVector[i]);
	}
	while (!stackFromQueue.isEmpty())
	{
		cout << "System queue: " << stk.top()<<", ";
		stk.pop();
		cout << "Own queue: " << stackFromQueue.pop() << endl;
	}
	system("pause");
}
```

## 4.16 容器装水问题

**[题目]** 给定一个数组 arr，已知其中所有的值都是非负的，将这个数组看作一个容器请返回容器能装多少水。

比如，arr = [3, 1, 2, 5, 2, 4]，根据值画出的直方图就是容器形状，该容器可以装下 5 格水；再比如arr=[4，5，1，3，2]，该容器可以装下 2 格水**（是假如从天而降一堆水，掉进这个直方图里面，问能装多少水）**。

**解题思路：**思路真的巨简单，只需要把注意点在每一个位置上，而非去关注这个直方图的形状，那么明显的，每一个位置 i 能够承载的水量为**（即 i 位置左最大和右最大中的小者，并且和当前 i 位置的值比较）：**
$$
volume = max\{min\{max\{arr[0\sim (i-1)]\},max\{arr[(i+1) \sim rbegin]\}\} - arr[i]，0 \}
$$
**另外，**还有一个要求是把空间复杂度控制在 $O(1)$，则这一节还需要继续优化。这个真的太牛皮了，简直难以理解最开始是怎么想到的，即左边给一个边界，右边也给一个边界，两边边界向中间收缩，因为对左边边界的右边那个数来说，相当于其左边已经完成遍历，而对右边边界的左边那个数来说，相当于其右边已经完成遍历，而此时记录的左边最大和右边最大必然有一个大小关系，如果左边界记录的最大值大，则右边界左边那个数必然只能达到其右边界最大值的高度，反之同理，且两边边界记录最大值相同时，可以任意移动左边或右边边界。

**代码：**

``` c plus
// 容器装水问题
int maxWater(const vector<int>& arr)
{
    // 先排除一些必然不行的情况
    if (arr.size() < 3)
    {
        return 0;
    }
    // 第一个元素表示边界的位置，第二个元素表示遍历到边界的左右侧最大值
    int leftBound = 1;
    int leftMax = arr[0];
    int rightBound = arr.size() - 1;
    int rightMax = *arr.rbegin();
    int result = 0;
    // 因为左右两边必然不能装水，则不需要遍历
    while (leftBound <= rightBound)
    {
        // 这里 leftBound 可以和 rightBound 取成一样，因为边界踩着的元素是需要计算的元素，所以两者相等时踩着最后一个需要记录的元素
        if (leftMax >= rightMax)
        {
            // 说明此时的瓶颈在于右边界，则移动右边界
            result += max(0, rightMax - arr[rightBound]);
            rightMax = max(arr[rightBound], rightMax);
            rightBound--;
        }
        else
        {
            // 说明此时的瓶颈在于左边界，则移动左边界
            result += max(0, leftMax - arr[leftBound]);
            leftMax = max(arr[leftBound], leftMax);
            leftBound++;
        }
    }
    return result;
}
void main()
{
	// 案例1，应该输出 5
	vector<int> arr1{ 3, 1, 2, 5, 2, 4 };
	cout << "The result of the water problem is(Issue 1st): " << maxWater(arr1) << endl;
	// 案例2，应该输出 2
	vector<int> arr2{ 4, 5, 1, 3, 2};
	cout << "The result of the water problem is(Issue 2cd): " << maxWater(arr2) << endl;
	system("pause");
}
```

## 4.17 数组左右分组问题

**[题目]** 给定一个数组 arr 长度为 N，你可以把任意长度大于 0 且小于 N 的前缀作为左部分，剩下的作为右部分。但是每种划分下都有左部分的最大值和右部分的最大值，请返回最大的，左部分最大值减去右部分最大值的绝对值。要求时间复杂度为 $O(N)$。

**解题思路：**找出数组中的最大元素，然后把其划分入左边或者右边，若划分为左边，则右边只留一个数；若划分为右边，则左边只留一个数。拿出这两种情况下的最大值即可。

**代码：**

``` c plus
// === 数组左右划分后的最大值问题 === //
int maxDifferenceInCurArray(const vector<int>& arr)
{
    if (arr.empty())
        return 0;
    int max_inArr = INT_MIN;
    for (int i = 0; i < arr.size(); i++)
        max_inArr = max(max_inArr, arr[i]);
    // 基于划分逻辑，实际上只需要减去左右边上的最小值即可
    return max_inArr - min(*arr.begin(), *arr.rbegin());
}
void main()
{
	vector<int> arr = RandVector(20, 100, 8);
	ShowVector(arr);
	cout << "The max difference of the cur arr is: " << maxDifferenceInCurArray(arr) << endl;
	system("pause");
}
```

## 4.18 旋转词问题

**[题目]** 如果一个字符串为 str，把字符串 str 前面任意的部分挪到后面形成的字符串叫作 str 的旋转词。比如 str = "12345"，str 的旋转词有 "12345"、"23451"、
"34512、"45123" 和 "51234"。给定两个字符串 a 和 b，请判断 a 和 b 是否互为旋转词。

比如：

a="cdab"，b="abcd"，返回 true。

a="1ab2"，b="ab12"，返回 false。

a="2ab1"，b="ab12"，返回 true。

**解题思路：**把目标串复制一遍，然后看另一个串是否是该字符串的子串（KMP算法），如果是，则两者一定互为旋转词。

**代码：**

``` c plus
// === 旋转词问题 === //
bool isRotateWords(const string& str1, const string& str2)
{
    if (str1.size() != str2.size())
        return false;
    string fatherString = str1 + str1;
    return GetSubStringIndex_ModifiedKMP(fatherString, str2) != -1;
}
void main()
{
	// 旋转词问题，案例1，是旋转词
	string word1_group1("abcdefg");
	string word2_group1("cdefgab");
	cout << (isRotateWords(word1_group1, word2_group1) ? "True" : "False") << endl;
	// 旋转词问题，案例2，不是旋转词
	string word1_group2("abcdefg");
	string word2_group2("abdcefg");
	cout << (isRotateWords(word1_group2, word2_group2) ? "True" : "False") << endl;
	system("pause");
}
```

## 4.19 凑 4 问题

**[题目]** 给定一个数组 arr，如果通过调整可以做到 arr 中任意两个相邻的数字相乘是 4 的倍数返回 true；如果不能返回 false。

**解题思路：**以含有 2 的元素个数为准进行分类

1. 如果不含有 2，则当奇数个数为 1 时，需要含有 4 的个数为 1；当奇数个数大于 1 时如 n 时，至少需要 4 的个数为 n - 1；
2. 如果含有 1 个 2，此时 2 的地位和奇数等价，可以转换为情况 1；
3. 如果含有不止 1 个 2，此时 2 可以自己内部消化，然后需要先摆 4，用这个 4 来消化最后一个 2，然后摆奇数，此时至少需要 4 的个数为 n。 

**代码：**

``` c plus
// === 凑 4 问题 === //
bool nearMultiple4Times(const vector<int>& arr)
{
    if (arr.size() < 2)
        // 如果元素个数都不满 2，没有必要统计结果
        return false;
    int oddNumber = 0;
    // 因数不止一个 2，即因数包含 4 的个数
    int _4Number = 0;
    // 因数只有 2 的数的个数
    int _2Number = 0;
    for (int i = 0; i < arr.size(); i++)
    {
        if ((arr[i] & 1) != 0)
            oddNumber++;
        else
        {
            if (arr[i] % 4 == 0)
                _4Number++;
            else
                _2Number++;
        }
    }
    if (_2Number == 0)
        // 没有仅含 2 为因数的数，则此时分奇数的个数为 1 或不为 1
        return oddNumber == 1 ? (_4Number >= 1) : (_4Number >= oddNumber - 1);
    else if (_2Number == 1)
    {
        // 如果仅含 2 为因数的数有 1 个，这个数的地位和奇数相同，则基本可以看作和情况 1 相同。
        int _2plusOdd = _2Number + oddNumber;
        return (_2plusOdd == 1) ? (_4Number >= 1) : (_4Number >= _2plusOdd - 1);
    }
    else
        // 如果仅含 2 为因数的数有不止 1 个，则此时 4 的个数至少应该和奇数个数相同
        return _4Number >= oddNumber;
}
void main()
{
	int index = 1;
	// True
	vector<int> arr1{ 4, 4 };
	cout << index++ << ", " << nearMultiple4Times(arr1) << endl;
	// True
	vector<int> arr2{ 4, 3 };
	cout << index++ << ", " << nearMultiple4Times(arr2) << endl;
	// False
	vector<int> arr3{ 4, 4, 1, 1, 5, 9 };
	cout << index++ << ", " << nearMultiple4Times(arr3) << endl;
	// True
	vector<int> arr4{ 4, 4, 1, 1, 5, 9, 4 };
	cout << index++ << ", " << nearMultiple4Times(arr4) << endl;
	// False
	vector<int> arr5{ 2, 2, 2, 4, 5, 9 };
	cout << index++ << ", " << nearMultiple4Times(arr5) << endl;
	system("pause");
}
```

## 4.20 背包容量问题

**[题目]** 牛牛准备参加学校组织的春游，出发前牛牛准备往背包里装入一些零食，牛牛的背包容量为 W。牛牛家里一共有 n 袋零食，第 i 袋零食体积为 v[i]。

牛牛想知道在总体积不超过背包容量的情况下，他一共有多少种零食放法（总体积为 0 也算一种放法）。

**解题思路：**之前有个问题很类似，是给定 W，要求从数组中选出数字，使得累加和等于给定的 W，这个地方只是还要加入小于的情况。其实因为我们建立了一张 dp 表，所以我们知道所有目标 W 对应的取法数目，则只需要把对应位置上的元素相加即可。

**代码：**

``` c plus
// === 背包体积问题 === //
int bagVolumeProblem(const vector<int>& arr, const int& w)
{
    if (arr.empty() || w <= 0)
        return 0;
    // 直接搞一个动态规划出来，两个参数，一个是当前零食的 index，一个是目标容量 volume
    // 那么明显，base case 为零食的 index 是数组 rbegin 的时候
    int N = arr.size();
    // 这个地方，容量是可能取到 w 的，所以初始化的时候 size 应该初始化为 w + 1
    vector<vector<int>> dp(N, vector<int>(w + 1, 0));
    for (int i = 0; i <= w; i++)
        // 因为只有一个零食了，所以最后目标和零食体积相同的情况初始化为 1（1 种方法），否则为 0 
        dp[N - 1][i] = (arr[N - 1] == i ? 1 : 0);
    // 这里面还有一个地方和之前的问题有所不同，就是在 N - 1 位置零食是否选择上，不选当前零食并使得最终目标为 0 的情况也应当是一种有效的选法
    dp[N - 1][0] = 1;
    // 然后就是递推关系，i 位置的零食可以选也可以不选，这是产生多种选法的原因
    for (int index = N - 2; index >= 0; index--)
        for (int volume = 0; volume <= w; volume++)
            // 那么当前的方法数就是选或者不选当前零食这两种情况下的后续递推
            // 不过值得注意的是 volume - arr[index] < 0 说明装不下当前零食了，则给 0，说明这种方式产生不了任何的有效路径
            dp[index][volume] = dp[index + 1][volume] + ((volume - arr[index] >= 0) ? dp[index + 1][volume - arr[index]] : 0);
    // 然后总结所有目标选法
    int result = 0;
    for (int i = 0; i <= w; i++)
        result += dp[0][i];
    return result;
}
void main()
{
	vector<int> arr = RandVector(20, 50, 20);
	ShowVector(arr);
	int w = 200;
	cout << "The result by myself is: " << bagVolumeProblem(arr, w) << endl;
	cout << "The result standard is: " << bagVolumeProblem_standard(arr, w) << endl;
	system("pause");
}
```

## 4.21 找工作问题

**[题目]** 给定一个工作数组 vector\<Job>，而每个 Job 对象含有两项数据，即工作的难度和工作的报酬，现在再给定一个能力数组 vector\<int>，里面的每一个元素对应于每个人的能力值，要求给每一个人都找到一份能力匹配且报酬最高的工作。

**解题思路：**先给工作数组排序，排序的方式是：能力值升序，能力值相同的部分，按报酬降序，然后对所有能力值相同的部分，只取报酬最高的那一个，因为相同能力，比不可能选择报酬低的工作，然后对于每一个人的能力值，找到第一个比它高的值，然后取它左边那个 Job 即可。

**代码——多个条件的数组排序方法：**

``` c plus
// === 找工作问题 === //
struct Job
{
    // 报酬
    int money;
    // 所需能力值
    int ability;
    Job(const int& money, const int& ability) :money(money), ability(ability) {}
};
class Comparator_Job
{
public:
    bool operator()(const Job& job1, const Job& job2)
    {
        // 我们要按照工作能力值升序，报酬降序进行排序 
        // sort 会按照下面的标准比较数组中任意两个元素，并将所有元素都变得有序
        return job1.ability != job2.ability ? (job1.ability < job2.ability) : (job1.money > job2.money);
    }
};
void main()
{
	vector<Job> jobs;
	for (int i = 0; i < 20; i++)
	{
		int money = RandInt(1, 20, 1);
		int ability = RandInt(1, 20, 1);
		jobs.emplace_back(money, ability);
	}
	sort(jobs.begin(), jobs.end(), Comparator_Job());
	for (int i = 0; i < jobs.size(); i++)
		cout  << "Ability: " << jobs[i].ability << ", money: " << jobs[i].money << endl;
	system("pause");
}
```

**代码——主体：**

``` c plus
// === 找工作问题 === //
vector<int> findBestJob(vector<Job> jobs, const vector<int>& abilities)
{
    // 先按能力值升序，报酬降序排序
    sort(jobs.begin(), jobs.end(), Comparator_Job());
    // key 表示能力值，方便后续直接搜索到能够匹配上人员能力的工作，value 表示报酬
    // 这个表中存放的数据是，报酬随能力值增长而增长的工作（且所有工作都是同能力值工作中报酬最高的工作）
    // 因为高能力值地低报酬的工作绝对没有必要选，所以可以直接淘汰
    map<int, int> mp;
    // 第一个 job 是必然要推入的
    mp.insert(make_pair(jobs[0].ability, jobs[0].money));
    // 用这个 job 来进行判断，当后续的 job 的能力值改变（必然变大），并且报酬增多的情况，才往 mp 中推入数据
    Job preJob = jobs[0];
    for (int i = 0; i < jobs.size(); i++)
    {
        // 遍历所有工作
        if (jobs[i].ability != preJob.ability && jobs[i].money > preJob.money)
        {
            // 更新 preJob 
            preJob = jobs[i];
            mp.insert(make_pair(preJob.ability, preJob.money));
        }
    }
    // 查看一下得到的 mp
    cout << "The jobs in order: " << endl;
    for (auto it = mp.begin(); it != mp.end(); it++)
        cout << "The ability: " << it->first << ", the money: " << it->second << endl;

    vector<int> result;
    // 然后对每一个人员的能力，找出对应的能够匹配的最大能力值的工作即可（因为此时存有的工作报酬必然是随着能力值增长而增长的）
    for (int i = 0; i < abilities.size(); i++)
    {
        // 找出第一个比目标大的结果
        auto it = mp.upper_bound(abilities[i]);
        // 没办法，只能分几种情况
        if (it == mp.begin())
            // 说明此时能力太低，匹配不了任何工作，还挺巧妙的，因为第一个工作必然是能力值最低的工作
            result.push_back(0);
        else if (it == mp.end())
            // 说明此时能力值太高，可以匹配任意工作，则直接返回最后一个工作的报酬
            result.push_back(mp.rbegin()->second);
        else
            // 返回左边工作的报酬，注意是 --it
            result.push_back((--it)->second);
    }
    return result;
}
void main()
{
	// 生成工作
	int jobNumber = 10;
	vector<Job> jobs;
	vector<int> moneys = RandVector(5, 20, jobNumber, 1);
	vector<int> jobAbilities = RandVector(5, 30, jobNumber, 1);
	for (int i = 0; i < 10; i++)
	{
		jobs.emplace_back(moneys[i], jobAbilities[i]);
	}
	cout << "The job conditions: " << endl;
	for (int i = 0; i < jobs.size(); i++)
		cout << "The jobs'ability: " << jobs[i].ability << ", the jobs' money: " << jobs[i].money << endl;
	// 生成人员
	int memberNumber = 10;
	vector<int> abilities = RandVector(1, 20, memberNumber);
	cout << "The member conditions: " << endl;
	for (int i = 0; i < abilities.size(); i++)
		cout<< abilities[i]<<", ";
	cout << endl;
	// 生成最佳工作数组
	cout << endl << "The best job: " << endl;
	ShowVector(findBestJob(jobs, abilities));
	system("pause");
}
```

**输出结果：**

![image-20230509221443781](C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230509221443781.png)

## 4.22 书写问题

**[题目]** 给定一个字符串，如果该字符串符合人们日常书写一个整数的形式，返回 int 类型的这个数；如果不符合或者越界返回 -1 或者报错。

比如有不合法的字符串为 "-"、"-07"、"07"，简而言之：

​		**规则1：**数字之外只有减号；

​		**规则2：**如果有 "-"，开头且一次，且后面的数字不能是 0；

​		**规则3：**如果开头为 0，则后续必然没有字符。

**解题思路：**第一步先判断其是否合法**（按照上面的三条规则，很好实现）**；然后转整数，如果能转，主要是几种边界讨论**（是否会溢出的问题）**，直接看代码。

**代码：**

``` c plus
// === 字符串转换为整型数据问题 === //
// 判断字符串是否符合日常整数的书写
bool isStringValid(const string& str)
{
    if (str[0] != '-' && (str[0] < '0' || str[0]> '9'))
        // 如果字符串的第一个字符不是负号，并且其超过了数字的范围，则是无效字符串
        return false;
    if (str[0] == '-' && (str.size() == 1 || str[1] == '0'))
        // 如果字符串第一个字符是负号，但整个字符串只有这个负号，或者下一个字符是 0 ，则是无效字符串
        return false;
    if (str[0] == '0' && str.size() > 1)
        // 如果第一个字符是 0，但后面还跟了其它字符，则是无效字符串
        return false;
    for (int i = 1; i < str.size(); i++)
        // 如果在除了第一个字符串以外的其它位置有任意一个在 0 ~ 9 范围以外，则是无效字符串
        if (str[i] < '0' || str[i]>'9')
            return false;
    return true;
}
int stringToInteger(const string& str)
{
    if (str.empty())
        throw string("Cannot convert!");
    if(!isStringValid(str))
        // 如果字符串无效
        throw string("Cannot convert!");
    // 判断这个数是正数或是负数
    bool isPositive = str[0] == '-' ? false : true;
    // 两个边界值，用于判断数字转换过程中的溢出
    // 这里用负数是为了保证转换过程中，当接收到最小整数时不溢出
    int minq = INT_MIN / 10;
    int minr = INT_MIN % 10;
    int result = 0;
    int cur = 0;
    // 需要先判断当前是否转的是正数，如果是，则从第一个位置开始转换，否则要忽略负号，从第二个位置开始转换
    for (int i = isPositive ? 0 : 1; i < str.size(); i++)
    {
        // 因为我们想用负数来接收
        cur = '0' - str[i];
        if (result < minq || (result == minq && cur < minr))
            // result < minq 表示的是该次乘 10 之后会直接溢出
            // result == minq && cur < minr 表示的是一种更特殊的边界条件，自己想想，不描述了
            throw string("Cannot convert!");
        // 否则转就完事了
        result = result * 10 + cur;
    }
    // 因为我们用负数来接收，有可能会刚好接收到一个正数，但是转换过程中达到了最小整数值，此时如果把其转成正数会溢出，所以寄
    if (isPositive && result == INT_MIN)
        throw string("Cannot convert!");
    return isPositive ? -result : result;
}
void main()
{
	// 最大整数
	string test1 = "2147483647"; cout << "Test1: ";
	try
	{
		cout << (stringToInteger(test1)) << endl;
	}
	catch (const string& str)
	{
		cout << str << endl;
	}
	// 最小整数
	string test2 = "-2147483648"; cout << "Test2: ";
	try
	{
		cout << (stringToInteger(test2)) << endl;
	}
	catch (const string& str)
	{
		cout << str << endl;
	}
	// 溢出
	string test3 = "2147483648"; cout << "Test3: ";
	try
	{
		cout << (stringToInteger(test3)) << endl;
	}
	catch (const string& str)
	{
		cout << str << endl;
	}
	// 溢出
	string test4 = "-2147483649"; cout << "Test4: ";
	try
	{
		cout << (stringToInteger(test4)) << endl;
	}
	catch (const string& str)
	{
		cout << str << endl;
	}
	// 一般情况
	string test5 = "-123"; cout << "Test5: ";
	try
	{
		cout << (stringToInteger(test5)) << endl;
	}
	catch (const string& str)
	{
		cout << str << endl;
	}
	system("pause");
}
```

## 4.23 打印目录问题

**[问题]** 给你一个字符串类型的数组arr，譬如：vector\<string> arr = { "b\\\\cst", "d\\\\\", "a\\\\d\\\\e", "a\\\\b\\\\c"}；你把这些路径中蕴含的目录结构给画出来，子目录直接列在父目录下面，并比父目录向右进两格，就像这样：

a
	b
		c
	d
		e
b
	cst
d

同一级的需要按字母顺序排列，不能乱。

**解题思路：**前缀树。然后深度有限遍历打印即可，easy。

**代码——注意事项，转义字符"\\"：**

``` c plus
void main()
{
	string str("a\\b\\c");
	// 输出 a\b\c, 5
	cout << str << ", " << str.size() << endl;
    // 测试我们的字符分割算法
	auto charVec = mStringHandler(str).split("\\");
	for (int i = 0; i < charVec.size(); i++)
		// 输出 a, b, c,，正确
		cout << charVec[i] << ", ";
	cout << endl;
	system("pause");
}
```

**代码——主体：**

``` c plus
struct Node
    {
        Node(const string& name) :name(name) {}
        // 当前级目录的名称
        string name;
        // 有序表（目录名称升序）存储后续的目录节点（相当于是图结构）
        map<string, Node*> nextMap;
    };
// === 字符串打印目录问题 === //
namespace GetFolderTree
{
    // 最终调用的函数，folderPaths 表示用 vector 存储的所有字符串，比如 {"a\\james\\c, b\\harden\\h"}
    void print(const vector<string>& folderPaths)
    {
        if (folderPaths.empty())
            return;
        Node* head = generateFolderTree(folderPaths);
        // 传入头结点，其对应的深度是 level
        printProcess(head, 0);
    }
    // 将一个 vector<string> 加入到前缀树中，并返回其头结点
    Node* generateFolderTree(const vector<string>& folderPaths)
    {
        // 头结点存储的字符串为空串
        Node* head = new Node("");
        for (auto& str : folderPaths)
        {
            // 遍历所有字符串，每一个都要添加到前缀树中
            // 首先，把当前的 str，比如 a//b//c，分解为单独的目录名称 a, b, c
            vector<string> paths = mStringHandler(str).split("\\");
            // 对每一个可能产生的目录，都需要从头节点开始遍历
            Node* cur = head;
            for (int i = 0; i < paths.size(); i++)
            {
                if (cur->nextMap.find(paths[i]) == cur->nextMap.end())
                    // 如果当前目录名在 cur 的后续节点中不存在，则需要添加新的前缀树节点
                    cur->nextMap.insert(make_pair(paths[i], new Node(paths[i])));
                // 否则说明当前对应的目录已经在当前级创建过，则直接跳到对应目录上即可
                cur = cur->nextMap[paths[i]];
            }

        }
        return head;
    }
    // 深度有限遍历前缀树，并根据其所在的层数来打印对应的空格数，以表示其对应的目录分级
    void printProcess(Node* head, const int& level)
    {
        if (level != 0)
            // 在非 0 层的情况下，打印对应内容
            cout << get2nSpace(level) << head->name << endl;
        // 然后深度有限遍历前缀树即可
        for (auto& next : head->nextMap)
            printProcess(next.second, level + 1);
    }
    // 输入 n，返回 2n 个空格的字符串
    string get2nSpace(const int& n)
    {
        string result = "";
        for (int i = 0; i < 2 * n; i++)
            result += " ";
        return result;
    }
}

void main()
{
	vector<string> strs =
	{
		"James\\Lebron\\Kevin",
		"Curry\\Stephen\\Durant",
		"James\\Jordan\\Michael",
		"Harden\\James\\Irven\\Kobe",
		"Irven\\James\\Harden\\Kobe",
		"Irven\\James\\Silly\\Boy",
		"Irven\\Tom\\Billy\\Kobe",
	};
	GetFolderTree::print(strs);
	system("pause");
}
```

## 4.24 子数组最大累加和问题

**[题目]** 为了保证招聘信息的质量问题，公司为每个职位设计了打分系统，打分可以为正数，也可以为负数，正数表示用户认可帖子质量，负数表示用户不认可帖子质量：打分的分数根据评价用户的等级大小不定，比如可以为 1 分，10 分，30 分，-10 分等。假设数组 A 记录了一条帖子所有打分记录，现在需要找出帖子曾经得到过最高的分数是多少，用于后续根据最高分数来确认需要对发帖用户做相应的惩罚或奖励：其中，最高分的定义为用户所有打分记录中，连续打分数据之和的最大值即认为是帖子曾经获得的最高分。例如：帖子 10001010 近期的打分记录为 [1，1，-1，-10，11，4，-6，9，20，-10，-2]，那么该条帖子曾经到达过的最高分数为 11 + 4 + (-6) + 9 + 20 = 38。请实现一段代码，输入为帖子近期的打分记录，输出为当前帖子得到的最高分数。

**解题思路：**假设答案法。关键在于把研究单元从一个数字的正负扩张到一个区间范围内的正负，简而言之，如果我们有三段区间，第一段累加和小于 0，第二段累加和大于 0，第三段的累加和小于 0，那么最大累加和必然是中间区间的累加和。那么在实际做的时候，任意时刻，只要当前累加和小于 0，我们就将记录累加和的变量重置为 0，这样可以保证，以任何开头到当前位置的累加和都小于 0，那么如果后续有一段区间的累加和大于 0 且该区间的累加和是我们记录的最大值，那么它一定也是最终的最大值，因为前面（连续）任何区间内的累加和都小于 0。

**代码：**

``` c plus
// === 最大累加和问题 === //
// 问题1. 子数组累加和问题
int subArrayMaxSum(const vector<int>& arr)
{
    if (arr.empty())
        return -1;
    // 记录的最大值
    int result = INT_MIN;
    // 当前遍历位置对应的累加和
    int cur = 0;
    for (int i = 0; i < arr.size(); i++)
    {
        // 对当前遍历位置进行累加
        cur += arr[i];
        // 记录最大累加值
        result = max(result, cur);
        // 如果当前累加和为负，重置，这样可以保证以当前 i 为终点的所有累加和都为负数
        // 那么如果后序连续一段范围内的累加和为最大值，那么其必然不需要以 i 为终点的任何区间范围累加和
        cur = cur < 0 ? 0 : cur;
    }
    return result;
}
void main()
{
	vector<int> arr1{ -2, -3, -5, 40, -10, -10, 100, 1 };
	cout << "The max subArray sum1 is: " << subArrayMaxSum(arr1) << endl;
	vector<int> arr2{ -2, -3, -5, 0, 1, 2, -1 };
	cout << "The max subArray sum1 is: " << subArrayMaxSum(arr2) << endl;
	vector<int> arr3{ -2, -3, -5, -1 };
	cout << "The max subArray sum1 is: " << subArrayMaxSum(arr3) << endl;

	system("pause");
}
```

## 4.25 子矩阵的最大累加和问题

**[题目]** 求一个整型矩阵的子矩阵最大累加和。

**解题思路：**求当且仅当包含 0~0 行范围内的子矩阵最大累加和，求当且仅当包含 0~1 行范围内的子矩阵最大累加和...，求当且仅当包含 0~N-1 行范围内的最大累加和，求当且仅当包含 1~1 行范围内...。最终结果就在其中。

**代码：**

``` c plus
// 问题2. 子矩阵累积和问题
int subMatrixMaxSum(const vector<vector<int>>& mat)
{
    if (mat.empty() || mat.begin()->empty())
        return -1;
    int result = INT_MIN;
    int cur = 0;
    // s 表示的是矩阵一行的数据，所以其应该初始化为列数
    vector<int> s;
    // 第一层循环，表示起始行标
    for (int i = 0; i < mat.size(); i++)
    {
        // 重新初始化一个数组，因为每次改换起头行的时候都要重新计算子矩阵的累加和
        s = vector<int>(mat[i].size(), 0);
        // 第二层循环，表示终止行标
        for (int j = i; j < mat.size(); j++)
        {
            // 在重新统计一个规模子矩阵累加和的时候，将 cur 重置
            // 因为我们不是真的在对矩阵做累加，而是把每一次子矩阵的累加分解为数组累加，所以要完全保证数组的累加计算逻辑成立
            cur = 0;
            for (int k = 0; k < s.size(); k++)
            {
                // 重构对应的数组，同时记录最大累加和
                s[k] += mat[j][k];
                cur += s[k];
                result = max(result, cur);
                cur = cur < 0 ? 0 : cur;
            }
        }
    }
    return result;
}

// 对数器
int subMatrixMaxSum_brutal(const vector<vector<int>>& mat)
{
    if (mat.empty() || mat.begin()->empty())
        return 0;
    int result = INT_MIN;
    // 可以看到，对于暴力法而言，我们需要遍历确定四个边界并求累加，此时的时间复杂度为 O(M^2 * N^2)
    for (int i = 0; i < mat.size(); i++)
        for (int j = i; j < mat.size(); j++)
            for (int k = 0; k < mat[i].size(); k++)
                for (int l = k; l < mat[i].size(); l++)
                    result = max(result, matrixSum(mat, i, j, k, l));
    return result;
}
// 计算一个矩阵某个范围内的累加和
int matrixSum(const vector<vector<int>>& mat, const int& top, const int& bottom, const int& left, const int& right)
{
    int sum = 0;
    for (int i = top; i <= bottom; i++)
        for (int j = left; j <= right; j++)
            sum += mat[i][j];
    return sum;
}
void main()
{
	for (int i = 0; i < 20; i++)
	{
		vector<vector<int>> mat = RandMatrix(-100, 100, 10, 10, 1);
		cout << "The max subMatrix sum is (optimization): " << subMatrixMaxSum(mat)\
		<< ", the max subMatrix sum is (brutal): " << subMatrixMaxSum_brutal(mat) << endl;
	}
	system("pause");
}
```

## 4.26 路灯问题

**[题目]** 比如有一个字符串 “x x x . . . x x x . . . . . . . x x . x . . x x x”，只需要点亮 “.” 表示的位置，而一个路灯 L 可以点亮半径为 1 的领域内的点，问最少需要多少个路灯。

**解题思路：**个人感觉，如果当前位置只有连续的一个点，则把路灯放在这个点上，否则都从第二点开始放，并且隔 2 个点放一个（不够 2 了就放第一个点），这个思路的结果就是：连续点个数 / 3，然后看是否有剩，有剩的话 + 1，完事。然后按左说的，每次必然在第一个位置放灯，然后往后面跳 3 个，这个没啥问题，和我的逻辑相同，主要是第一个点放灯这个做法，逻辑上并不是很完美，但最终结果确实是对的。

**代码：**

``` c plus
// === 路灯问题 === //
// 方法1. 直接数学公式计算
int lightProblem1(const string& str)
{
    int result = 0;
    int continuousPointNumber = 0;
    for (int i = 0; i < str.size(); i++)
        // 如果当前位置是 '.'，则连续点数 ++，否则进行运算操作，并置 continuousPointNumber 为 0
        if (str[i] == '.')
            continuousPointNumber++;
        else
        {
            result += continuousPointNumber / 3 + (continuousPointNumber % 3 == 0 ? 0 : 1);
            continuousPointNumber = 0;
        }
    // 还有最后一个位置的连续数目需要统计，因为如果最后一个位置是 '.'，其不会在 else 中计算，所以要在这个位置增加一步
    result += continuousPointNumber / 3 + (continuousPointNumber % 3 == 0 ? 0 : 1);
    return result;
}

// 方法2. 左方法
int lightProblem2(const string& str)
{
    int result = 0;
    int i = 0;
    while (i < str.size())
        // 为 'X' 直接位置往后移动
        if (str[i] == 'X')
            i++;
        else
        {
            // 说明当前位置是个点，这里说明这种逻辑下，必然会在 X 后面放下一个 L
            result++;
            // 说明在最后一个位置，直接跳出循环
            if (i + 1 == str.size())
                break;
            // 如果下一个位置是 X，则从 X 之后的那一个位置开始检查
            else if (str[i + 1] == 'X')
                i += 2;
            // 如果下一个位置是 .，则从 . 之后再后一个位置开始检查，因为一个 light 可以覆盖其领域半径为 1 的区域
            else
                i += 3;
        }
    return result;
}
void main()
{
	string str1("........X.....X...X.X..X...X.X.X.X.X...XX.X..XX");
	cout << "The result of the light problem(mine): " << lightProblem1(str1) << ", "\
		<< "the result of the light problem(zuo): " << lightProblem2(str1) << endl;
	string str2("X......");
	cout << "The result of the light problem(mine): " << lightProblem1(str2) << ", "\
		<< "the result of the light problem(zuo): " << lightProblem2(str2) << endl;
	string str3("...X");
	cout << "The result of the light problem(mine): " << lightProblem1(str3) << ", "\
		<< "the result of the light problem(zuo): " << lightProblem2(str3) << endl;
	// 随机测试
	int strLength = 1000;
	for (int i = 0; i < 10; i++)
	{
		vector<int> arr = RandVector(0, 1, strLength, 1);
		string str(strLength, ' ');
		for (int j = 0; j < arr.size(); j++)
			str[j] = (arr[j] == 1 ? '.' : 'X');
		cout << "The result of the light problem(mine): " << lightProblem1(str) << ", "\
			<< "the result of the light problem(zuo): " << lightProblem2(str) << endl;
	}
	system("pause");
}
```

## 4.27 有限条件的二叉树后序遍历

**[题目]** 已知二叉树无重复节点，并且给定了该树的中序遍历数组和先序遍历数组，要求返回其对应的后序遍历数组。比如给定

``` c plus
vector<int> pre {1, 2, 4, 5, 3, 6, 7};
vector<int> in {4, 2, 5, 1, 6, 3, 7};
```

返回 {4, 5, 2, 6, 7, 3, 1}。

**解题思路：**用 pre 找出一棵树的根，然后在中序中用 pre 找到的根划分左右子树，然后递归填写，很妙。还值得注意的一点是，不管是什么样的遍历， 一棵子树遍历出来的节点一定是在连续的某一坨范围内，而不会因为遍历方式不同而被分开，并且中序遍历和后序遍历左**子树**分布的位置是相同的**（按块来看，虽然一块区域内的内容可能顺序不同）**。

**代码：**

``` c plus
// === 根据前、中序遍历结果确定二叉树后序遍历结果 === //
vector<int> getPostTransversal(const vector<int>& preTransversal, const vector<int>& inTransversal)
{
    if (preTransversal.empty() || inTransversal.empty() || preTransversal.size() != inTransversal.size())
        return vector<int>();
    int N = preTransversal.size();
    vector<int> result(N, 0);
    // 这个哈希表用于存储，对应前序遍历的 某个位置 的结果在中序遍历的 哪个位置
    unordered_map<int, int> hash;
    for (int i = 0; i < preTransversal.size(); i++)
        hash.insert(make_pair(
            // 表示前序遍历中某个位置 i
            i, 
            // 表示 i 位置对应元素在中序遍历中的位置
            find(inTransversal.begin(), inTransversal.end(), preTransversal[i])- inTransversal.begin()
        ));	
    setPos(
        // 前序遍历结果
        preTransversal, 0, N - 1,
        // 中序遍历结果
        inTransversal, 0, N - 1,
        // 后序遍历结果
        result, 0, N - 1,
        hash);
    return result;
}
// Note: pos -> position not equal to post
// 以前序数组 [prei, prej] 范围的元素和中序数组 [ini, inj] 范围的元素来确定后序数组 [posti, postj] 范围的元素
void setPos(const vector<int>& preTransversal, const int& prei, const int& prej,
    const vector<int>& inTransversal, const int& ini, const int& inj,
    vector<int>& postTranversal, const int& posti, const int& postj,
    unordered_map<int, int>& hash)
{
    // 这个地方必须要处理越界的情况，可以这样去看，在逻辑上已经没有问题
    // 但由于左右子树 leftNodeNumber 和 rightNodeNumber 都可能为 0
    // 那么在传参过程中，明显可能出现左边界大于右边界的情况，这是因为我们在某些边界取值的时候，直接 -1 或者 +1 了
    // 而是不是越界，只需要判断某一种遍历即可，因为大家的位置都是对应的，逻辑上是互通的
    if (prei > prej)
        return;
    if (prei == prej)
    {
        // 如果切分出来的子树只有一个元素，意味着此时的树只有一个节点，则任意遍历方式的结果相同
        postTranversal[posti] = preTransversal[prei];
        return;
    }	
    // 根可以直接设置，即子树的前序遍历第一个元素就是后序遍历的最后一个元素
    postTranversal[postj] = preTransversal[prei];
    // 找出前序遍历 prei 位置上的元素，在中序遍历中的位置
    // 因为当前子树中，prei 我位置上的元素必然是根，然后在中序遍历中我们就能知道对应于当前子树的左子树和右子树
    int inOrderPos = hash[prei];
    // 为了代码的可读性，我们可以在这里用中序遍历的结果计算当前子树的左右子树的节点个数
    int leftNodeNumber = inOrderPos - ini;
    int rightNodeNumber = inj - inOrderPos;
    // 左子树递归
    setPos(
        preTransversal, prei + 1, prei + leftNodeNumber,
        inTransversal, inOrderPos - leftNodeNumber, inOrderPos - 1,
        postTranversal, posti, posti + leftNodeNumber - 1,
        hash
        );
    // 右子树递归
    setPos(
        preTransversal, prej - rightNodeNumber + 1, prej,
        inTransversal, inOrderPos + 1, inOrderPos + rightNodeNumber,
        postTranversal, postj - rightNodeNumber, postj - 1,
        hash
    );
}

void main()
{
	// 一般情况
	vector<int> pre1{ 1, 2, 4, 5, 3, 6, 7 };
	vector<int> in1{ 4, 2, 5, 1, 6, 3, 7 };
	vector<int> post1 = getPostTransversal(pre1, in1);
	ShowVector(post1);
	// 特殊情况1，没有右子树
	vector<int> pre2{ 1, 2, 3, 4, 5, 6, 7 };
	vector<int> in2{ 7, 6, 5, 4, 3, 2, 1 };
	vector<int> post2 = getPostTransversal(pre2, in2);
	ShowVector(post2);
	// 特殊情况2，没有左子树
	vector<int> pre3{ 1, 2, 3, 4, 5, 6, 7 };
	vector<int> in3{ 1, 2, 3, 4, 5, 6, 7 };
	vector<int> post3 = getPostTransversal(pre3, in3);
	ShowVector(post3);
	system("pause");
}
```

## 4.28 数字变为英文或中文表述

**[题目]** 顾名思义，是一个纯业务问题，按情况分析即可，没有什么特殊的。

**代码——转英文表述：**

``` c plus
namespace EnglishExpression
{
    // 将 1~19 范围内的数字转换为英文
    string num1To19(const int& num)
    {
        if (num < 1 || num>19)
            return "";
        // 在这个范围内的数字直接当作 base case 返回结果
        vector<string> engExpressions{
            "One ", "Two ", "Three ", "Four ", "Five ", "Six ", "Seven ", "Eight ",
            "Nine ", "Ten ", "Eleven ", "Twelve ", "Thirteen ", "Fourteen ", "Fifteen ",
            "Sixteen ", "Seventeen ", "Eighteen ", "Nineteen"
        };
        return engExpressions[num - 1];
    }
    // 将 1~99 范围内的数字转换为英文
    string num1To99(const int& num)
    {
        if (num < 1 || num>99)
            return "";
        if (num < 20)
            return num1To19(num);
        // 说明必然在 20 以上
        int high = num / 10;
        vector<string> tyNames{
            "Twenty ", "Thirty ", "Fourty ", "Fifty ", "Sixty ", "Seventy ", "Eighty ", "Ninety "
        };
        // 通过十位和个位的组合来返回结果
        return tyNames[high - 2] + num1To19(num % 10);
    }
    // 将 1~999 范围内的数字转换为英文
    string num1To999(const int& num)
    {
        if (num < 1 || num>999)
            return "";
        if (num < 100)
            return num1To99(num);
        int high = num / 100;
        // 通过百位和十位的组合来返回结果
        return num1To19(high) + "Hundred " + num1To99(num % 100);
    }
    // 最终转换
    string numToEnglishExpression(const int& num)
    {
        int tmp = num;
        if (num == 0)
            return "Zero";
        string result = "";
        if (num < 0)
            result = "Negative, ";
        // 因为转换过程中是把所有数转换为正数
        // 所以对于最小整型数，需要单独处理
        if (num == INT_MIN)
        {
            result += "Two Billion, ";
            // 模运算结果的符号仅取决于被模数
            tmp %= -2000000000;
        }
        tmp = abs(tmp);
        // 从最高位开始看
        int high = 1000000000;
        // 当前最高位的 index，主要是为了正确索引十亿、百万和千
        int highIndex = 0;
        vector<string> names{ "Billion", "Million", "Thousand", "" };
        while (tmp != 0)
        {
            int cur = tmp / high;
            tmp %= high;
            // 以三位数作为操作单元，如果本身只是一个三位数，则在 highIndex 为 3 的时候才会进入下面的循环
            // 并且值得注意的是，最终 tmp 一定会模 1，那么此时模的结果必然为 0
            if (cur != 0)
            {
                result += num1To999(cur);
                result += names[highIndex] + (tmp == 0 ? " " : ", ");
            }
            high /= 1000;
            highIndex++;
        }
        return result;
    }
}

void main()
{
	cout << EnglishExpression::numToEnglishExpression(19) << endl;
	cout << EnglishExpression::numToEnglishExpression(20) << endl;
	cout << EnglishExpression::numToEnglishExpression(21) << endl;
	cout << INT_MAX << ", ";
	cout << EnglishExpression::numToEnglishExpression(INT_MAX) << endl;
	cout << INT_MIN << ", ";
	cout << EnglishExpression::numToEnglishExpression(INT_MIN) << endl;
	system("pause");
}
```

**代码——转中文：**

``` c plus
// 问题2. 转中文表达
namespace ChineseExpression
{
    // 将 1~19 范围内的数字转换为中文
    string num1To9(const int& num)
    {
        if (num < 1 || num > 9)
            return "";
        vector<string> names{
            "一", "二", "三", "四", "五", "六", "七", "八", "九"
        };
        return names[num - 1];
    }
    // 将 1~99 范围内的数字转换为中文
    string num1To99(const int& num, const bool& hasBai)
    {
        if (num < 1 || num>99)
            return "";
        if (num < 10)
            return num1To9(num);
        int shi = num / 10;
        if (shi == 1 && (!hasBai))
            return "十" + num1To9(num % 10);
        else
            return num1To9(shi) + "十" + num1To9(num % 10);
    }
    // 将 1~999 范围内的数字转换为中文
    string num1To999(const int& num)
    {
        if (num < 1 || num>999)
            return "";
        if (num < 100)
            return num1To99(num, false);
        string result = num1To9(num / 100) + "百";
        int rest = num % 100;
        if (rest == 0)
            return result;
        else if (rest >= 10)
            result += num1To99(rest, true);
        else
            result += ("零" + num1To9(rest));
        return result;
    }
    // 将 1~9999 范围内的数字转换为中文，因为中文是以万为循环
    string num1To9999(const int& num)
    {
        if (num < 1 || num > 9999)
            return "";
        if (num < 1000)
            return num1To999(num);
        string result = num1To9(num / 1000) + "千";
        int rest = num % 1000;
        if (rest == 0)
            return result;
        else if (rest >= 100)
            result += num1To999(rest);
        else
            // 此时是没有十位的
            result += ("零" + num1To99(rest, false));
        return result;
    }
    // 将 1~99999999 范围内的数字转换为中文
    string num1To99999999(const int& num)
    {
        if (num < 1 || num > 99999999)
            return "";
        int wan = num / 10000;
        int rest = num % 10000;
        if (wan == 0)
            return num1To9999(num);
        string result = num1To9999(wan) + "万";
        if (rest == 0)
            return result;
        else
        {
            // 完全按语言习惯来的，可以稍微想一想
            if (rest < 1000)
                result += ("零" + num1To999(rest));
            else
                result += num1To9999(rest);
        }
        return result;
    }
    // 最终转换
    string numToChineseExpression(const int& num)
    {
        if (num == 0)
            return "零";
        string result = num < 0 ? "负" : "";
        // 除完模完之后再取绝对值，不会溢出
        int yi = abs(num / 100000000);
        int rest = abs(num % 100000000);
        if (yi == 0)
            return result + num1To99999999(rest);
        result += num1To9999(yi) + "亿";
        if (rest == 0)
            return result;
        else
        {
            if (rest < 10000000)
                result += "零" + num1To99999999(rest);
            else
                result += num1To99999999(rest);
        }
        return result;
    }
}
void main()
{
	cout << ChineseExpression::numToChineseExpression(20) << endl;
	cout << ChineseExpression::numToChineseExpression(233) << endl;
	cout << ChineseExpression::num1To9999(1001) << endl;
	cout << ChineseExpression::numToChineseExpression(19999999) << endl;
	cout << INT_MAX << ", ";
	cout << ChineseExpression::numToChineseExpression(INT_MAX) << endl;
	cout << INT_MIN << ", ";
	cout << ChineseExpression::numToChineseExpression(INT_MIN) << endl;
	system("pause");
}
```

## 4.29 求完全二叉树节点的个数

**[题目]** 顾名思义。

**解题思路：**不就是看最后一层有多少个节点吗，是这个思想，但实现起来有技巧。递归去看当前子树的右子树的最左节点是不是在最深的那一层，如果是，那么当前子树的左子树一定是满二叉树（深度 - 1）；而如果当前子树的右子树的最左节点不在最深的那一层，那么此时的右子树一定是满二叉树（深度 - 2）。

**代码：**

``` c plus
// === 快速求解完全二叉树节点问题 === //
int CBTNodeNumber(Solutions::TNode* head)
{
    if (head == NULL)
        return 0;
    // 总数的头节点深度看作是 1
    return bs(head, 1, mostLeftLevel(head, 1));
}
// h 表示当前树的总深度，不变，l 表示对应子树的深度
int bs(Solutions::TNode* head, const int& l, const int& h)
{
    // 说明当前处在最后一层，因为是完全二叉树，可以确定当前节点是叶子节点，则直接返回 1
    if (l == h)
        return 1;
    if (mostLeftLevel(head->right, l + 1) == h)
        // 如果当前树的右子树的最左节点在最深的一层，则说明当前树的左子树肯定是满二叉树
        // -1 是因为满二叉树的计算公式，+1 是加上当前的根
        return (1 << (h - l)) - 1 + 1 + bs(head->right, l + 1, h);
    else
        // 说明当前树的右子树的最左节点不在最深的一层，则说明当前树的右子树肯定是满二叉树
        return (1 << (h - l - 1)) - 1 + 1 + bs(head->left, l + 1, h);
}
// 计算以 head 为头（head 的深度已知为 level）的树的深度
int mostLeftLevel(Solutions::TNode* head, const int& level)
{
    int result = level;
    // 这里确实不能直接用 head->left != NULL，因为有可能传入的 head 就是一个空的节点，此时刚好，返回的 result 还会比给定的 level 小 1
    // 这更是符合逻辑的
    while (head!= NULL)
    {
        result++;
        head = head->left;
    }
    return result - 1;
}
void main()
{
	auto head = ConstructCBT();
	cout << "The node number of the complete binary tree is: " << CBTNodeNumber(head) << endl;
	system("pause");
}
```

## 4.30 最长递增子序列问题 	

**[题目]** 只需要注意，子序列不要求所有元素在原数组中完全连续。

**解题思路——经典方法：**思路很标准，找以每个位置 i 结尾的子序列中递增子序列的最长长度，时间复杂度明显是 $O(N^2)$ 。

``` c plus
// === 最长递增子序列问题 === //
// 方法1. 普通动态规划
int biggestIncreasingSubSequence_DP(const vector<int>& arr)
{
    if (arr.empty())
        return 0;
    vector<int> dp(arr.size(), 0);
    // 第一个位置的最长递增子序列只包含它自己，所以置为 1
    dp[0] = 1;
    int result = 0;
    for (int i = 1; i < arr.size(); i++)
    {
        int maxDpNumber = 0;
        // 遍历找到 i 位置之前比它小的数，找到它们之中的最大递增子序列数即可
        for (int j = 0; j < i; j++)
            if (arr[j] < arr[i])
                maxDpNumber = max(maxDpNumber, dp[j]);
        // 值得注意的是，如果之前所有数都比当前的数大，则上述循环不会改变 maxDpNumber 的初始化值，则结果依然是正确的
        dp[i] = maxDpNumber + 1;
        // 记录计算得到的最大结果
        result = max(result, dp[i]);
    }
    return result;
}
```

**解题思路——优化方法：**给一个 ends 数组，i 位置的元素表示原数组中长度为 i + 1 的递增子序列中的最小结尾值，并且 ends 在更新数据之后是必然有序的**（可以不严格递增）**，这个可以通过反证法来证明。那么在后续遍历原数组的过程中，对于当前的遍历元素 a，应当从 ends 中找出第一个比它大的数的对应位置 h，用 a 来对它进行更新，因为往前看，前面的数都比它小，它无法更新，后面的数它够不着，而能够更新当前位置的原因就在于，在这个位置之前，长度为 h 的递增子序列中，一定有一个子序列的结尾数比它小，所以把它拿进来一定可以形成一个长度为 h + 1 的子序列（而这也是需要不断更新所有 ends 数组元素的原因），当然，如果当前数 a 比 ends 中的任何数都大，说明能够形成的递增子序列的长度扩张，则 ends 数组的有效位数也可以扩张。

``` c plus
// 方法2. 优化方案
int biggestIncreasingSubSequence_OP(const vector<int>& arr)
{
    if (arr.empty())
        return 0;
    // 刚好，用一个不初始化长度的 vector，可以用于表示哪些位是有效的
    vector<int> ends;
    for (int i = 0; i < arr.size(); i++)
    {
        if (ends.empty() || arr[i] > *ends.rbegin())
            // 仔细思考一下，只有当原本的 ends 为空或者当前 arr[i] 比 ends 的最后一个元素还大的时候，才需要推入新的元素
            ends.push_back(arr[i]);
        // 一定能在数组中找到一个比当前数字大的数字，因为在上一步判断中，已经确定 arr[i] 不会比 ends 中的最后一个元素大
        // 所以这一步找到第一个比当前数字大的数，用当前数更新它
        // 而优化的点就在于，ends 数组是一个升序数组，所以采用二分查找，可以使得每一步的查找复杂度变为 logN
        int pos = BinSearch_ForFirstBiggerValue(ends, arr[i]);
        ends[pos] = arr[i];
    }
    // ends 数组的长度就是最终的结果
    return ends.size();
}
void main()
{
	for (int i = 0; i < 10; i++)
	{
		cout << "// ============= " << i << " ============= //" << endl;
		vector<int> arr = RandVector_NoRepeat(1, 200, 100, 1);
		cout << "The DP Method: " << biggestIncreasingSubSequence_DP(arr) << endl;
		cout << "The OP Method: " << biggestIncreasingSubSequence_OP(arr) << endl;
	}
	system("pause");
}
```

## 4.31 被 3 整除问题

**[题目]** 小Q得到一个神奇的数列：1, 12, 123，..., 12345678910, 1234567891011...。

并且小Q对于能否被 3 整除这个性质很感兴趣。小Q现在希望你能帮他计算一下从**数列的**第 l 个到第 r 个（包含端点）有多少个数可以被 3 整除。

**输入描述：**输入包括两个整数 I 和 r（1<=I<= r<= 1e9），表示要求解的区间两端。

**输出描述：**输出一个整数，表示区间内能被 3 整除的数字个数。

**解题思路：**其实第 i 个数就是 1 2 3 4 5 6 7 8 9 10 11... i，那么实际上只需要看，把这些所有数加起来能不能模 3 余 0 即可。因为可以证明
$$
abcd \ \%\ 3 = (a+b+c+d)\ \%\ 3
$$

``` c plus
// === 被 3 整除的序列数问题 === //
// 计算神奇数列 l 到 r 项中有几个数可以被 3 整除
int getIfDividedBy3(const int& l, const int& r)
{
    int sum = 0;
    for (int i = l; i <= r; i++)
    {
        // 主要还有一个是，这个神奇数列表示的数字实际上特别大，所以用 long 来接收数据
        long long tmp = (long long)(i + 1LL) * i / 2LL;
        if (tmp % 3LL == 0)
            sum++;
    }
    return sum;
}
// 暴力法
int getIfDividedBy3_brutal(const int& l, const int& r)
{
    int sum = 0;
    for (int i = l; i <= r; i++)
        sum = constructSingleNumber(i) % 3 == 0 ? sum + 1 : sum;
    return sum;
}
long long constructSingleNumber(const int& l)
{
    if (l == 0)
        return 0;
    string str;
    for (int i = 0; i < l; i++)
        str += to_string(i + 1);
    return fromString<long long>(str);
}

void main()
{
	cout << "The result by optimization method is: " << getIfDividedBy3(0, 14);
	cout << ", the result by brutal method is: " << getIfDividedBy3_brutal(0, 14)<<endl;
	int64_t a = 3;
	long b = 3;
	int c = 5; 
	// 注意，long long 表示的才是长整型，一个 long 等价于 int
	cout << sizeof(2LL) << ", " << sizeof(a) << ", " << sizeof(b)<<", "<<sizeof(c) << endl;
	system("pause");
}
```

## 4.32 有限空间统计未出现数字问题

**[题目]** 给定一个整数数组 A，长度为 n，有 1 <= A[i] <= n，且对于 [1, n] 的整数，其中部分整数会重复出现而部分不会出现。实现算法找到 [1, n] 中所有未出现在 A 中的整数。

**提示：**尝试实现 $O(n)$ 的时间复杂度和 $O(1)$ 的空间复杂度**（返回值不计入空间复杂度）**。

**输入描述：**一行数字，全部为整数，空格分隔 A0, A1, A2, A3...

**输出描述：**一行数字，全部为整数，空格分隔 R0, R1, R2, R3...

**示例1：**

**输入：**1 3 4 3，**输出：**2。

**解题思路：**力争在数组的 i 位置上放数字 i + 1，那么在进行完操作之后，i 位置上放的不是 i + 1 数字的情况下，数字 i + 1 就是不存在的。

**代码——典型错误：**

``` c plus
void main1(vector<int>& arr)
{
    if (arr.empty())
        return;
    for (int i = 0; i < arr.size(); i++)
        // 只需要遍历一遍的原因在于：只需要遍历一遍就可以把数组原本的所有数放到对应的位置上
        modify1(i, arr);
    for (int i = 0; i < arr.size(); i++)
        if (arr[i] != i + 1)
            // 打印对应位置不正确的结果
            cout << i + 1 << ", ";
    cout << endl;
}
void modify1(int pos, vector<int>& arr)
{
    while (arr[pos] != pos + 1)
    {
        int temp = arr[arr[pos] - 1];
        arr[arr[pos] - 1] = arr[pos];
        // 由于这个记录的是位置而不是数字信息，所以没有办法对刚刚取出来的数字进行判断，失去了循环性
        // 也就是 pos 的含义改变了，原本输入的 pos 代表的是要判断 pos 位置的数据是否符合要求
        // 但更新一次之后的 pos 含义变成了当前数字应该去的 pos 位置
        pos = temp - 1;
    }
}
```

**正确代码：**值得注意的是，最终总能跳出循环的原因在于，数组最终会变得完全有序，所以当数组的最后一个位置变得有序之后，其压出来的数字要回到它对应的位置上的时候，那个位置上本来放的就是已经有序的数字。

``` c plus
// === 有限空间统计未出现数字问题 === //
namespace printNumberNotInArray
{
    // 方法二. 数值驱动
    void main(vector<int>& arr)
    {
        if (arr.empty())
            return;
        for (auto& value : arr)
            modify(value, arr);
        for (int i = 0; i < arr.size(); i++)
            if (arr[i] != i + 1)
                // 打印对应位置不正确的结果
                cout << i + 1 << ", ";
        cout << endl;
    }
    void modify(int value, vector<int>& arr)
    {
        while (value != arr[value - 1])
        {
            int temp = arr[value - 1];
            arr[value - 1] = value;
            value = temp;
        }
    }
}
void main()
{
	vector<int> arr = RandVector(1, 10, 10, 1);
	ShowVector(arr);
	printNumberNotInArray::main(arr);
	system("pause");
}
```

## 4.33 最大收益问题

**[题目]** CC 直播的运营部门组织了很多运营活动，每个活动需要花费一定的时间参与，主播每参加完一个活动即可得到一定的奖励，参与活动可以从任意活动开始，但一旦开始，就需要将后续活动参加完毕（注意：最后一个活动必须参与），活动之间存在一定的依赖关系（不存在环的情况），现在给出所有的活动时间与依赖关系，以及给出有限的时间，请帮主播计算在有限的时候内，能获得的最天奖励，以及需要的最少时长。

<img src="C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230524102831303.png" alt="image-20230524102831303" style="zoom:80%;" />

如上图数据所示，给定有限时间为10天。可以获取得最大奖励为：11700，需要的时长为：9天。参加的活动为 B D F H 四个。

**输入描述：**

第一行输入数据 N 与 D，表示有 N 项活动，D 表示给予的时长。0 < N <= 1000，0 < D <= 10000。

从第二行开始到 N + 1 行，每行描述一个活动的信息，其中第一项表示当前活动需要花费的时间 t，第二项表示可以获得的奖励 a，之后有 N 项数据，表示当前活动与其他活动的依赖关系，1 表示有依赖，0 表示无依赖。每项数据用空格分开。

**输出描述：**
输出两项数据 A 与 T，用空格分割。A 表示所获得的最大奖励，T 表示所需要的时长。

**输入：**
$$
8 \ 10 \\
3 \ 2000 \ 0 \ 1 \ 1 \ 0 \ 0 \ 0 \ 0 \ 0 \\
3 \ 4000 \ 0 \ 0 \ 0 \ 1 \ 1 \ 0 \ 0 \ 0 \\
2 \ 2500 \ 0 \ 0 \ 0 \ 1 \ 0 \ 0 \ 0 \ 0 \\
1 \ 1600 \ 0 \ 0 \ 0 \ 0 \ 1 \ 1 \ 1 \ 0 \\
4 \ 3800 \ 0 \ 0 \ 0 \ 0 \ 0 \ 0 \ 0 \ 1 \\
2 \ 2600 \ 0 \ 0 \ 0 \ 0 \ 0 \ 0 \ 0 \ 1 \\
4 \ 4000 \ 0 \ 0 \ 0 \ 0 \ 0 \ 0 \ 0 \ 1 \\
3 \ 3500 \ 0 \ 0 \ 0 \ 0 \ 0 \ 0 \ 0 \ 0 \\
$$
**输出：**11700 9

**解题思路：**从最后一个节点开始往前推，每一个事件节点先对应有一张独立的有序表，其存储了按照时间升序**（总的时间，即从最后的事件到当前事件一共需要的时间）**，然后把这些表中，时间上升，但奖励未上升的路径剔除，最终再合出一张大表，这张表中就存储了所有路径中可能出现的最好情况。

**代码：**

``` c plus
// === 最大收益问题 === //
map<int, int>::iterator floorKey(map<int, int>& mp, const int& dest)
{
    if (mp.empty())
        return mp.end();
    auto it = mp.upper_bound(dest);
    if (it == mp.begin() && it->first != mp.begin()->first)
        // 表示没有 floorKey，或者说当前的 key 比 arr 中的所有元素都小
        it == mp.end();
    else
        // 就算 i 比所有元素都大，也可以正确输出
        it--;
    return it;
}
// allTime 表示给定的总时间
// revenue 表示对应各个事件的收益
// times 表示对应各个事件消耗的时间
// dependents 表示各个事件之间的依赖关系
vector<int> maxRevenue(const int& allTime, const vector<int>& revenue, const vector<int>& times,
    const vector<vector<int>>& dependents)
{
    int size = revenue.size();
    // 首先建立各个节点之间的父子关系，每个节点可能有多个父亲
    // 而为了生成各个节点独立的表，我们需要遍历一个节点的所有父亲
    unordered_map<int, list<int>> parents;
    int end = -1;
    for (int i = 0; i < dependents.size(); i++)
    {
        // dependents 明显是一个方阵
        bool allZero = true;
        for (int j = 0; j < dependents[i].size(); j++)
            if (dependents[i][j] != 0)
            {
                // i 表示当前的 父 是第 i 个事件，那么该行中的不为 1 的元素代表对应 j 位置事件是它的 子
                parents[j].push_back(i);
                allZero = true;
            }
        if (allZero)
            // 没有子表示当前的节点是最后一个节点
            end = i;
    }
    // 建立各个节点的收益有序表
    unordered_map<int, map<int, int>> nodeCostRevenueMap;
    // 首先初始化最后一个节点的耗时和收益，这个节点的表只有一个元素
    nodeCostRevenueMap[end].insert(make_pair(times[end], revenue[end]));
    queue<int>que;
    // 然后通过宽度优先遍历来从 子 节点找到 父 节点，并给所有节点设置对应的收益有序表
    // 个人感觉深度优先遍历同样适用，而且不会产生重复操作
    que.push(end);
    while (!que.empty())
    {
        // 通过宽度优先遍历，取出当前要使用的元素
        int cur = que.front();
        que.pop();
        for (auto& last : parents[cur])
        {
            // 遍历当前 cur 节点的所有父亲
            for (auto it = nodeCostRevenueMap[cur].begin(); it != nodeCostRevenueMap[cur].end(); it++)
            {
                // 遍历当前 cur 节点的有序表，其中的所有结果都要放到父亲 last 的表中
                // 通过当前 cur 节点的有序表计算其到达各个 父亲 所需的时间以及收益
                int lastCost = it->first + times[last];
                int lastRevenue = it->second + revenue[last];
                // 拿到我们现在正在设置的父节点的表
                map<int, int>& lastMap = nodeCostRevenueMap[last];
                // 找 floorKey 方法，找出消耗时间小于等于当前路径消耗时间的方案，如果没有，则返回 end
                auto itt = floorKey(lastMap, lastCost);
                // 值得注意的是，这里的 itt->second 或者 lastMap[itt->first] 是同一个意思
                if (itt == lastMap.end() || itt->second < lastRevenue)
                    // 如果当前路径造成的结果，要么是它所消耗的时间比其它所有路径结果都小
                    // 要么是它所消耗的时间比其它路径大于或者等于，但它所能得到的报酬也更加高的情况，才修改父亲的表
                    // 这个地方，对于消耗时间相同的情况也可以正常处理
                    // 值得注意的是，宽度优先遍历会导致一些路径方案被反复操作，虽然不会出错，个人感觉深度优先遍历反倒更好
                    lastMap[lastCost] = lastRevenue;
            }
            // 将 子 的 父 推入到队列中，继续进行宽度优先遍历
            que.push(last);
        }	
    }
    map<int, int> allMap;
    // 原本的各个有序表是分立的，用一张哈希表存储，此时遍历这张哈希表，把所有有序表进行合并
    for (auto curMap = nodeCostRevenueMap.begin(); curMap != nodeCostRevenueMap.end(); curMap++)
        // 遍历哈希表
        for (auto entry = curMap->second.begin(); entry != curMap->second.end(); entry++)
        {
            // 遍历当前有序表，将结果往大表里面送
            // 找到大表中，对应元素的 floorKey
            auto floorIte = floorKey(allMap, entry->first);
            if (floorIte == allMap.end() || allMap[floorIte->first] < entry->second)
                allMap[entry->first] = entry->second;
        }
    // 从最终的有序表中，找出给定时间 allTime 能够执行的最大路径，此时对应的结果就是最大收益方案
    auto resultIte = floorKey(allMap, allTime);
    return vector<int>{resultIte->first, resultIte->second};
}
void main()
{
	int allTime = 10;
	vector<int> revenue{ 2000, 4000, 2500, 1600, 3800, 2600, 4000, 3500 };
	vector<int> times{ 3, 3, 2, 1, 4, 2, 4, 3 };
	vector<vector<int>>dependents {
			{ 0, 1, 1, 0, 0, 0, 0, 0 },
			{ 0, 0, 0, 1, 1, 0, 0, 0 },
			{ 0, 0, 0, 1, 0, 0, 0, 0 },
			{ 0, 0, 0, 0, 1, 1, 1, 0 },
			{ 0, 0, 0, 0, 0, 0, 0, 1 },
			{ 0, 0, 0, 0, 0, 0, 0, 1 },
			{ 0, 0, 0, 0, 0, 0, 0, 1 },
			{ 0, 0, 0, 0, 0, 0, 0, 0 } };
	auto res = maxRevenue(allTime, revenue, times, dependents);
	cout << "The best choice's time cost is: " << res[0] << ", the corresponding revenue is: " << res[1] << endl;
	system("pause");
}
```

## 4.34 逻辑组合问题

**[题目]** 给定一个只由0（假）、1（真）、&（逻辑与）、|（逻辑或）和 ^（异或）五种字符组成的字符串 express，再给定一个布尔值 desired。返回 express 能有多少种组合方式，可以达到 desired 的结果。

**[举例]** express= " 1 ^ 0 | 0 | 1 "，desired = false，其中只有 1 ^ (( 0 | 0 ) | 1) 和 1 ^ (0 | (0 | 1)) 的组合可以得到 false，返回 2。express = "1", desired = false
无组合可以得到 false，返回 0。

**解题思路：**其实就是在原来的逻辑运算符之间加小括号，对每一个逻辑运算符（不包括 0 和 1），其必须对应有左右小括号。

**代码——暴力递归：**

``` c plus
// 表示当前输入的字符串是否是合理的
bool isValid(const string& exp)
{
    if (!(exp.size() & 1))
        // 如果给出的字符串是偶数，则肯定无效
        return false;
    // 检查偶数位置上是不是数字
    for (int i = 0; i < exp.size(); i += 2)
        if ((exp[i] != '1') && (exp[i] != '0'))
            return false;
    // 检查奇数位置上是不是逻辑符号
    for (int i = 1; i < exp.size(); i += 2)
        if ((exp[i] != '&') && (exp[i] != '|') && (exp[i] != '^'))
            return false;
    return true;
}
// 暴力递归方法
// desired 表示我们想要的结果是 true 还是 false
int num_RC(const string& exp, const bool& desired)
{
    if (exp.empty() || !isValid(exp))
        return 0;
    // 初始返回的范围是 0 ~ exp.size() - 1
    return p(exp, desired, 0, exp.size() - 1);
}
// L 和 R 表示当前是在 L ~ R 范围内对逻辑符号进行组合
int p(const string& exp, const bool& desired, const int& L, const int& R)
{
    // base case
    if (L == R)
        if (exp[L] == '1')
            // 如果该位置是 1，而且目标也是 1，则返回 1
            return desired ? 1 : 0;
        else
            // 如果该位置是 0，但目标是 1，则返回 0
            return desired ? 0 : 1;
    int result = 0;
    if (desired)
    {
        // 对于目标为真的情况
        for (int i = L + 1; i < R; i += 2)
        {
            // 遍历所有符号（所以从 L + 1 开始，每次跳 2 个位置）
            // 这里其实相当于是尝试把每个逻辑运算符当作最外层的逻辑运算符
            switch (exp[i])
            {
            case '&':
            {
                // 目标为真，且逻辑符号为与，那么自然左右都需要是真
                result += p(exp, true, L, i - 1) * p(exp, true, i + 1, R);
                break;
            }
            case '|':
            {
                // 目标为真，且逻辑符号为并，那么左右一个真就行
                result += p(exp, true, L, i - 1) * p(exp, true, i + 1, R);
                result += p(exp, false, L, i - 1) * p(exp, true, i + 1, R);
                result += p(exp, true, L, i - 1) * p(exp, false, i + 1, R);
                break;
            }
            case '^':
            {
                // 目标为真，且逻辑符号为异或，那么左右一真一假即可
                result += p(exp, true, L, i - 1) * p(exp, false, i + 1, R);
                result += p(exp, false, L, i - 1) * p(exp, true, i + 1, R);
                break;
            }
            }
        }
    }
    else
    {
        // 对于目标为假的情况
        for (int i = L + 1; i < R; i += 2)
        {
            // 遍历所有符号（所以从 L + 1 开始，每次跳 2 个位置）
            // 这里其实相当于是尝试把每个逻辑运算符当作最外层的逻辑运算符
            switch (exp[i])
            {
            case '&':
            {
                // 目标为假，且逻辑符号为与，左右一假即可
                result += p(exp, false, L, i - 1) * p(exp, true, i + 1, R);
                result += p(exp, true, L, i - 1) * p(exp, false, i + 1, R);
                result += p(exp, false, L, i - 1) * p(exp, false, i + 1, R);
                break;
            }
            case '|':
            {
                // 目标为假，且逻辑符号为并，左右双假即可
                result += p(exp, false, L, i - 1) * p(exp, false, i + 1, R);
                break;
            }
            case '^':
            {
                // 目标为假，且逻辑符号为异或，左右同真同假
                result += p(exp, true, L, i - 1) * p(exp, true, i + 1, R);
                result += p(exp, false, L, i - 1) * p(exp, false, i + 1, R);
                break;
            }
            }
        }
    }
    return result;
}
```

**代码——动态规划：**

``` c plus
// 动态规划方法
int num_DP(const string& exp, const bool& desired)
{
    if (exp.empty() || !isValid(exp))
        return 0;
    // 首先先要想清楚 dp 的含义，对该问题而言，dp[i][j] 表示当前 exp 从 i ~ j 范围上可以形成 desired 逻辑的方法数
    // 所以要注意 i 和 j 的范围，其必然踩在偶数位置上
    // 还值得注意的是，需要用两张表来处理结果，在运算过程中，两者互有耦合
    vector<vector<int>> tr(exp.size(), vector<int>(exp.size(), 0));
    vector<vector<int>> fa(exp.size(), vector<int>(exp.size(), 0));
    // base case
    // 1. 能够想到的限制是若 i >= j，则结果必然为 0，则最终的表应该是一个上三角矩阵
    // 2. 对角线元素可以首先给出来
    for (int i = 0; i < tr.size(); i += 2)
    {
        // true 表就代表 desired 为 1，false 表反之
        tr[i][i] = exp[i] == '1' ? 1 : 0;
        fa[i][i] = exp[i] == '1' ? 0 : 1;
    }
    // 递推关系
    // dp[i][j] 表示范围 i ~ j，自然其依赖于 dp[i][signIndex - 1] 以及 dp[signIndex + 1][j]
    // 其中 signIndex 从 i + 1 以 2 为间隔 跳到 j - 1
    // 即各个元素依赖于其正左边以及其正下方的元素，所以更新的时候，按照列增大，行减小的方向更新
    // 值得注意的是，i 和 j 也要以 2 递增，表示范围的起止都踩在数字上而不是踩在逻辑运算符上
    for (int j = 2; j < tr.size(); j += 2)
        for (int i = j - 2; i >= 0; i -= 2)
            for (int signIndex = i + 1; signIndex < j; signIndex += 2)
            {
                if (exp[signIndex] == '&')
                {
                    tr[i][j] += tr[i][signIndex - 1] * tr[signIndex + 1][j];
                    fa[i][j] += fa[i][signIndex - 1] * tr[signIndex + 1][j];
                    fa[i][j] += tr[i][signIndex - 1] * fa[signIndex + 1][j];
                    fa[i][j] += fa[i][signIndex - 1] * fa[signIndex + 1][j];
                }
                else if (exp[signIndex] == '|')
                {
                    tr[i][j] += tr[i][signIndex - 1] * fa[signIndex + 1][j];
                    tr[i][j] += fa[i][signIndex - 1] * tr[signIndex + 1][j];
                    tr[i][j] += tr[i][signIndex - 1] * tr[signIndex + 1][j];
                    fa[i][j] += fa[i][signIndex - 1] * fa[signIndex + 1][j];
                }
                else
                {
                    tr[i][j] += tr[i][signIndex - 1] * fa[signIndex + 1][j];
                    tr[i][j] += fa[i][signIndex - 1] * tr[signIndex + 1][j];
                    fa[i][j] += fa[i][signIndex - 1] * fa[signIndex + 1][j];
                    fa[i][j] += tr[i][signIndex - 1] * tr[signIndex + 1][j];
                }
            }
    return desired ? tr[0][tr.size() - 1] : fa[0][fa.size() - 1];
}
void main()
{
	string expression("1^0|0|1&1^0|1^0");
	cout << "The desired is true: ";
	cout << ExpressionNumber::num_RC(expression, 1) << ", ";
	cout << ExpressionNumber::num_DP(expression, 1) << endl;
	cout << "The desired is false: ";
	cout << ExpressionNumber::num_RC(expression, 0) << ", ";
	cout << ExpressionNumber::num_DP(expression, 0) << endl;
	system("pause");
}
```

## 4.35 找最长无重复子串

**[题目]** 在一个字符串中找到没有重复字符子串中最长的长度。

**例如：**
abcabcbb，没有重复字符的最长子串是 abc，长度为 3
bbbbb，答案是 b，长度为 1
pwwkew，答案是 wke，长度是 3

**要求：**答案必须是子串，"pwke” 是一个子字符序列但不是一个子字符串。

**解题思路：**这种类型的问题优先考虑以每一个位置作为字符串结尾的情况下，对应的最长无重复字符的子串长度。那么逻辑便是，后序的位置只需要看前一个位置的最长无重复字符串的长度是多少，然后从该位置往前数（在上一个位置的无重复子串范围内），数到有重复的位置为止，记录长度即可**（实际上用一张表来记录每一个字母上一次出现的位置即可）**。

**值得注意的是，对于这种只可能依赖于上一个位置字符的问题，可以只用一个单变量来记录上一个位置的对应数据。**

``` c plus
// === 最长无重复子串问题 === //
int findLongestSubString(const string& str)
{
    if (str.empty())
        return 0;
    // 用于表示字符上一次出现的位置，因为 ASCLL 码的取值范围是 0 ~ 255，所以准备一个 256 长度的整型数组即可
    vector<int> lastLocation(256, -1);
    // 初始化第一个位置
    lastLocation[str[0]] = 0;
    int totalLongest = 1;
    int curLongest = 1;
    // 然后从 i = 1 位置开始看
    for (int i = 1; i < str.size(); i++)
    {
        // 取出两种范围（上一个位置的最长长度以及上一次字符重复）的小值
        curLongest = min(curLongest + 1, i-lastLocation[str[i]]);
        totalLongest = max(curLongest, totalLongest);
        // 最后更新位置数组，不能提前更新
        lastLocation[str[i]] = i;
    }
    return totalLongest;
}
void main()
{
	cout << findLongestSubString("abcabcbb") << endl;
	cout << findLongestSubString("bbbbb") << endl;
	cout << findLongestSubString("pwwkew") << endl;
	cout << findLongestSubString("ccyxdoqqpwii") << endl;
	system("pause");
}
```

## 4.36 编辑字符串问题

**[题目]** 给定两个字符串 str1 和 str2，再给定三个整数 ic、dc 和 rc，分别代表插入、删除和替换一个字符的代价，返回将 str1 编辑成 str2 的最小代价。

**[举例]** str1 = "abc"，str2 = "adc"，ic = 5，dc = 3，rc = 2，从"abc" 编辑成 "adc"，把 'b' 替换成 'd' 是代价最小的，所以返回 2。
str1 = "abc"，str2 = "adc"，ic = 5，dc = 3，rc = 100 从 "abc" 编辑成 "adc"，先删除 'b'，然后插入 'd' 是代价最小的，所以返回 8。
str1 = "abc"，str2 = "abc"，ic = 5，dc = 3，rc = 2 不用编辑了，本来就是一样的字符串，所以返回 0。

**解题思路：**主要还是在于表 dp 元素的实际含义，此处的 dp\[i][j] 表示将字符串 str1[0 ~ (i-1)] 编辑为 str2[0 ~ (j-1)] 的最小代价。在解题过程中，默认在每一步中，
遵循从左向右使得两个字符串变得逐渐相同的逻辑可以得到最小代价，在这个假设（未证明）的前提下，这个其实就是一个基本的动态规划问题，考虑递推的关系即可。

**代码：**

``` c plus
// === 编辑字符串问题 === //
namespace EditCost
{
    int minCost(const string& str1, const string& str2, const int& insertCost, const int& deleteCost, const int& replaceCost)
    {
        // 还是要先分析 dp 的含义，dp[i][j] 表示从 str1 的 0 ~ (i - 1) 前缀变为 str2 的 0 ~ (j - 1) 前缀所需的最小代价
        // 所以最后位置要到 size()
        int rowNumber = str1.size() + 1;
        int colNumber = str2.size() + 1;
        // 所有位置初始化为 0
        vector<vector<int>> dp(rowNumber, vector<int>(colNumber, 0));
        // base case
        // 计算从空（0 ~ (0 - 1) 位置）到单字符(0 ~ (1 - 1))的代价，以及单字符到空的代价
        for (int i = 1; i < rowNumber; i++)
            // 第 0 列表示从不同长度减为空
            dp[i][0] = i * deleteCost;
        for (int j = 1; j < colNumber; j++)
            // 第 0 行表示从空增长到不同的长度
            dp[0][j] = j * insertCost;
        // 递推关系，主要讨论形成 dp[i][j] 的可能性，因为我们只考虑了前缀依次变化的情况（大概大家都等价）
        // 原理不明白，但基本逻辑可以想清楚，也就是说在 str1[0 ~ (i - 2)] 和 str2[0 ~ (j - 2)] 已经相等的情况下，想把
        // str1[i - 1] 位置变成 str2[j - 1] 的方法，那么有 3 种情况
        // 1. 情况1，把 str1[i - 1] 位置的字符删除，然后把 str1[0 ~ (i - 2)] 变为 str2[0 ~ (j - 1)]，对应代价为 dp[i - 1]dp[j] + deleteCost
        // 2. 情况2，把 str1[0 ~ (i - 1)] 变为 str2[0 ~ j - 2]，然后插入 str[j - 1]，对应代价为 dp[i][j - 1] + insertCost
        // 3. 情况3，直接将 str1[i - 1] 替换为 str2[j - 1]，当然，如果两者该位置上的字符相同，则无需额外代价，最低代价必然为 dp[i - 1][j - 1]
        // 否则对应代价为 dp[i - 1][j - 1] + replaceCost
        for (int i = 1; i < rowNumber; i++)
            for (int j = 1; j < colNumber; j++)
                if (str1[i - 1] == str2[j - 1])
                    dp[i][j] = dp[i - 1][j - 1];
                else
                    dp[i][j] = min(dp[i - 1][j] + deleteCost,
                        min(dp[i][j - 1] + insertCost, 
                            dp[i - 1][j - 1] + replaceCost));
        // rowNumber 和 colNumber 等于原字符串长 + 1 
        return dp[rowNumber - 1][colNumber - 1];
    }
}
void main()
{
	// 案例1，abc -> adc
	cout << EditCost::minCost("abc", "adc", 5, 3, 2) << endl;
	// 案例2，abc -> adc
	cout << EditCost::minCost("abc", "adc", 5, 3, 100) << endl;
	// 案例3，abc -> adc
	cout << EditCost::minCost("abc", "abc", 5, 3, 2) << endl;
	system("pause");
}
```



## 4.37 最小字典序无重复子串问题

**[题目]** 给定一个全是小写字母的字符串 str，删除多余字符，使得每种字符只保留一个，并让最终结果字符串的字典序最小。

**[举例]** str = "acbc"，删掉第一个 'c'，得到 "abc"，是所有结果字符串中字典序最小的。str = "dbcacbca"，删掉第一个 'b'、第一个 'c'、第二个 'c'、第二个 'a'，得到 "dabc" 是所有结果字符串中字典序最小的。

**解题思路：**贪心算法，给定一个哈希表，用于记录各个字符的总出现次数，并在遍历原字符串的过程中，给当前出现字符的对应次数 --，表示剩余的该字符还有多少个；当某个字符的出现次数变为 0 的时候，就从 0 ~ 该位置中选出 ASCLL 码最小的结果，并从原字符串中，剔除所有该字符，而下一次执行该过程，就从刚刚找出的那个字符位置（字符出现次数变为 0）开始。只需要注意为什么当字符出现次数变为 0 的时候我们要暂停扫描，因为在扫描区域内的所有字符中，仅有 ASCLL 码最小的那个字符会被保留，而如果一个字符它在后续字符串中已经没有了，而它又不是当前范围内的 ASCLL 码最小的字符，那么该字符将不在最终结果中出现，所以和原题义相悖。

**代码：**

``` c plus
namespace RemoveDuplicaetedLetters
{
    // === 字典序最小无重复子串问题 === //
    // 递归写法
    string method1(const string& str)
    {
        if (str.size() < 2)
            return str;
        // 用于统计各个字符的出现词频
        vector<int> mp(256, 0);
        // 先遍历整个数组，统计字符的出现词频
        for (int i = 0; i < str.size(); i++)
            mp[str[i]]++;
        int minASCLLIndex = 0;
        // 然后找出某个字符第一次词频降为 0 的位置
        // 同时统计在遍历过程中，找到的最小 ASCLL 码 index
        // 值得注意的是，如果在某个字符的词频将为 0 了，此时直接跳出循环，而不会在本次处理中考虑将当前字符给挑出来
        for (int i = 0; i < str.size(); i++)
        {
            // 每一步都应该看当前位置是不是最小 ASCLL 码值
            minASCLLIndex = str[minASCLLIndex] > str[i] ? i : minASCLLIndex;
            // 然后再判断词频并选择是否跳出
            if (--mp[str[i]] == 0)
                break;
        }
        string midString = mStringHandler(str).subString(minASCLLIndex + 1);
        string lastString = mStringHandler(midString).replaceAll(str[minASCLLIndex], "");
        return str[minASCLLIndex] + method1(lastString);
    }
}
void main()
{
	for (int j = 0; j < 10000; j++)
	{
		string str3("");
		for (int i = 0; i < 10; i++)
		{
			str3.push_back(RandInt('a', 'z', 1));
		}
		cout << "Method1: " << RemoveDuplicaetedLetters::method1(str3) << endl;
	}
	system("pause");
}
```

## 4.38 字符串有序编码问题

**[题目]** 在数据加密和数据压缩中常需要对特殊的字符串进行编码。给定的字母表 A 由 26 个小写英文字母组成，即 A = {a, b, ..., z}。该字母表产生的长序字符串是指定字符串中字母从左到右出现的次序与字母在字母表中出现的次序相同，且每个字符最多出现 1 次。例如，a，b，ab，bc，xyz 等字符串是升序字符串。对字母表 A 产生的所有长度不超过 6 的升序字符串按照字典排列编码如下：a(1)，b(2)，c(3)，...，z(26)，ab(27)，ac(28)...... 对于任意长度不超过 16 的升序字符串，迅速计算出它在上述字典中的编码。

**输入描述：**第 1 行是一个正整数 N，表示接下来共有 N 行，在接下来的 N 行中，每行给出一个字符串。输出描述，输出 N 行，每行对应于一个字符串编码。

**示例：**输入 3，a，b，ab，输出 1，2，27。

**解题思路：**首先，要做出一个 f(len) 函数，用于计算长度为 len 的合法子序列有多少个。然后需要一个 g(char, len) 函数，表示长度为 len，以 char 开头的子序列有多少个。对 g 函数，通过递归函数可以简单实现，对一个 char 开头的序列，长度为 len 的序列种类为第二个字符从 (char + 1) ~ z 开头，长度为 len - 1的序列的综合数。而对 f 函数，其实就是调用 g(a ~ z, len) 即可。 

``` c plus
// 给定子序列长度 length，计算对应有效子序列的总数量
int f(const int& length)
{
    if (length <= 0)
        return 0;
    int result = 0;
    for (int i = 0; i < 26; i++)
        result += g(i, length);
    return result;
}

// 给定子序列起始字符 i 和长度 length，计算对应有效子序列的总数量
int g(const int& i, const int& length)
{
    if (length <= 0)
        return 0;
    // 如果目标序列长度为 1，则对应长度以 i 开头的子序列种类只有一种
    if (length == 1)
        return 1;
    int result = 0;
    // 'a' 是 0，所以最后要循环到 26，其表示 'z'
    // 因为题目要求序列升序，所以必须从 i + 1 开始
    for (int j = i + 1; j < 26; j++)
        result += g(j, length - 1);
    return result;
}

// 给定子序列，返回其对应的序号
int Kth(const string& s)
{
    if (s.empty())
        return 0;
    int result = 0;
    // 先按照序列数量计算
    for (int i = 1; i < s.size(); i++)
        result += f(i);
    // 然后按照各个字符位置进行计算 比如 b s v
    // 先计算首位 b 能压住 长 3 序列 个数为 g('a', 3);
    // 然后计算第二位 s 能压住的 长 2 序列 个数为 g('c', 2) + g('d', 2) + ... + g('r', 2)
    // 最后计算第三位 u 能压住的 长 1 序列 个数为 g('t', 1) + g('u', 1)
    // 所以明显是有两层循环，外层的循环次数明显是字符串的长度
    int lastLetter = 0;
    for (int i = 0; i < s.size(); i++)
    {
        int newLetter = s[i] - 'a';
        // 内层的循环从 i 位置的 字母 + 1 开始，到 i + 1 位置的 字母 - 1 结束
        for (int j = lastLetter; j < newLetter; j++)
            result += g(j, s.size() - i);
        lastLetter = newLetter + 1;
    }
    // 最终结果是前面被压住序列的数目 + 1
    return result + 1;
}
void main()
{
	cout << StringToKth::Kth("abcdefglmn") << endl;
	cout << StringToKth::Kth_standard("abcdefglmn") << endl;
	system("pause");
}
```



# 5. 动态规划

## 5.1 二叉树种类问题

**[题目] **给定一个非负整数 N，代表二叉树的节点个数。返回能形成多少种不同的二叉树结构。

**解题思路：**明显的，对于 N 个结点的树，其总共能够形成的树的种类即左树 i 个结点的子树种类 + 右树 N - i - 1 个结点的子树种类（头结点占一个），其中 i 从 0 变化到 N - i - 1。

**代码1——递归实现：**

``` c plus
// 二叉树种类问题
// 方法一，递归实现
int numTrees_RC(const int& n)
{
    // Error Case
    if (n < 0)
        return -1;
    // Base Case
    if (n < 2)
        // 对于 0 个和 1 个结点的情况，都返回 1 种
        return 1;
    int result = 0;
    for (int leftNum = 0; leftNum <= n - 1; leftNum++)
    {
        // 左树上的结点总数从 0 开始一直到 n - 1，因为自己要占一个结点，所以左右树上最多放 n - 1 个结点
        int leftWays = numTrees_RC(leftNum);
        // 右树上的结点树为 n - 1 - leftNum
        int rightWays = numTrees_RC(n - 1 - leftNum);
        result += leftWays * rightWays;
    }
    return result;
}
```

**代码2——动态规划：**

``` c plus
int numTrees_DP(const int& n)
{
    if (n < 0)
        return -1;
    if (n < 2)
        return 1;
    // 生成动态规划数组，dpArr[i] 表示的是对应树为 i 个结点的时候，其能够产生的 ways
    // 因为结点的个数是从 0 ~ n，所以数组的尺寸应该是 n + 1
    vector<int> dpArr(n + 1, 0);
    dpArr[0] = 1;
    for (int i = 1; i < n + 1; i++)
        // 第一层循环表示的是对应 dpArr 数值的求取
        for (int j = 0; j <= i - 1; j++)
            dpArr[i] += dpArr[j] * dpArr[i - 1 - j ];
    return dpArr[n];
}
void main()
{
    int num = 15;
	for (int i = 0; i < num; i++)
        cout << "The ways of BT is (by RC): " << numTrees_RC(i) << ", the ways of BT is (by DP): " << numTrees_DP(i) << endl;
    system("pause");
}
```

## 5.2 动态规划的空间压缩技巧

**意思是，在一般动态规划问题中，我们总是申请一整张表，而最终的结果通常指示一个单值，所以可以进一步压缩空间，而非申请一整张表。比如对于一个二维表而言，如果表中的各个元素仅依赖于其上面和左边的元素，那么只需要一个一维的数组，就可以通过自己左边已更新的元素和该数组中原本位置的元素来完成自身的更新。此外，可以申请有限个变量进行辅助来完成整个更新过程。这个方法是很有意义的，比如如果一个问题整体需要 1000000 × 4 个数据，那么最终我们只需要一个 4 元素一维数组就可以完成目标值计算。**

<font color= red>**当然，问题也不限于用一维数组，需要根据实际问题来考虑压缩空间的方式。**</font>

**[题目]** 给你一个二维数组 matrix，其中每个数都是正数，要求从左上角走到右下角。每一步只能向右或者向下，沿途经过的数字要累加起来。最后请返回最小的路径和。

**解题思路：**其实这个问题非常简单，就是一个最典型的动态规划问题，因为一个格子的最小路径和要么是到它上面格子的最小路径和加该格子的结果，要么是到它左边格子的最小路径和加该格子的结果。

**代码——动态规划：**

``` c plus
// === 矩阵路径最小和问题 === //
int matrxiMinPathSum_ordinary(const MatrixXi& mat)
{
    int rowNumber = mat.rows();
    int colNumber = mat.cols();
    if (rowNumber == 0 || colNumber == 0)
        return 0;
    vector<vector<int>> dpMat(rowNumber, vector<int>(colNumber, 0));
    // base case，明显，第一行元素仅依赖其左边元素，第一列元素仅依赖其上边元素
    dpMat[0][0] = mat(0, 0);
    // 第一行和第一列的元素没的选
    for (int i = 1; i < colNumber; i++)
        dpMat[0][i] = dpMat[0][i - 1] + mat(0, i);
    for (int i = 1; i < rowNumber; i++)
        dpMat[i][0] = dpMat[i - 1][0] + mat(i, 0);
    // 非第一行和第一列的元素只和其左边以及上面格子里面的元素有关
    for (int i = 1; i < rowNumber; i++)
        for (int j = 1; j < colNumber; j++)
            dpMat[i][j] = min(dpMat[i - 1][j] + mat(i, j), dpMat[i][j - 1] + mat(i, j));
    return dpMat[rowNumber - 1][colNumber - 1];
}
```

**代码——动态规划 + 空间压缩：**

``` c plus
int matrxiMinPathSum_spaceOptimization(const MatrixXi& mat)
{
    int rowNumber = mat.rows();
    int colNumber = mat.cols();
    if (rowNumber == 0 || colNumber == 0)
        return 0;
    // 值得一提的是，这个地方可以进一步判断行多还是列多，然后选取比较少的那一个来作为向量的生成依据，以保证空间压缩的有效性
    // 另外，如果行数多，则使用行向量，否则使用列向量
    bool rowMore = (rowNumber > colNumber ? 1 : 0);
    // 以数量更少的那一个作为向量的尺寸
    int less = rowMore ? colNumber : rowNumber;
    int more = rowMore ? rowNumber : colNumber;
    // 仅申请一个一维数组即可
    vector<int> dpVec(less, 0);
    dpVec[0] = mat(0, 0);
    // 更新第一行或者第一列的数据
    for (int i = 1; i < less; i++)
        dpVec[i] = dpVec[i - 1] + (rowMore ? mat(0, i) : mat(i, 0));
    // 以 more 作为外循环
    for (int i = 1; i < more; i++)
    {
        // 先计算该行或列的第一个元素
        dpVec[0] = dpVec[0] + (rowMore ? mat(i, 0) : mat(0, i));
        // 然后依次计算该行的其它元素
        for (int j = 1; j < less; j++)
        {
            // 这里明显增量可以提到符号外面
            // 值得注意的是，如果是 rowMode，此时外循环是行
            // 但如果是 colMore，此时外循环是列，内循环是行，不要取错矩阵的元素，需要明确的是，我们想取的元素都是同个位置的元素
            // 只是因为内外循环表示的含义不同，所以此处略有不同
            dpVec[j] = min(dpVec[j - 1], dpVec[j]) + (rowMore ? mat(i, j) : mat(j, i));
        }
    }
    // 返回最右边的元素即可
    return *dpVec.rbegin();
}
void main()
{
    int matRows = 8;
    int matCols = 8;
    for (int time = 0; time < 10; time++)
    {
        Eigen::MatrixXi mat = MatrixXi::Zero(matRows, matCols);
        for (int i = 0; i < mat.rows(); i++)
            for (int j = 0; j < mat.cols(); j++)
                // 把矩阵范围压缩到 1 ~ 31
                mat(i, j) = RandInt(20, 100, 1);
        cout << "The minimum sum of the matrix path is (By ordinary dynamic process): " << matrxiMinPathSum_ordinary(mat) << endl;
        cout << "The minimum sum of the matrix path is (By space optimization): " << matrxiMinPathSum_spaceOptimization(mat) << endl;
        cout << endl;
    }
    system("pause");
}
```

## 5.3 咖啡杯问题

**[题目]** 给定一个元素全部为正的数组，其中每一个数表示各个咖啡机加工一杯咖啡的时间，然后，有 N 个人要喝咖啡，每个人只喝一杯，而每个人喝咖啡的时间可以看作 0，而且只有 1 台洗咖啡的机器，并且其洗一杯咖啡的时间为 a，咖啡杯不洗也能变干净的时间为 b**（这个和洗咖啡机器的最大差距不在于使用时间的多少，而在于其可以并行而不止于串行）**，求这些人从泡咖啡开始到所有杯子都变干净至少所需的时间。

**解题思路：**这个问题比较难，要分成两个方面

1. 小根堆，用于统计以最短时间使得所有人可以喝完咖啡的方式，相当于把 N 个人喝咖啡的问题分解为依次喝咖啡的问题；
2. 动态规划，直接看代码的注释比较清楚。

**代码——暴力递归：**

``` c plus
// === 咖啡杯问题 === //
// arr 表示咖啡杯的冲泡效率
// N 表示喝咖啡的人数
// a 表示洗咖啡杯机器的冲洗时间
// b 表示咖啡杯自然变干净的时间（逆天）
int drinkCoffe(const vector<int>& arr, const int& N, const int& a, const int& b, const string& ifRC)
{
    // 创建一个以结点 vector<int>{ timing, makeTime } 为元素的小根堆，堆的排序以 timing + makeTime 为准
    // 而每次一个元素被放进小根堆，我们需要输出的是 timing + makeTime，并将 timing 更新为 timing + makeTime
    // 而且要不断更新小根堆
    priority_queue<vector<int>, vector<vector<int>>, Comparator_DrinkCoffe> smallRootHeap;
    // 初始化小根堆，此时的 timing 应全部初始化为 0
    for (int i = 0; i < arr.size(); i++)
        smallRootHeap.push(vector<int>{0, arr[i]});
    vector<int> drinkTiming;
    // 然后计算出 drinkTiming 数组，其长度和需要喝咖啡的人数 N 相同
    for (int i = 0; i < N; i++)
    {
        // 弹出堆顶元素
        auto tmpNode = smallRootHeap.top();
        smallRootHeap.pop();
        // 更新元素
        int newTiming = tmpNode[0] + tmpNode[1];
        drinkTiming.push_back(newTiming);
        tmpNode[0] = newTiming;
        // 将更新 Timing 后的结点重新放回堆中
        smallRootHeap.push(tmpNode);
    }
    // 然后决定用哪个方法返回结果
    return ifRC == \
        "RC" ? cleanProcess_RC(drinkTiming, a, b, 0, 0) : 
        "DP" ? cleanProcess_DP(drinkTiming, a, b) : 
        cleanProcess_DPOptimization(drinkTiming, a, b);
}
// drinkTiming 是由 washCoffeCup 函数生成好的数组，i 位置上表示第 i 个人喝完咖啡之后的时间
// index 表示从 index 个咖啡杯开始看，洗完 index ~ N - 1 咖啡杯所需达到的最小时间
// washTiming 表示洗咖啡杯机器的空闲时间节点
// 所以其实是有两条并行的时间线，还需要明确的是，喝咖啡和洗咖啡杯其实没有任何关系，两者是相互独立的
// 但这个地方确实是有贪心策略在，因为此处默认了在喝咖啡时间最短的情况下去寻找最短时间的洗咖啡杯的策略，可以使得问题消耗的时间最短
int cleanProcess_RC(const vector<int>& drinkTiming, const int& a, const int& b, const int& index, const int& washTiming)
{
    // Base case
    if (index == drinkTiming.size() - 1)
        // max(washTiming, drinkTiming[index]) 表示洗咖啡杯机器空闲的时间和最后一杯咖啡喝完时间的最大值
        // 只有两者都满足的情况下，才能够用洗咖啡杯机器洗咖啡杯
        // 而自然干净的情况就比较简单，喝完最后一杯咖啡之后等它自己干净就是其对应的最终时间
        // 这个地方，不要去想这个 washTiming 是怎么得到的，你只需要关心这一步的逻辑，其它的逻辑等其它步骤去完善
        return min(max(washTiming, drinkTiming[index]) + a, drinkTiming[index] + b);

    // Normal case
    // 用咖啡机洗咖啡杯的分支
    // wash 表示在 index 步中，我们什么时候才能够洗完咖啡杯（都说了是必须用洗咖啡机器的分支了）
    int wash = max(washTiming, drinkTiming[index]) + a;
    // next1 表示在 index 步选择用洗咖啡机器洗咖啡杯这种情况下，之后的所有步骤中，使得所有咖啡杯变干净所需的时间
    // 其实这一步非常精髓，也不太好理解
    int next1 = cleanProcess_RC(drinkTiming, a, b, index + 1, wash);
    // 两者要取最大值，表示该分支情况下使得所有咖啡杯变干净的实际所需的时间
    int branch1 = max(wash, next1);

    // 让咖啡杯自然干净的分支
    // dry 表示在 index 步中，什么时候这个杯子可以自然变干净
    int dry = drinkTiming[index] + b;
    // next2 表示在 index 步选择用让咖啡杯自然变干净这种情况下，之后的所有步骤中，使得所有咖啡杯变干净所需的时间
    int next2 = cleanProcess_RC(drinkTiming, a, b, index + 1, washTiming);
    // 两者要取最大值，表示该分支情况下使得所有咖啡杯变干净的实际所需的时间
    int branch2 = max(dry, next2);
    // 最后采用两种分支中实际耗时更短的那一种
    return min(branch1, branch2);
}
```

**代码——动态规划：**

``` c plus
// 动态规划版本
int cleanProcess_DP(const vector<int>& drinkTiming, const int& a, const int& b)
{
    int N = drinkTiming.size();
    // 观察非动态规划版本，有几条性质：
    // 1. Base case 是 index == drinkTiming.size() - 1 的情况；
    // 2. 每个位置的数据依赖其下面以及右下角的数据

    // 首先，我们要确定最大可能取到的 washTiming
    // 由于等杯子自然干净和使用洗咖啡杯机器的时间是完全独立的，这两者真是没有任何关系
    // 所以 washTiming 能够达到的最大值就是每个杯子都用洗咖啡杯机洗的情况，而且这个里面的数值都是会用到的
    // 因为本身就存在所有杯子都用洗咖啡杯机器洗的情况
    // 大概明白了纠结之处，其实就是逻辑上，很多计算过的数据实际上是使用不到的，所以总是想去把所有可能出现的情况先拿出来
    // 但所有可能出现的情况本来就是我们想求解的东西，所以这里其实是空间换时间了
    int maxWashTiming = 0;
    for (int i = 0; i < N; i++)
        maxWashTiming = max(maxWashTiming, drinkTiming[i]) + a;
    // 外层是 index，内层是 washTiming
    // 这里其实有一个很隐秘的地方，N + 1 就说明其实最终把 base case 融合到了下面的循环中
    vector<vector<int>> dp(N + 1, vector<int>(maxWashTiming + 1, 0));

    for (int index = N - 1; index >= 0; index--)
        for (int washTiming = 0; washTiming <= maxWashTiming; washTiming++)
        {
            // 计算出当前如果要使用洗咖啡杯的机器，使得当前位置咖啡杯变得干净所需的时间
            int curClean1 = max(drinkTiming[index], washTiming) + a;
            // 这个地方是比较诡异的，因为确实有很多地方是没有被重新分配数据而保持 0 的
            // 那么到底是怎么保证在更新过程中不用到这些数据的
            if (curClean1 > maxWashTiming)
                // 其实是这样的，dp[~][maxWashTiming - a + 1 ~ maxWashTiming] 这个范围内的结果是不需要填的
                // 因为在 washTiming 为 maxWashTiming - a 并且在洗第 N - 1 个杯子的时候用洗杯机器洗
                // 就已经达到了可能需要用到的 washTiming 的最大值即 maxWashTiming
                // 这个值可能会被更新入 dp[N - 1][maxWashTiming - a] 中（说可能是因为最后要取个最小）
                // 而逐行向上的过程中，可能会需要的真正列数也会逐渐变少，所以真正有用的矩阵其实是一个三角形的矩阵
                // 这是因为，比如，假如 dp[N - 2][maxWashTiming - 2a + 1] 是有效的
                // 那么其会告诉 N - 1 步，我这里需要一个 N - 1 步中，洗咖啡机的可使用时间为 maxWashTiming - 2a + 1 的最终结果
                // 这会导致 N - 1 步试图更新一个 dp[N - 1][maxWashTiming - a + 1] 的分支（这点很重要，所有分支都是会去遍历的）
                // 然而我们知道这个结果我们并不需要（因为我们之前已经算过了，最多最多只需要 maxWashTiming 时间）
                // 而此时需要的时间会达到 maxWashTiming + 1

                // = 还值得补充的一个逻辑在于，当 washTiming 为 maxWashTiming - a 时，必然有 drinkTiming[N - 1] ≤ washTiming = //
                // 同理，在每一步中都必然有类似的结论
                break;
            // base case 的体现就在于，对最后一个咖啡杯来说，没有后续的咖啡杯需要洗
            // 所以 restClean1 和 restClean2 均为 0，这里刚好我们创建的数组满足了这一点
            int restClean1 = dp[index + 1][curClean1];
            int branch1 = max(curClean1, restClean1);

            // 计算出当前如果不适用洗咖啡杯的机器，使得当前位置咖啡杯变干净所需的时间
            int curClean2 = drinkTiming[index] + b;
            int restClean2 = dp[index + 1][washTiming];
            int branch2 = max(curClean2, restClean2);
            dp[index][washTiming] = min(branch1, branch2);
        }
    return dp[0][0];
}
// 动态规划 + 遍历优化版本
int cleanProcess_DPOptimization(const vector<int>& drinkTiming, const int& a, const int& b)
{
    int N = drinkTiming.size();
    int maxWashTiming = 0;
    for (int i = 0; i < N; i++)
        maxWashTiming = max(maxWashTiming, drinkTiming[i]) + a;
    vector<vector<int>> dp(N + 1, vector<int>(maxWashTiming + 1, 0));
    // 这就是我们说的，其实我们需要的只是一个三角形区域内的数据，通过 base case 生成最后一行，然后不断缩小范围直至 [0][0]
    for (int index = N - 1; index >= 0; index--)
        for (int washTiming = 0; washTiming <= maxWashTiming - a - (N - 1 - index); washTiming++)
        {
            int curClean1 = max(drinkTiming[index], washTiming) + a;
            int restClean1 = dp[index + 1][curClean1];
            int branch1 = max(curClean1, restClean1);

            int curClean2 = drinkTiming[index] + b;
            int restClean2 = dp[index + 1][washTiming];
            int branch2 = max(curClean2, restClean2);
            dp[index][washTiming] = min(branch1, branch2);
        }
    return dp[0][0];
}
void main()
{
	vector<int> arr{ 3, 5, 7, 6 };
	int N = 20;
	int a = 10;
	int b = 25;
	cout << "The coffee problem by RC is: " << drinkCoffe(arr, N, a, b, "RC") << endl;
	cout << "The coffee problem by DP is: " << drinkCoffe(arr, N, a, b, "DP") << endl;
	cout << "The coffee problem by DPOP is: " << drinkCoffe(arr, N, a, b, "DPOP") << endl;
	system("pause");
}
```

## 5.4 唱歌问题

**[题目]** 抽象一下，有一个初始值 start 和一个目标值 end，两者均为偶数，现在有三种方式对 start 进行修改，第一种方式使 sum += a，可以使得 start += 2，第二种方式使 sum += b，可以使得 start \*= 2，第三种方式使 sum += c，可以使得 start -= 2。求一种方式使得 sum 最小。

**解题思路：**主要需要注意，从逻辑层面看递归很简单，但需要添加限制和足够的 base case。有以下分析：

1. **特解限制，**可以人为找出一种特解，比如对该问题，我们可以全部采用第一种方式，此时需要花费的 money 为 (end - start) / 2 \* a，那么在递归过程中，对任意情况，其对应花费的 money 已经超过了该特解，则直接返回无效结果（因为其不可能是最优解了）；
2. **具体边界，**对该问题而言，将人气降到负数是没有任何道理的；没有必要将人气升到 2 \* end 以上，因为乘 start 使得其超过 end 的目的是为了减（因为减的代价可能比较小），但也不是说随便乱乘，因为没有必要创造冗余的加减操作**（在使得人气上升到 2 * end 的操作之前，start 必然已经比 end 大，此时直接减就可以了，不可能还需要其它多余的加和乘操作）**。

**代码——暴力迭代：**

``` c plus
// === Kiki 唱歌问题 === //
namespace Kiki
{
    int minCost_RC(const int& addCost, const int& multiCost, const int& subCost, const int& start, const int& end)
    {
        if (start > end)
            return -1;
        return process_RC(0, end, addCost, multiCost, subCost, start, 2 * end, (end - start) / 2 * addCost);
    }
    // curCost 表示当前花费
    // aim 表示目标值
    // curStart 表示当前的值，因为我们逻辑上是对 start 进行修改使其达到 end，所以为其命名为 curStart
    // limitEnd 表示我们的当前值 curStart 最大不能超过一个边界 end 值
    // limitCost 表示我们的方案不得超过特解的 cost，否则必然不是最好的方案
    int process_RC(const int& curCost, const int& end,
        const int& addCost, const int& multiCost, const int& subCost,
        const int& curStart, const int& limitEnd, const int& limitCost)
    {
        // start 超出有效范围，直接返回
        if (curStart < 0 || curStart >= limitEnd)
            // 返回 int 最大值,其不会影响最终的求解结果
            return INT_MAX;
        if (curCost > limitCost)
            return INT_MAX;
        // base case
        if (curStart == end)
            return curCost;
        // start += 2 的分支
        int result = INT_MAX;
        int p1 = process_RC(curCost + addCost, end, addCost, multiCost, subCost, curStart + 2, limitEnd, limitCost);
        if (p1 != INT_MAX)
            result = p1;
        // start *=2 的分支
        int p2 = process_RC(curCost + multiCost, end, addCost, multiCost, subCost, curStart * 2, limitEnd, limitCost);
        if (p2 != INT_MAX)
            result = min(result, p2);
        // start -= 2 的分支
        int p3 = process_RC(curCost + subCost, end, addCost, multiCost, subCost, curStart - 2, limitEnd, limitCost);
        if (p3 != INT_MAX)
            result = min(result, p3);
        return result;
    }
}
void main()
{
	// 参数含义依次为 
	// addCost, multiCost, subCost, start, end
	cout << "By Recurrent: " << Kiki::minCost_RC(10, 100, 20, 6, 10) << endl;		// 输出 20
	cout << "By Recurrent: " << Kiki::minCost_RC(50, 10, 20, 6, 20) << endl;		// 输出 40，(6 * 2 - 2) * 2 = 20
	system("pause");
}
```

**代码——动态规划：**

``` c plus
// 这是一个二维的动态规划问题，非常值得研究的一道题，有很多的注意点
// 变量为 start 和 curCost
int minCost_DP(const int& addCost, const int& multiCost, const int& subCost, const int& start, const int& end)
{
    if (start > end)
        return -1;
    int specialCost = ((end - start) / 2) * addCost;
    // 不妨设第一层循环为 start，第二层循环为 curCost
    // 用 vector 刚好，因为对第一层循环的下标，意味着 start 小于 0，刚好对应于无效的情况
    // 第一层循环的范围明显为 0 ~ (2 * end - 1)，因为刚好等于 2 * end 也肯定是无效的，第二层循环的范围是 0 ~ specialCost（特解）
    vector<vector<int>> dp(2 * end, vector<int>(specialCost + 1, INT_MAX));
    // 该问题的 元素含义 比较特殊
    // dp[i][j] 表示以 start（形参）, curCost = j 作为基本条件
    // 以 end（不是形参）= i 作为目标的情况下，需要消费的最少 money
    // 那么对应的 base case 就能够知道，即如果 i = start 就是给定的 end 值，则对应的最小 money 就是当前的 curCost（因为不需要额外操作）
    for (int j = 0; j <= specialCost; j++)
        // 因为 j 就表示 curCost，而 i 表示目标 end，所以如果目标 end 就是当前给定的 start，则最少的 cost 就是当前的 curCost
        dp[start][j] = j;
    // 递推关系：dp[i][j] = 
    // min(dp[i - 2][j] + addCost,
    // dp[i / 2][j] + multiCost,
    // dp[i + 2][j] + subCost)
    // 也就是说，有三种可能的方式可以达到当前的状态，即目标为 i - 2 且初始花费的 money 为 j 的状态
    // 这种状态下，只需要在执行一次 add 操作，就可以达到目标为 i 且初始花费为 j 的状态，其它两种情况同理
    // 值得注意的是，此时所设的变量含义是有点割裂的，因为对应的 i 是最终的 end 值，但 j 表示的是当前花费（说成初始花费更容易理解）

    // 值得一提的几点：
    // 1. dp 中的最后一列，它表示初始花费就已经达到 specialCost 即花费上限的情况
    // 那么此时只有一开始 start 就和目标 end 相同，才有可能产生有效的解，否则必然会因为额外操作而使得结果无效
    // 2. 对同一行而言，只要找到一行中的某个元素结果，就可以依次写出该行所有其它元素，因为初始花费不会影响从 start 达到当前 end 的额外花费
    // 3. dp[i - 2][j] + addCost 代表从 += 2 的分支到达当前 dp[i][j] 的结果，它等价于 dp[i - 2][j + addCost]
    // 这一点非常关键，从 2 可以很容易看出来这个关系，因为 dp[i - 2][j] 和 dp[i - 2][j + addCost] 的差距本身就仅在初始花费 addCost
    // 4. 循环中，行列的先后非常关键，会直接影响求解的正确性，特别对于 dp 中的元素初始化为有效值的情况，这个问题不容易发现
    // 比如该问题而言，前一列的元素依赖于后一列，所以必须按列更新，则列的循环必须在外
    for (int j = specialCost - 1; j >= 0; j--)
        for (int i = 0; i < 2 * end; i++)
        {
            if (((i - 2) >= 0) && (j + addCost <= specialCost))
                // start += 2 的分支
                dp[i][j] = min(dp[i][j], dp[i - 2][j + addCost]);
            if (!(i & 1) && !((i / 2) & 1) && (j + multiCost <= specialCost))
                // start *=2 的分支
                // 在 i 本身是偶数，且 i 除以 2 为偶数的情况下，其才有可能从一步以乘 2 的形式达到，否则这种操作是无效的
                dp[i][j] = min(dp[i][j], dp[i / 2][j + multiCost]);
            if (((i + 2) < 2 * end) && (j + subCost <= specialCost))
                // start -= 2 的分支
                dp[i][j] = min(dp[i][j], dp[i + 2][j + subCost]);
        }
    //ShowMatrix(dp);
    // 返回目标为 end，初始花费值为 0 的结果
    return dp[end][0];
}
void main()
{
	// 参数含义依次为 
	// addCost, multiCost, subCost, start, end
	int addCost = 50;
	int multiCost = 10;
	int subCost = 30;
	int start = 6;
	int end = 20;
	cout << "By Recurrent: " << Kiki::minCost_RC(addCost, multiCost, subCost, start, end) << endl;		// 输出 40，(6 * 2 - 2) * 2 = 20
	cout << "By Dynamic Process: " << Kiki::minCost_DP(addCost, multiCost, subCost, start, end) << endl;	// 输出 40，(6 * 2 - 2) * 2 = 20
	system("pause");
}
```

<font color = red>**这道题很有代表意义，仔细阅读注释中的注意事项。**</font>

# 6. 斐波那契数列套路

​		简而言之，对于递归关系严格唯一的问题，都可以找到一个时间复杂度 $O(logN)$ 的解。

​		因为对严格递推的数列，其存在以下的关系：
$$
\left[
\begin{matrix}
F_{i+2} & F_{i+1}
\end{matrix}\ 
\right]
=
\left[
\begin{matrix}
F_{i+1} & F_{i}
\end{matrix}\ 
\right]
\left[
\begin{matrix}
a & b\\
c & d
\end{matrix}\ 
\right]
$$
这个关系显而易见，而我们可以利用这个关系来对此类问题进行优化。即通过前几项来求出对应变换矩阵中的几个元素，对斐波那契数列来说，明显有
$$
a=1\\b=1\\c=1\\d=0
$$

## 6.1 斐波那契数列

**[题目]** 求斐波那契数列第 N 项元素，要求以时间复杂度 $O(logN)$ 完成。

**解题思路：**针对斐波那契数列问题而言
$$
\left[
\begin{matrix}
F_{N} & F_{N-1}
\end{matrix}\ 
\right]
=
\left[
\begin{matrix}
1 & 1
\end{matrix}\ 
\right]
\left[
\begin{matrix}
1 & 1\\
1 & 0
\end{matrix}\ 
\right]^{(N-1)}
$$
那么对于任意一个目标结果，问题被转换为了如何快速求矩阵的乘积。而快速求矩阵的方式即将次幂拆成二进制，比如
$$
A^{75}=A^{10001011}
$$
而此时所有所需的乘积因素就变成了
$$
A^{1},A^{2},A^{4},...,A^{2^N}
$$
那么对原问题而言其就变成了
$$
A^{75}= A^{64}A^{8}A^{2}A^{1}
$$
明显，求出所有因数的过程的时间复杂度是 $O(logN)$ 的，而最终乘积的时间复杂度也是 $O(logN)$ 水平的，所以最终整个过程的时间复杂度也是如此。

**代码——暴力法：**

``` c plus
// === 斐波那契数列问题 === //
// 问题一. 暴力版本
int Fibonacci_brutal(const int& n)
{
    if (n == 0 || n == 1)
        return 1;
    int pre1 = 1;
    int pre2 = 1;
    int result = 0;
    for (int i = 2; i <= n; i++)
    {
        result = pre1 + pre2;
        pre1 = pre2;
        pre2 = result;
    }
    return result;
}
```

**代码——时间优化方法：**

``` c plus
// 问题二. 优化版本
// 定义矩阵乘法
vector<vector<int>> operator*(const vector<vector<int>>& mat1, const vector<vector<int>>& mat2)
{
    if (mat1.empty() || mat2.empty())
        throw string("The multiplied matrices are empty!");
    if (mat1[0].size() != mat2.size())
        throw string("The pre matrix's column number doesn't equal the post matrix's row number");
    int rowNumber = mat1.size();
    int colNumber = mat2[0].size();
    vector<vector<int>> result(rowNumber, vector<int>(colNumber, 0));
    for (int i = 0; i < rowNumber; i++)
        for (int j = 0; j < colNumber; j++)
            for (int k = 0; k < mat1[i].size(); k++)
                result[i][j] += mat1[i][k] * mat2[k][j];
    return result;
}
// 定义矩阵的次幂
vector<vector<int>> matrixPower(const vector<vector<int>>& mat, const int& power)
{
    if (mat.empty())
        throw string("The given matrix is empty!");
    if (mat.size() != mat[0].size())
        throw string("The given matrix isn't square");
    // 这里最好就直接从单位矩阵开始乘，因为无法保证二进制个位上一定有数
    vector<vector<int>> result(mat.size(), vector<int>(mat[0].size(), 0));
    for (int i = 0; i < result.size(); i++)
        result[i][i] = 1;
    int curPower = power;
    // 当前的矩阵因数
    vector<vector<int>> curPowerMatrix = mat;
    // 在次幂数不为 0 的时候不断执行
    while (curPower != 0)
    {
        if ((curPower & 1) != 0)
            // 说明当前位有东西，需要加入到结果中
            result = result * curPowerMatrix;		
        // 计算当前矩阵因数，不管当前位置要不要加入到结果，都需要计算
        curPowerMatrix = curPowerMatrix * curPowerMatrix;
        // 次幂继续右移
        curPower = curPower >> 1;
    }
    return result;
}
int Fibonacci_optimization(const int& n)
{
    if (n < 0)
        return 0;
    if (n == 0 || n == 1)
        return 1;
    // 我去，震惊了，多层的 vector 居然可以这么初始化，一直不知道
    vector<vector<int>> baseMatrix{
        {1, 1},
        {1, 0},
    };
    // 这里 n 要从 2 开始取，前面已经过滤了不满足要求的情况，所以没有问题
    vector<vector<int>> powerMatrix = matrixPower(baseMatrix, n - 1);
    return (powerMatrix[0][0] + powerMatrix[1][0]);
}
void main()
{
	// Fibonacci 暴力法
	for (int i = 0; i < 20; i++)
		cout << Fibonacci_brutal(i) << ", ";
	cout << endl;
	// Fibonacci 优化法
	for (int i = 0; i < 20; i++)
		cout << Fibonacci_optimization(i) << ", ";
	cout << endl;
	system("pause");
}
```

## 6.2 推广——母牛问题

**比如**有类似的严格递推关系为
$$
F(i) =3F(i-1) -4F(i-3)+6F(i-5)
$$
那么明显的有
$$
\left[
\begin{matrix}
F_{i} & F_{i-1} & F_{i-2} & F_{i-3} & F_{i-4}
\end{matrix}\ 
\right]
=
\left[
\begin{matrix}
F_{i-1} & F_{i-2} & F_{i-3} & F_{i-4} & F_{i-5}
\end{matrix}\ 
\right]
\left[
\begin{matrix}
3 & 1 & 0 & 0 & 0\\
0 & 0 & 1 & 0 & 0\\
-4 & 0 & 0 & 1 & 0\\
0 & 0 & 0 & 0 & 1\\
6 & 0 & 0 & 0 & 0\\
\end{matrix}\ 
\right]
$$
其实就是看递推项中的最大跨度是多少，那么行矩阵的维度就是这个跨度，比如上面的最大跨度是 1 ~ 5，即跨度为 5，则行矩阵的维度为 5。同理，base case 也需要一直延申到 i = 4，即也需要先有跨度个数个基本数据，另外还需注意次幂数，比如对该案例有
$$
\left[
\begin{matrix}
F_{i} & F_{i-1} & F_{i-2} & F_{i-3} & F_{i-4}
\end{matrix}\ 
\right]
=
\left[
\begin{matrix}
F_{i-1} & F_{i-2} & F_{i-3} & F_{i-4} & F_{i-5}
\end{matrix}\ 
\right]
\left[
\begin{matrix}
3 & 1 & 0 & 0 & 0\\
0 & 0 & 1 & 0 & 0\\
-4 & 0 & 0 & 1 & 0\\
0 & 0 & 0 & 0 & 1\\
6 & 0 & 0 & 0 & 0\\
\end{matrix}\ 
\right]
$$
**[题目]** 有一只母牛，她每年可以生一只母牛，而每一只母牛要**满 3 岁**之后才能生母牛，问在 n 年总共有多少牛。

**解题思路：**明显有递推关系
$$
F(i)=F(i-1)+F(i-3)
$$
因为其实当前牛的牛数就是去年的牛数加上今年可以生牛的牛数，而今年可以生牛的牛数自然就是 3 年前**（一共 4 个数，中间有 3 个间隔）**的牛数。

**代码：**

``` c plus
// 问在 n 年一共有多少只牛
int cowProblem(const int& n)
{
    if (n < 0)
        return 0;
    // 基本数据全部都是 1，因为在第三年之前，都只有一头牛
    if (n == 0 || n == 1 || n == 2)
        return n + 1;
    // 我去，震惊了，多层的 vector 居然可以这么初始化，一直不知道
    vector<vector<int>> baseMatrix{
        {1, 1, 0},
        {0, 0, 1},
        {1, 0 ,0}
    };
    // 这里 n 要从 2 开始取，前面已经过滤了不满足要求的情况，所以没有问题
    // 从 3 开始有第一次递推，所以这里用 n - 2
    // 值得注意的是，不管递推中用到了几个前驱变量，此时都需要完整写出所有向量，这是数学递推关系决定的
    vector<vector<int>> powerMatrix = matrixPower(baseMatrix, n - 2);
    return (3 * powerMatrix[0][0] + 2 * powerMatrix[1][0] + powerMatrix[2][0]);
}
void main()
{
	for (int i = 0; i < 20; i++)
		cout << cowProblem(i) << ", ";
	cout << endl;
	system("pause");
}
```

## 6.3 01 达标字符串问题

**[题目]** 字符串只由 '0' 和 '1' 两种字符构成。

当字符串长度为 1 时，所有可能的字符串为 "0"、"1"，共 2 个；

当字符串长度为 2 时，所有可能的字符串为 "00"、"01"、"10"、11"，共 4 个；

当字符串长度为 3 时，所有可能的字符串为 "000"、"001"、"010"、"011"、"100"、"101"、"110"、"111"，共 8 个；

如果某一个字符串中，只要是出现 '0' 的位置，左边就靠着 '1'，这样的字符串叫作达标字符串。

给定一个正数 N，返回所有长度为 N 的字符中，达标字符串的数量。

比如，N = 3，返回 3，因为只有 "101"、"110"、"111" 达标。

**解题思路：**给一个函数 F，F(i) 表示首位可以填 0 或 1 的长度 i 的 01 字符串，并可以使得总串达标的情况数目（即该字符串前面默认已经填了一个 1 了）。那么如果首位填 1，那么下一位也可以任意填 0 或者 1，那么此时问题变成了 F(i - 1)，如果首位填 0，则下一位只能填 1，则下下一位就可以填 0 或者 1，则此时问题变成了 F(i - 2)，那么有
$$
F(i) = F(i-1) + F(i-2)
$$
这就变成了一个类 Fibonacci 数列问题。

**代码：**

``` c plus
// === 01 达标字符串问题 === //
int _01QualifiedString(const int& n)
{
    // 值得注意的是，我们推出的关系适用的 F 的真正含义
    // 由于第一个数字我们不能填 0，所以实际上我们真正计算的是 n - 1
    // 比如我们输入一个 3，这个时候我们应该调用 F(2)，因为第一位必须填 1
    int real_n = n - 1;
    if (real_n < 0)
        return 0;
    if (real_n == 0)
        return 1;
    if (real_n == 1)
        return 2;
    // 基本矩阵就是 fibonacci 问题中的基本矩阵，只是 base case 稍有不同
    vector<vector<int>> baseMatrix{
        {1, 1},
        {1, 0},
    };
    vector<vector<int>> powerMatrix = matrixPower(baseMatrix, real_n - 1);
    // 注意，因为我们建立递推关系的时候，大下标的数是放前面的
    return 2 * powerMatrix[0][0] + powerMatrix[1][0];
}
```

## 6.4 拼三角形问题

**[题目]** 在迷迷糊糊的大草原上，小红捡到了 n 根木棍，第 i 根木棍的长度为 i，小红现在很开心。想选出其中的三根木棍组成美丽的三角形。但是小明想捉弄小红，想去掉一些木棍，使得小红任意选三根木棍都不能组成三角形。

请问小明最少去掉多少根木棍呢？给定 N，返回至少去掉多少根？

**解题思路：**其实就是把一些长度的棍子拿出去之后，剩下的木棍中，按长度升序排序，并且满足
$$
F(i)\geq F(i-1)+F(i-2)
$$
而刚好，当所有剩下的木棍都是斐波那契数的时候，能够使得去除的木棍最少且任意三根木棍都不能组成三角形。

**代码：**

``` c plus
// === 去火柴棒问题 === //
// m 表示总的火柴棒的数目
int removeWood(const int& m)
{
    if (m < 4)
        // 这种情况根本没的去，直接返回 0
        return 0;
    // 只需要知道在 m 范围内有多少个斐波那契数就行
    // 因为当 m 为 4 的时候，就已经有 3 个斐波那契数了，所以初始数目为 3
    int fiboNum = 3;
    int F_isub2 = 2;
    int F_isub1 = 3;
    // 这时候就很适合采用 while 循环，给定两个基本斐波那契数，可以想象，如果 m 为 5，则应该要进一次循环，则应该取循环条件为
    while (F_isub2 + F_isub1 <= m)
    {
        fiboNum++;
        int tmp = F_isub2;
        F_isub2 = F_isub1;
        F_isub1 += tmp;
    }
    return m - fiboNum;
}
```

# 7. 二叉树的递归套路

## 7.1 搜索二叉树转双向链表

**[题目]** 双向链表节点结构和二叉树节点结构是一样的，如果你把 last 认为是left，right 认为是 next 的话。给定一个搜索二叉树的头节点 head，请转化成一条有序的双向链表，并返回链表的头节点。**（实际最终的结果是中序遍历二叉树的形式得到的双向链表）**

**解题思路1——直接中序遍历**

**代码：**

``` c plus
// 方法1. 直接中序遍历
TNode* convert1(TNode* head)
{
    if (head == NULL)
        return NULL;
    queue<TNode*> que;
    // 中修改v遍历节点，并得到对应的结果队列
    inOrderToQueue(head, que);
    // 因为排除了头结点为空的情况，现在队列里面应当至少有一个节点
    // 因为第一个节点的左指针要指向空，则需要将其单独处理
    // 弹出第一个元素
    // 顺便把 head 指向双向链表的第一个元素，方便后续返回
    head = que.front();
    TNode* cur = head;
    que.pop();
    cur->left = NULL;
    while (!que.empty())
    {
        // 记录上一个节点，不会记录到空，因为其至少是第一个节点
        TNode* pre = cur;
        cur = que.front();
        que.pop();
        // 当前节点的左指针指向前一个节点
        cur->left = pre;
        // 前一个节点的右指针指向当前节点
        pre->right = cur;
    }
    // 最后把最后一个节点的右指针指向空
    cur->right = NULL;
    return head;
}
// 用一个引用队列来存储中序遍历的节点结果
void inOrderToQueue(TNode* head, queue<TNode*>& que)
{
    if (head == NULL)
        return;
    inOrderToQueue(head->left, que);
    que.push(head);
    inOrderToQueue(head->right, que);
}
```

**解题思路2——套路：**主要一定要想到，每一次将部分二叉搜索树结构转换为双向链表之后，需要返回这一个部分整体的 left 和 right，即转换后局部双向链表的 head 和 last。

**代码：**

``` c plus
// 方法2. 套路
// 分析我们需要从子树中获得的信息，在子树的结构已经完整建立之后，我们只需要从左树和右树要过来整个子树作为双向链表时候的左右指针即可
TNode* convert2(TNode* head)
{
    if (head == NULL)
        return NULL;
    return process(head).start;
}
ReturnType process(TNode* head)
{
    // base case，这里还不太好考虑需要什么样的 base case，所以不妨先考虑递推关系
    if (head == NULL)
        return ReturnType(NULL, NULL);
    // 可以想到，我们需要从左右孩子那里把局部双向链表的左节点和右节点收上来，并以当前节点和这些节点之间建立关系
    auto leftSubTreeReturned = process(head->left);
    auto rightSubTreeReturned = process(head->right);
    // 把当前节点的左指针指向收上来的 左树结果 的右节点
    head->left = leftSubTreeReturned.end;
    // 如果 左树结果 的右节点不为空，则把它的右指针指向当前节点
    if (leftSubTreeReturned.end != NULL)
        leftSubTreeReturned.end->right = head;
    // 把当前节点的右指针指向收上来的 右树结果的 左节点
    head->right = rightSubTreeReturned.start;
    // 如果 右树结果 的左节点不为空，则把它的左指针指向当前节点
    if (rightSubTreeReturned.start != NULL)
        rightSubTreeReturned.start->left = head;
    // 这里需要注意，如果左右收上来的结果是空的，则返回自己，这个大概想想就知道
    return ReturnType(
        leftSubTreeReturned.start == NULL ? head : leftSubTreeReturned.start,
        rightSubTreeReturned.end == NULL ? head : rightSubTreeReturned.end
    );
}
// 分别从两个方向打印得到的双向链表
void printDoubleLinkedList(TNode* head)
{
    if (head == NULL)
        return;
    TNode* cur = head;
    // 需要一个前指针，因为当 cur 指向 NULL 的时候，代表正向打印完成，但此时没有办法反向搜索
    // 也可以配合 break 来省去这个指针，但此时每一步都需要多一个判断
    TNode* pre = NULL;
    while (cur != NULL)
    {
        pre = cur;
        cout << cur->data << ", ";
        cur = cur->right;
    }
    cout << " | ";
    // pre 是从左往右的顺序意义上的 pre
    while (pre != NULL)
    {
        cur = pre;
        cout << pre->data << ", ";
        pre = pre->left;
    }
    cout << endl;
}
void main()
{
	Solutions::TNode* head1 = ConstructCBT();
	cout << "中序遍历结果：" << endl;
	InOrderRecur1(head1);
	cout << endl;

	cout << "转双向链表结果1：" << endl;
	auto doubleLinkedHead1 = BSTtoDoubleLinkedList::convert1(head1);
	BSTtoDoubleLinkedList::printDoubleLinkedList(doubleLinkedHead1);

	Solutions::TNode* head2 = ConstructCBT();
	cout << "转双向链表结果2：" << endl;
	auto doubleLinkedHead2 = BSTtoDoubleLinkedList::convert2(head2);
	BSTtoDoubleLinkedList::printDoubleLinkedList(doubleLinkedHead2);

	system("pause");
}
```

## 7.2 找最大搜索二叉树

**[题目]** 找到一棵二叉树中，最大的搜索二叉子树，返回最大搜索二叉子树的节点数（如果有相同大小的，返回其中一个即可）。**（注意现在的目标是子树，不仅仅是要求结构）。**

**解题思路：**还是先分析当前根需要从左右树中需要拿到的信息，即：

​		1）左右子树上的最大搜索二叉子树的头结点；

​		2）左右子树是不是二叉搜索树（可以去掉，可以通过比较左右子树节点是否是左右子树的最大搜索二叉树节点来判断）；

​		3）左右子树中节点的最大值

​		4）左右子树中节点的最小值

​		5）左右子树的大小

然后分析得到，如果当前树是搜索二叉树，那么对当前树而言，其最大的搜索二叉树的根就是该树的根；但若当前树不是搜索二叉树，就需要从左右子树返回的信息来判断应该是哪一棵树。

**代码1——自写版本：**

``` c plus
// === 查找一棵二叉树中的 size 最大的搜索二叉树（要求是一棵真正的二叉树，不单单是要求结构满足搜索二叉树） === //
namespace BiggestSubBSTInTree
{
// 调用该函数
TNode* getMaxBST(TNode* head)
{
    if (head == NULL)
        return NULL;
    return process(head)->maxSubBSTNode;
}
// 输入当前节点，返回以其为根的信息，为了可以用 NULL 判断，我们返回堆区指针
// 需要注意释放空间
ReturnType* process(TNode* X)
{
    // base case
    if (X == NULL)
        // 如果当前节点是空的，自然返回空
        return NULL;
    // 递推关系
    auto leftSubTreeReturn = process(X->left);
    auto rightSubTreeReturn = process(X->right);

    // 把需要返回的变量列出来，马上就知道后续逻辑了
    int minValue = X->data;
    int maxValue = X->data;
    if (leftSubTreeReturn != NULL)
    {
        minValue = min(minValue, leftSubTreeReturn->minValue);
        maxValue = max(maxValue, leftSubTreeReturn->maxValue);
    }
    if (rightSubTreeReturn != NULL)
    {
        minValue = min(minValue, rightSubTreeReturn->minValue);
        maxValue = max(maxValue, rightSubTreeReturn->maxValue);
    }

    // 上面的设置是必须的，而以下的判断需要分情况
    TNode* maxSubBSTNode = NULL;
    bool isBST = false;
    int size = 0;

    if (
        // 情况1. 如果整体构成一个搜索二叉树
        // 左树为空，或左树不为空且左树是搜索二叉树且左树最大值小于当前节点值
        (leftSubTreeReturn == NULL || (leftSubTreeReturn->isBST && leftSubTreeReturn->maxValue < X->data)) &&
        // 右树为空，或右树不为空且右树是搜索二叉树且右树最小值大于当前节点值
        (rightSubTreeReturn == NULL || (rightSubTreeReturn->isBST && rightSubTreeReturn->minValue > X->data))
        )
    {
        // 当前节点就是最大
        maxSubBSTNode = X;
        // 设置当前节点对应树是搜索二叉树
        isBST = true;
        // 此时对应的最大子搜索二叉树的大小是左右两树大小相加 + 1
        size = (leftSubTreeReturn == NULL ? 0 : leftSubTreeReturn->maxSubBSTSize)
            + (rightSubTreeReturn == NULL ? 0 : rightSubTreeReturn->maxSubBSTSize) + 1;
    }
    else
    {
        // 情况2.
        // 设置当前节点对应树不是搜索二叉树
        isBST = false;
        // 然后从左右子树中返回最大的搜索二叉树节点
        if (leftSubTreeReturn == NULL)
        {
            maxSubBSTNode = rightSubTreeReturn->maxSubBSTNode;
            size = rightSubTreeReturn->maxSubBSTSize;
        }
        else if (rightSubTreeReturn == NULL)
        {
            maxSubBSTNode = leftSubTreeReturn->maxSubBSTNode;
            size = leftSubTreeReturn->maxSubBSTSize;
        }
        else
        {
            // 说明左右节点均不为空
            if (rightSubTreeReturn->maxSubBSTSize > leftSubTreeReturn->maxSubBSTSize)
            {
                // 右树上对应的最大 BST 尺寸大，则返回右树上的结果
                maxSubBSTNode = rightSubTreeReturn->maxSubBSTNode;
                size = rightSubTreeReturn->maxSubBSTSize;
            }
            else
            {
                // 否则返回左树上的结果
                maxSubBSTNode = leftSubTreeReturn->maxSubBSTNode;
                size = leftSubTreeReturn->maxSubBSTSize;
            }
        }
    }
    // 释放左右树收上来的数据空间，值得注意
    if (leftSubTreeReturn != NULL)
        delete leftSubTreeReturn;
    if (rightSubTreeReturn != NULL)
        delete rightSubTreeReturn;
    // 返回结果
    return new ReturnType(isBST, maxSubBSTNode, minValue, maxValue, size);
}
```

**代码2——标准版本（不返回NULL情况，不过我们也算是练习了一把堆区数据管理）：**

``` c plus
// 调用该函数
TNode* getMaxBST_standard(TNode* head)
{
    if (head == NULL)
        return NULL;
    return process_standard(head)->maxBSTHead;
}
// 输入当前节点，返回以其为根的信息，为了可以用 NULL 判断，我们返回堆区指针
// 需要注意释放空间
ReturnType_Standard* process_standard(TNode* X)
{
    // base case : 如果子树是空树
    // 最小值为系统最大
    // 最大值为系统最小
    if (X == NULL) {
        // 最小值设置为最大值，最大值设置为最小值，这样就不会影响后续函数判断
        return new ReturnType_Standard(NULL, 0, INT_MAX, INT_MIN);
    }
    // 默认直接得到左树全部信息
    ReturnType_Standard* lData = process_standard(X->left);
    // 默认直接得到右树全部信息
    ReturnType_Standard* rData = process_standard(X->right);
    // 以下过程为信息整合
    // 同时以X为头的子树
    
    也做同样的要求，也需要返回如ReturnType描述的全部信息
    // 以X为头的子树的最小值是：左树最小、右树最小、X的值，三者中最小的
    int minValue = min(X->data, min(lData->min, rData->min));
    // 以X为头的子树的最大值是：左树最大、右树最大、X的值，三者中最大的
    int maxValue = max(X->data, max(lData->max, rData->max));
    // 如果只考虑可能性一和可能性二，以X为头的子树的最大搜索二叉树大小
    int maxBSTSize = max(lData->maxBSTSize, rData->maxBSTSize);
    // 如果只考虑可能性一和可能性二，以X为头的子树的最大搜索二叉树头节点
    Solutions::TNode* maxBSTHead = lData->maxBSTSize >= rData->maxBSTSize ? lData->maxBSTHead: rData->maxBSTHead;
    // 利用收集的信息，可以判断是否存在可能性三
    // 很巧妙的地方在于，这个地方居然刚好可以处理左右节点为空的情况，因为左节点的最大值是整数最小，右节点的最小值是整数最大，所以从数值上肯定是 BST
    // 而且指针 NULL == NULL 也刚好判断成功，牛的
    if (lData->maxBSTHead == X->left && rData->maxBSTHead == X->right
        && X->data > lData->max && X->data < rData->min) {
        maxBSTSize = lData->maxBSTSize + rData->maxBSTSize + 1;
        maxBSTHead = X;
    }
    // 信息全部搞定，返回
    return new ReturnType_Standard(maxBSTHead, maxBSTSize, minValue, maxValue);
}
void main()
{
	Solutions::TNode* head = new Solutions::TNode(6);
	head->left = new Solutions::TNode(1);
	head->left->left = new Solutions::TNode(0);
	head->left->right = new Solutions::TNode(3);
	head->right = new Solutions::TNode(12);
	head->right->left = new Solutions::TNode(10);
	head->right->left->left = new Solutions::TNode(4);
	head->right->left->left->left = new Solutions::TNode(2);
	head->right->left->left->right = new Solutions::TNode(5);
	head->right->left->right = new Solutions::TNode(14);
	head->right->left->right->left = new Solutions::TNode(11);
	head->right->left->right->right = new Solutions::TNode(15);
	head->right->right = new Solutions::TNode(13);
	head->right->right->left = new Solutions::TNode(20);
	head->right->right->right = new Solutions::TNode(16);

	Solutions::TNode* bst = BiggestSubBSTInTree::getMaxBST(head);
	Solutions::TNode* bst_standard = BiggestSubBSTInTree::getMaxBST_standard(head);
    // 输出结果相同，没得问题
	cout << bst->data << ", " << bst << endl;
	cout << bst_standard->data << ", " << bst_standard << endl;
	system("pause");
}
```



