# 1. 舍弃可能性

## 1.1 排序后相邻数差值最大问题

**[题目]** 给定一个数组，求如果排序之后，相邻两数的最大差值。要求时间复杂度 O(N)，且要求不能用非基于比较的排序。

**解题思路：**对于一个拥有 N 个元素数组，我们一共准备 N + 1 个桶，每个桶用于管理某个范围内的数字，然后遍历数组，找出最大最小值，然后根据最大最小值范围，分出 N + 1 个桶，每个桶种用于维护对应范围内的数字，而至于如何计算对应的数字在哪个桶中，看下图：

<img src="C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230526103219703.png" alt="image-20230526103219703" style="zoom:80%;" />

其实就是比例计算，桶的范围和值的范围是成比例的，那么将比例计算结果再取地板四舍五入即可。值得注意的是，我们的桶一共设置为数组长度 + 1 个，这样做有两点意义：

1. **保证能取到最大最小值之差的相邻数一定在不同桶，**而不会在同一个桶内，因为一个桶内的**最大**差值为范围大小（用浮点数来解释），而如果结果中必然至少有一个空桶，那么这个空桶两侧桶内的最大最小值之差**最小**也为一个范围大小，所以我们可以直接舍弃所有在一个桶内找结果的可能；
2. **保证计算结果不会溢出，**每个范围的大小应该是 range = (max – min)/N，而范围 i 对应为 min + (i - 1) * range ~ min + i * range – 1，比如 min 为 1，max 为 51，那么现在想取 5 个范围，此时每个范围的大小明显为 10（因为 1 ~ 50 中间一共的范围大小为 50），但这样做有一个小问题，就是当值取到 max 的时候，从公式上也看得出来，其算出来的桶结果会比我们给定的桶的下标大 1，所以在问题中设置桶的范围为 N + 1，注意，是我们在计算给定数据所属桶的时候用的 N，但我们实际上申请了 N + 1 个桶的空间。

**那么由于桶所表示的范围是连续的，所以相邻的数必然是相邻非空桶的前桶最大值和后桶最小值。**

``` c plus
// === 排序后相邻数差值最大问题 === //
namespace MaxGap
{
    // 1. 对数器
    int maxGap_sort(vector<int>& arr)
    {
        if (arr.empty())
            return 0;
        sort(arr.begin(), arr.end(), less<int>());
        int maxGap = INT_MIN;
        for (int i = 0; i < arr.size() - 1; i++)
            maxGap = max(maxGap, arr[i + 1] - arr[i]);
        return maxGap;
    }

    // 2. 算法
    int maxGap(vector<int>& arr)
    {
        if (arr.empty())
            return 0;
        // 首先统计原数组的最大最小值
        int arrMax = INT_MIN;
        int arrMin = INT_MAX;
        for (int i = 0; i < arr.size(); i++)
        {
            arrMax = max(arrMax, arr[i]);
            arrMin = min(arrMin, arr[i]);
        }
        if (arrMax == arrMin)
            // 两者相等，说明数组中的所有数都相同，直接返回差值为 0
            return 0;
        // 表示原数组的维度
        int N = arr.size();
        // 表示各个桶内的最大值和最小值，因为有 N + 1 个桶，所以初始化 N + 1 维的数组
        vector<int> maxs(N + 1, INT_MIN);
        vector<int> mins(N + 1, INT_MAX);
        // 用于指示各个桶是否有元素进入
        vector<bool> havingGotIn(N + 1, false);
        for (int i = 0; i < arr.size(); i++)
        {
            // 计算当前数应该放进哪个桶
            int bucket = bucketNumber(arrMax, arrMin, N, arr[i]);
            // 如果当前桶还没有元素进入，直接更新最大最小值
            if (!havingGotIn[bucket])
            {
                maxs[bucket] = arr[i];
                mins[bucket] = arr[i];
                havingGotIn[bucket] = true;
            }
            else
            {
                maxs[bucket] = max(arr[i], maxs[bucket]);
                mins[bucket] = min(arr[i], mins[bucket]);
            }
        }
        // 然后查出各个桶中的最大最小值即可（有值的桶）
        int result = INT_MIN;
        // 因为第一个桶和最后一个桶里面必然有元素
        int preMax = maxs[0];
        for (int i = 1; i < havingGotIn.size(); i++)
        {
            if (havingGotIn[i])
            {
                // 如果当前桶不是空的，则进来更新数据
                result = max(result, mins[i] - preMax);
                preMax = maxs[i];
            }
        }
        return result;
    }

    int bucketNumber(const int& max, const int& min, const int& N, const int& cur)
    {
        // 这里的 N 是原数组的维度，也代表我们准备的范围数目
        // 其实按照比例关系，我们现在应该是有两条成比例的，但范围不同的横坐标线
        // 但是由于桶只能是整数，且间距为 1，所以其末端点 - 初端点 = 范围数，也就是原数组的维度
        // 而最终 cur 所属的桶还应加上第一个桶的下标，此处为 0，所以表达式如下
        return N * (cur - min) / (max - min);
    }
}
void main()
{
	for (int i = 0; i < 10; i++)
	{
		vector<int> arr = RandVector(1, 10000, 50, 1);
		cout << "The max gap by sort method is: " << MaxGap::maxGap_sort(arr) << ", ";
		cout << "the max gap by bucket method is: " << MaxGap::maxGap(arr) << endl;
	}
	system("pause");
}
```

## 1.2 最多异或 0 分割法

**[题目]** 给出 n 个数字，问**最多**有多少不重叠的非空区间（以某一种切分方法，将原数组切分为若干个区间），使得每个区间内数字的 xor （所有数按位异或）都等于 0。

**解题思路：**以最后一个位置为结尾的情况下，能够满足题意的最优解法。这道题的核心在于，如果数组 arr 的所有数的按位异或结果是 a，那么从 0 ~ (i - 1)位置的数的异或如果也是 a，必然有 i ~ (N - 1) 的异或结果为 0。根据这个结论我们可以分类，分为 i 位置元素与前面元素组成 xor0 区间以及 i 位置元素不与前面元素组成 xor0 区间。而对于第一种情况，我们要首先确定当前 i 位置是否能与前面元素形成 xor0 区间，实际上，如果从 0 开始到 0 ~ (i - 1) 结束的范围内有任何区间的异或结果等于当前 0 ~ i 位置的异或结果，那么说明必然存在至少一种分割方法，使得以 i 位置字符为结尾的划分子数组可以出现异或结果为 0。并且容易证明，如果有一种划分，能够使得在以最后一个字符作为结尾形成 xor0 区间的前提下，使当前区间划分结果得到的 xor0 区间数目最多，该区间必然是可以以 i 位置作为右边界能够形成 xor0 区间中的最小的那一个（最近的左边界）。

``` c plus
// === 最大 xor0 区间问题 === //
namespace MostXoR
{
    // 1. 对数器
    int mostXoR_brutal(const vector<int>& arr)
    {
        if (arr.size() == 0) {
            return 0;
        }
        vector<int> eors(arr.size(), 0);
        int eor = 0;
        for (int i = 0; i < arr.size(); i++) {
            eor ^= arr[i];
            eors[i] = eor;
        }
        vector<int> mosts(arr.size(), 0);
        mosts[0] = arr[0] == 0 ? 1 : 0;
        for (int i = 1; i < arr.size(); i++) {
            mosts[i] = eors[i] == 0 ? 1 : 0;
            for (int j = 0; j < i; j++) {
                if ((eors[i] ^ eors[j]) == 0) {
                    mosts[i] = max(mosts[i], mosts[j] + 1);
                }
            }
            mosts[i] = max(mosts[i], mosts[i - 1]);
        }
        return mosts[mosts.size() - 1];
    }

    // 2. 算法
    int mostXoR(const vector<int>& arr)
    {
        if (arr.empty())
            return 0;
        int curXor = 0;
        vector<int> dp(arr.size(), 0);
        // 这个 hash 表的 key 表示 从 0 ~ 当前遍历位置的可能出现的异或结果，value 表示离遍历位置最近的出现位置
        unordered_map<int, int> hash;
        // 表示在 -1 位置的异或结果为 0，可以处理第一次在 0 ~ i 上的异或结果为 0 的时候的情况
        // 因为如果当前整体第一次形成了异或结果为 0，则此时一定可以形成一个 xor0 的划分区间，这和其它异或结果一定要“配对”的形式还不太一样
        hash.insert(make_pair(0, -1));
        for (int i = 0; i < arr.size(); i++)
        {
            curXor ^= arr[i];
            if (hash.find(curXor) != hash.end())
            {
                int location = hash[curXor];
                // 当前位置的最大 xor0 区间数“可能”是“配对位置”的最大 xor0 区间数 + 1
                // 或者如果是第一次整体形成 xor 结果为 0，其并不需要配对，则利用到我们设置的初始情况
                dp[i] = location == -1 ? 1 : dp[location] + 1;
            }
            if (i > 0)
                // 这一句话包含了两种情况两种选择
                dp[i] = max(dp[i - 1], dp[i]);
            hash[curXor] = i;
        }
        return *dp.rbegin();
    }
}
void main()
{
	for (int i = 0; i < 20; i++)
	{
		vector<int> arr = RandVector(1, 10, 100, 1);
		cout << "The most XOR is (brutal): " << MostXoR::mostXoR_brutal(arr) << ", ";
		cout << "The most XOR is (algorithm): " << MostXoR::mostXoR(arr) << endl;
	}
	system("pause");
}
```

## 1.3 K 和问题

**[题目]** 给定一个数组 arr，该数组无序，但每个值都是正数，再给定一个正数 k。求 arr 的所有**子数组**中所有元素相加和为 k 的最长子数组长度。

**例如：**arr = [1, 2, 1, 1, 1]，k = 3，那么累加和为 3 的最长子数组的长度为 3。要求时间复杂度 $O(N)$，额外空间复杂度 $O(1)$。

**解题思路：**用两个指针维护一个窗口，如果当前窗口内的 sum 比目标 k 大，则左指针右移，否则右指针右移，而这样做的原理在于此时数组中的值都是正数，所以边界右扩必然导致窗口的 sum 变大，所以当 sum 比 k 大，我们不必考虑窗口右扩使得 sum 变小并满足条件的可能性。

``` c plus
// 问题1. 无序正数数组找元素和为 K 的最长子数组
// 暴力法
int problem12_brutal(const vector<int>& arr, const int& K)
{
    if (arr.empty() || K < 0)
        return 0;
    int result = 0;
    for (int i = 0; i < arr.size(); i++)
    {
        int sum = 0;
        for (int j = i; j < arr.size(); j++)
        {
            sum += arr[j];
            if (sum == K)
                result = max(result, j - i + 1);
        }
    }
    return result;
}
int problem1(const vector<int>& arr, const int& K)
{
    if (arr.empty() || K < 0)
        return 0;
    // 表示当前的指针维护的区间为 [left, right]
    int left = 0;
    // 左大于右表示当前维护区间没有元素
    int right = -1;
    int curSum = 0;
    int result = 0;
    // 在 right = size - 1 的时候，此时说明已经把数组中最后一个元素扩张到窗口中了，此时继续循环有越界风险
    // 左边界只可能出现比右边界向右多一个的情况，仔细一想，不可能会出现左边界踩线的情况，所以可以删除
    while (right < int(arr.size() - 1))
    {
        if (curSum < K)
            // 小于的情况则窗口右边界移动
            curSum += arr[++right];
        else if (curSum == K)
        {
            // 等于的情况则记录当前数组长度，并仅将右边界向右移动，如此这个算法可以适配含有 0 的数组
            // 如果明确告知数组中全是正数，则这里可以将左右边界均向右移动
            result = max(result, right - left + 1);
            curSum += arr[++right];
        }
        else
            // 大于的情况则左窗口向右移动，这里 left++ 是因为要减去的是窗口内的数字
            // 而其它两种情况 ++right 是要扩张窗口外的数字
            curSum -= arr[left++];
    }
    // 如果由于某一操作过后，右边界 right 到达 arr.size() - 1 了，此时必然是因为窗口内的 sum 小于等于 K
    // 则只需要判断当前是否需要计入最后一次操作即可，因为后续在移动左边界也必然不会得到更好的结果
    if (curSum == K)
        result = max(result, right - left + 1);
    return result;
}
void main()
{
	int K = 500;
	for (int i = 0; i < 20; i++)
	{
		vector<int> arr = RandVector(0, 50, 500, true);
		cout << "Result(brutal): " << KSumProblem::problem12_brutal(arr, K) << ", ";
		cout << "result(optimization): " << KSumProblem::problem1(arr, K) << endl;
	}
	system("pause");
}
```

**[推广1]** 给定一个数组 arr，该数组无序，且每个值可能是任意整数，再给定一个数 k。求 arr 的所有**子数组**中所有元素相加和为 k 的最长子数组长度。

**解题思路：**很 easy，用一张哈希表记录每一种前缀和第一次出现的位置，那么只要在遍历过程中，在当前位置的前缀和与哈希表中任意前缀和之差等于 k，说明以当前位置为结尾能够形成一种累加为 k 的最长子数组，收集整个过程中的最长子数组长度即可。

``` c plus
// 问题2. 无序整数数组找元素和为 K 的最长子数组
int problem2(const vector<int>& arr, const int& K)
{
    if (arr.empty())
        return 0;
    unordered_map<int, int> hash;
    // 表示其实指针在 -1 位置的时候，对应的前缀累加和为 0
    hash[0] = -1;
    int curSum = 0;
    int result = 0;
    for (int i = 0; i < arr.size(); i++)
    {
        curSum += arr[i];
        int dest = curSum - K;
        if (hash.find(dest) != hash.end())
            // 可以想象，这里是不需要 + 1 的
            result = max(result, i - hash[dest]);
        if (hash.find(curSum) == hash.end())
            // hash 表中维护的是第一次出现（最早出现的前缀和及其位置），所以只有当前缀和没有进入过 hash 表的时候才推入结果
            hash[curSum] = i;
    }
    return result;
}
void main()
{
	int K = -500;
	for (int i = 0; i < 20; i++)
	{
		vector<int> arr = RandVector(-50, 50, 500, true);
		cout << "Result(brutal): " << KSumProblem::problem12_brutal(arr, K) << ", ";
		cout << "result(optimization): " << KSumProblem::problem2(arr, K) << endl;
	}
	system("pause");
}
```

**[推广2]** 给定一个数组 arr，该数组无序，且每个值可能是任意整数，再给定一个数 k。求 arr 的所有**子数组**中所有元素相加和为小于等于 k 的最长子数组长度。

**解题思路：**给两个数组，从最后一个位置向前构造，首先是 mins，其内容含义为：以 i 位置元素作为开头能够构造的子数组中，最小的元素和；然后是 pos，其内容含义为：以 i 位置元素为开头构造的最小元素和中的最长子数组对应的最后一个位置**（值得考虑是，这里明显应该拿的是最长子数组的最后一个位置，当然，取第一个位置也是不错的，只是会多做几次操作）**。然后从头遍历构造的数组，如果 mins[i + m + n...] 的 sum 比 k 小，则右边界向右扩张（根据 pos 数组进行扩张，因为 mins 中维护的是最小和子数组，所以以这个数组为基准都扩不成功，则一定无法以当前 i 起头找到和小于 k 的子数组），但关键在于，如果当前 mins[i + m + n...] 的 sum 比 k 大，此时说明已经求得了以 i 位置为开头的最长小于 k 和数组，此时要同时将左边界和右边界向右扩张，因为左边界是必然向右扩张 1 的，而扩张左边界却回退右边界必然不能得到一个更好的结果，如此以来，在遍历过程中左右边界均不回退，则构造了一个时间复杂度较低的算法。

``` c plus
// 遍历即可
int problem3_brutal(const vector<int>& arr, const int& K)
{
    if (arr.empty())
        return 0;
    int result = 0;
    for (int i = 0; i < arr.size(); i++)
    {
        int sum = 0;
        for (int j = i; j < arr.size(); j++)
        {
            sum += arr[j];
            if (sum <= K)
                result = max(result, j - i + 1);
        }
    }
    return result;
}
// 问题3. 无序整数数组找元素和小于等于 K 的最长子数组
int problem3(const vector<int>& arr, const int& K)
{
    vector<int> mins(arr.size(), 0);
    vector<int> pos(arr.size(), 0);
    // 最后一个位置没有选择
    *mins.rbegin() = *arr.rbegin();
    *pos.rbegin() = arr.size() - 1;
    for (int i = arr.size() - 2; i >= 0; i--)
    {
        mins[i] = arr[i] + (mins[i + 1] <= 0 ? mins[i + 1] : 0);
        pos[i] = mins[i + 1] <= 0 ? pos[i + 1] : i;
    }
    int result = 0;
    int end = 0;
    int sum = 0;
    for (int i = 0; i < arr.size(); i++)
    {
        // 也算是吃一堑长一智吧，如何防止滞后判断，在判断里面把下一次的值加上不就好了
        // 但有的地方不能这样写，所以要考虑清楚
        // 这个地方的判断真的很巧妙的，虽然也算不上吧，但真的可以完美适配问题
        while (end < arr.size() && sum + mins[end] <= K)
        {
            sum += mins[end];
            end = pos[end] + 1;
        }
        result = max(result, end - i);
        if (end > i)
            // 窗口中还有数，这一步代表当前要进行下一个位置最长数组的求取
            sum -= arr[i];
        else
            // 这个情况仅限于最开始的时候，因为当前写法完全不存在右边界的回退，所以右边界不可能退到 i 以前
            // 目标数为负数但是第一个位置最小和为正数的时候，那么此时相当于完全从第二个位置开始重新搞
            end = i + 1;
    }
    return result;
}
void main()
{
	int K = -100;
	for (int i = 0; i < 50; i++)
	{
		vector<int> arr = RandVector(-50, 50, 50, true);
		int result_brutal = KSumProblem::problem3_brutal(arr, K);
		int result_optimization = KSumProblem::problem3(arr, K);
		cout << "Result(brutal): " << result_brutal << ", ";
		cout << "result(optimization): " << result_optimization << endl;
		if (result_brutal != result_optimization)
			cout << "Not right!" << endl;
	}
	system("pause");
}
```



# 2. 其它问题

## 2.1 硬币拼面值

**[题目]** 现有 n1 + n2 种面值的硬币，其中前 n1 种为普通币，可以取任意枚，后 n2 种为纪念币**每种最多**只能取一枚，每种硬币有一个面值，同能用多少种方法拼出 m 的面值？

**解题思路：**其实就是将 m 分成两部分，此消彼长，分别让两部分分给 n1 和 n2 来凑，把结果乘和即可。其实就是两个动态规划问题。主要是涉及到了一个**斜率优化**的问题，看下面图就懂：

<img src="C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230526165721732.png" alt="image-20230526165721732" style="zoom:80%;" />

``` c plus
// === 货币凑数问题 === //
namespace MoneyWays
{
    // 主调函数
    int method(const vector<int>& arbitrary, const vector<int>& only, const int& money, const bool& ifOptimization)
    {
        if (arbitrary.empty() && only.empty())
            // 两种都为空才直接返回 0
            return 0;
        // 处理两种特殊情况
        try
        {
            getArbDP(arbitrary, money, ifOptimization);
        }
        catch (const int& number)
        {
            return getOnlyDP(only, money)[only.size() - 1][money];
        }
        try
        {
            getOnlyDP(only, money);
        }
        catch (const int& number)
        {
            return getArbDP(arbitrary, money, ifOptimization)[arbitrary.size() - 1][money];
        }
        auto arbDp = getArbDP(arbitrary, money, ifOptimization);
        auto onlyDp = getOnlyDP(only, money);
        ShowMatrix(arbDp);
        cout << endl;
        ShowMatrix(onlyDp);
        int result = 0;
        for (int i = 0; i <= money; i++)
            result += arbDp[arbitrary.size() - 1][i] * onlyDp[only.size() - 1][money - i];
        return result;
    }
    // 普通货币的 dp 表
    vector<vector<int>> getArbDP(const vector<int>& arbitrary, const int& money, const bool& ifOptimization)
    {
        // 如果传入的 arbitrary 数组为空，意为我们的 money 全部用 only 来凑，此时返回 1，不影响结果
        if (arbitrary.empty())
            throw 1;
        // dp[i][j] 的含义是用 0 ~ i 的货币达到目标数 j 的方法数 
        vector<vector<int>> dp(arbitrary.size(), vector<int>(money + 1, 0));
        // 第一列元素，表示目标 money 为 0 的情况下，方法数为 1
        for (int i = 0; i < arbitrary.size(); i++)
            dp[i][0] = 1;
        // 第一行元素，表示仅用 0 ~ 0 上货币的方法数
        for (int i = 1; arbitrary[0] * i < money + 1; i++)
            // 如果刚好用 i 张货币 arbitrary 可以凑齐 money，对应位置置为 1
            dp[0][arbitrary[0] * i] = 1;
        // 递推关系，可以想到，在要采用 i 货币的时候，此时构建的 dp[i][j] 为 Sigma(dp[i - 1][j - k * arbitrary[i]])
        // 相当于 dp 其实只依赖于其上一行的元素，这里可以作斜率优化
        for (int i = 1; i < arbitrary.size(); i++)
            for (int j = 1; j <= money; j++)
                if (!ifOptimization)
                    for (int k = 0; k * arbitrary[i] <= j; k++)
                        dp[i][j] += dp[i - 1][j - k * arbitrary[i]];
                else
                    // 斜率优化版本
                    dp[i][j] = dp[i - 1][j] + (j - arbitrary[i] >= 0 ? dp[i][j - arbitrary[i]] : 0);
        return dp;
    }
    // 特殊货币的 dp 表
    vector<vector<int>> getOnlyDP(const vector<int>& only, const int& money)
    {
        // 如果传入的 only 数组为空，意为我们的 money 全部用 arbitrary 来凑，此时返回 1，不影响结果
        if (only.empty())
            throw 1;
        vector<vector<int>> dp(only.size(), vector<int>(money + 1, 0));
        for (int i = 0; i < only.size(); i++)
            dp[i][0] = 1;
        // 由于对特殊货币而言，其每种货币只能拿一个，所以明显的，在只使用第一种货币的情况下，只有其对应面额的那个 money 的对应 dp 可以被置为 1
        if (only[0] <= money)
            dp[0][only[0]] = 1;
        // 递推关系，可以想到，在要采用 i 货币的时候，此时构建的 dp[i][j] 为 dp[i - 1][j - k * only[i]]，但是这里的 k 只能取 0 或者 1
        for (int i = 1; i < only.size(); i++)
            for (int j = 1; j <= money; j++)
                // 只用考虑选择或者不选择 only[i]
                dp[i][j] = dp[i - 1][j] + ((j - only[i] >= 0) ? dp[i - 1][j - only[i]] : 0);
        return dp;
    }
}
void main()
{
	// 1. 2_1 × 5
	// 2. 2_1 × 3 + 4_2
	// 3. 5_1 × 2
	// 4. 5_1 + 5_2
	// 5. 2_1 + 3_1 + 5_1
	// 6. 2_1 + 3_1 + 5_2
	// 7. 3_1 × 2 + 4_2
	// 8. 2_1 × 2 + 3_1 × 2
	vector<int> arb{ 2, 3, 5 };
	vector<int> only{ 4, 5 };
	int dest = 10;
	cout << "The money ways is(non optimized): " << MoneyWays::method(arb, only, dest, false) << endl;
	cout << "The money ways is(optimized): " << MoneyWays::method(arb, only, dest, true) << endl;
	system("pause");
}
```

## 2.2 循环去除节点问题

**[题目]** 某公司招聘，有 n 个人入围，HR 在黑板上依次写下 m 个正整数 A1、A2、....、Am，然后让这 n 个人围成一个圈，并按照顺时针顺序为他们编号 0、1、2、...、n - 1。录取规则是：第一轮从 0 号的人开始，取用黑板上的第 1 个数字，也就是 A1。黑板上的数字按次序循环取用，即如果某轮用了第 m 个，则下一轮需要用第 1 个；如果某轮用到第 k 个，则下轮需要用第 k + 1 个 (k < m)。每一轮按照黑板上的次序取用到一个数字 A×，淘汰掉从当前轮到的人开始按照顺时针顺序数到的第 Ax 个人**（从 1 开始到 Ax）**，下一轮开始时轮到的第一个人即为被淘汰掉的人的顺时针顺序下一个人。
被淘汰的人直接回家，所以不会被后续轮次计数时数到。
经过 n - 1 轮后，剩下的最后 1 人被录取，所以最后被录取的人的编号与（n, m, A1, A2, ....., Am）相关。

**输入描述：**
第一行是一个正整数 N，表示有 N 组参数，从第二行开始，每行有若干个正整数，依次存放 n、m、A1、.....、Am，一共有 N 行，也就是上面的 N 组参数。

**输出描述：**
输出有 N 行，每行对应相应的那组参数确定的录取之人的编号。

**示例：**
**输入：**
1
4 2 3 1
**输出：**
1

**算法原型：**一个环形的链表，在每一轮开始的时候，为开始的节点分配编号 1，然后依次顺时针旋转并给各个节点分配递增的编号，然后从编号 1 的节点开始数数，当某个节点数到对应给定数 m 的时候，除去该节点，而下一轮从该节点的下一个节点开始重新进行，最终取剩下来的那个节点。

​		倒过来看这个过程，主要看我们能否找到一个函数，输入给它最终活下来的节点在当前轮次中的编号（在最后一轮的编号自然是 1）以及当前轮次存在的节点数，它能够给我们返回该节点在上一轮次的编号。

1. 首先找在一轮中，以当前轮的节点编号分配情况下，各个节点的数数结果，然后可以建立编号和数之间的函数关系，如下图所示

![image-20230527170435228](C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230527170435228.png)

这个关系非常明显，如果令编号为 s，数为 v，并令当前轮的节点数目为 m，那么 s 和 v 的关系为
$$
s=(v - 1)\ \% \ m \ +1
$$
当然，如果我们说开始节点的编号为 0，而数从 1 开始数，那么此时 s 和 v 的关系为
$$
s=(v-1)\ \%\ m
$$
所以可以看出，纵向位移对应于起始节点编号。

2. 然后，就是推导在某一轮次删除节点 s 的情况下，原节点编号和新节点编号之间的对应关系，比如：

$$
1 \ 2 \ 3 \ 4 \ 5 \ 6 \ 7 \ 8\\
5 \ 6 \ 7 \ x  \ 1 \ 2 \ 3 \ 4
$$

这个地方倒是正儿八经可以先考虑剃刀函数，如下图所示

<img src="C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230527172956028.png" alt="image-20230527172956028" style="zoom: 80%;" />

这样来看，确实还是延长到左边最好，值得注意的是，判断这种函数到底模的是多少，只需要看其一个完整的周期中，横坐标的跨越范围长度，如上图所示的情况，其明显模的是 (4 + 3 + 1 = 8)，即原节点的个数。而横向位移明显是左 3，纵向位移明显是上 1，即表达为
$$
old = (new + s - 1) \ \%\ m \ + \ 1
$$
那么如果我们在上一轮中要求是报号到 v 的时候除去节点，则上一轮各个节点的编号和该轮节点编号的最终关系为
$$
old = (new + (v - 1)\ \% \ m \ +1 - 1) \ \%\ m \ + \ 1
$$
而由于对于模运算来说，多次模和模一次明显是一样的，所以最终结果为
$$
old = (new + v - 1) \ \%\ m \ + \ 1
$$
 到这一步，我们就知道了，只要给定初始的节点个数以及除去节点的报号 v，就能够通过递归的方法在初始状态下计算出当前节点中哪个节点会最终存活。 

``` c plus
// 方便起见，直接使用链表的节点
// 问题 1，表示算法原型
// 对数器，暴力求解
Node* JosephusKill1_brutal(Node* head, const int& m)
{
    // 如果给出的循环列表为空，或者仅有一个节点，或者目标号数 m 小于 1，则直接返回当前头结点
    if (head == NULL || head->next == head || m < 1)
        return head;
    Node* last = head;
    // 找到回到头结点之前的那一个节点，把它看作最后一个节点
    while (last->next != head)
        last = last->next;
    int count = 0;
    // 这个循环是这样实现原问题的：
    // 用 last 指针表示当前遍历节点的上一个节点，head 表示当前遍历到的节点
    // 正常情况下，在一轮遍历中，last 指针移向其下一个节点，那么 head 指针只需要指向 last 指针指向新节点的下一个节点就能同时完成移动
    // 而在完成一轮遍历的时候，只需要将当前 last 指向当前 head 的 next，就能够删除当前 head
    // 最终，当仅剩一个节点的时候，自然 head == last，则达到最终的目的，退出循环并返回当前节点
    while (head != last)
    {
        // head 对应的是每一轮开始时候的节点
        if (++count == m)
        {
            // 如果数到了对应号数，则将上一个节点的 next 指向当前节点的下一个节点，代表删除当前节点
            last->next = head->next;
            delete head;
            count = 0;
        }
        else
            // last 向后移动
            last = last->next;
        // head 通过 last 的后移也向后移
        head = last->next;
    }
    return head;
}
Node* JosephusKill1_optimization(Node* head, const int& m)
{
    if (head == NULL || head->next == head || m < 1)
        return head;
    int count = 0;
    Node* cur = head;
    while (cur->next != head);
    {
        // 用于统计当前循环链表有多少个节点
        count++;
        cur = cur->next;
    }
    // 计算出在 count 个节点情况下，数号 m 情况下对应当前轮次节点的编号
    int number = getLive1(count, m);
    count = 0;
    while (count++ < number)
        // 一直向下指，直到达到目标序号
        head = head->next;
    return head;
}
// 问题 1 对应的新旧节点编号计算公式
int getLive1(const int& i, const int& m)
{
    if (i == 1)
        // 如果仅剩一个节点，那么此时自然它的编号为 1
        return 1;
    // getLive1(i - 1, m) 返回的就是 i - 1 个节点对应轮次下，数号为 m 的节点编号，即新节点编号
    // 这个递归调用得还挺特别的
    return (getLive1(i - 1, m) + m - 1) % i + 1;
}
void main()
{
	JosephusProblem::Node* head1 = new JosephusProblem::Node(1);
	head1->next = new JosephusProblem::Node(2);
	head1->next->next = new JosephusProblem::Node(3);
	head1->next->next->next = new JosephusProblem::Node(4);
	head1->next->next->next->next = new JosephusProblem::Node(5);
	head1->next->next->next->next->next = head1;
	JosephusProblem::Node* result1 = JosephusProblem::JosephusKill1_brutal(head1, 5);

	JosephusProblem::Node* head2 = new JosephusProblem::Node(1);
	head2->next = new JosephusProblem::Node(2);
	head2->next->next = new JosephusProblem::Node(3);
	head2->next->next->next = new JosephusProblem::Node(4);
	head2->next->next->next->next = new JosephusProblem::Node(5);
	head2->next->next->next->next->next = head2;
	JosephusProblem::Node* result2 = JosephusProblem::JosephusKill1_brutal(head2, 5);
	// 然后看看最后留下的节点是否一致：
	cout << "By brutal: " << result1->data << ", by optimization: " << result2->data << endl;
	system("pause");
}
```

**解题思路：**只是根据算法原型，将每一轮的报号目标数 v 进行修改罢了，这其中有一层非常微妙的原理，即原型算法中，每一轮中本人的编号其实是完全不重要的，按照算法原型算出来的人的编号，不过是表示当前轮次下，以某个起始点为准数起的第几个节点会最终被保留，所以原型算法中，人的编号这个概念，其实完全可以看作是引入的一个建立轮次之间关系的辅助记号而已，所以原型算法的问题可以如此描述：给定 n 个人，任选一个人为起始，从 1 开始叫号，每次叫号到 m，将叫号人杀死，从被杀死者的下一个人开始从 1 开始重新叫号，直至只剩一人。那么我们完全只需要按照原型算法计算，然后返回结果 - 1 即可。

``` c plus
// 问题 2，表示该问题，n 表示初始有多少个节点（人），原题中给出一个 m，其实没必要，因为从 As 我们就能知道对应有效参数的个数
int JosephuKill2(const int& n, const vector<int>& As)
{
    if (n < 2 || As.empty())
        return 0;
    // 计算出在 count 个节点情况下，数号 m 情况下对应当前轮次节点的编号
    int number = getLive2(n, As, 0);
    return number - 1;
}
int getLive2(const int& i, const vector<int>& As, const int& m)
{
    if (i == 1)
        // 问题中，节点编号从 0 开始，则 base case 返回 0
        return 1;
    // 根据题意，新一轮次使用的都是 As 数组中的下一个数字
    // 先用当前轮次应该使用的 m 计算出实际数组中应该取用的 index
    int index = m % As.size();
    // 然后在计算新一轮的节点编号的时候，将 index + 1
    return (getLive2(i - 1, As, index + 1) + As[index] - 1) % i + 1;
}
void main()
{
	cout << JosephusProblem::JosephuKill2(10, vector<int>{3, 1})<<endl;
	system("pause");
}
```

## 2.3 双数组 TopK 问题

**[题目]** 给定两个一维 int 数组 A 和 B 其中：A 是长度为 m、元素从小到大排好序的有序数组。B 是长度为 n、元素从小到大排好序的有序数组。希望从 A 和 B 数组中，找出第 k 小的数字，要求：使用尽量少的比较次数。

**解题思路1：**分别给 A 和 B 的头部放一个指针，谁小谁移动，每次比如第 i 次移动之前记录当前要移动的指针的位置，它就是第 i 小的数。该方法的时间复杂度为 $O(K)$。

``` c plus
// 方法1. 双指针直接求法
int method_doublePointer(const vector<int>& arr1, const vector<int>& arr2, const int& K)
{
    if (arr1.empty() && arr2.empty())
        return -1;
    if (arr1.empty())
        return arr2[K - 1];
    if (arr2.empty())
        return arr1[K - 1];
    int curIndex = 0;
    int result = 0;
    int startIndex1 = 0;
    int startIndex2 = 0;
    while (curIndex++ < K)
    {
        if (arr1[startIndex1] <= arr2[startIndex2])
            result = arr1[startIndex1++];
        else
            result = arr2[startIndex2++];
    }
    return result;
}
```

**解题思路2：**二分方法，其实就是找某一个数字，它比最小的 k - 1 个数字大，那么比如从 A 中找出上中位数 d，其必然比 A 中的 (m - 1) / 2 个数字大，然后在 B 数组中用二分法找出该数，当然，此时第二个数组中可能没有该数，但是可以找到数组中第一个比它大的数，此时通过下标可以算出它在 B 中是第几大（比如 h + 1），那么现在我们就能知道该数 d 比 A 和 B 中一共 (m - 1)/ 2 + h  个大，然后看这个数和 k - 1 的关系，如果它比 k - 1 大，说明当前的数太大，则在 A 中向前二分，如果它比 k - 1 小，则说明当前数太小，则在 A 中向后二分，而如果最终没有办法二分出 k - 1，说明 A 和 B 的 TopK 数不在 A 中，则同样的过程在 B 数组中执行一遍即可。该方法的时间复杂度为 $O(logm \times logn)$。

``` c plus
// 方法2. 二分方法
int method_binarySearch(const vector<int>& arr1, const vector<int>& arr2, const int& K)
{
    if (arr1.empty() && arr2.empty())
        return -1;
    if (arr1.empty())
        return arr2[K - 1];
    if (arr2.empty())
        return arr1[K - 1];
    int result = process_binarySearch(arr1, arr2, K);
    result = result == -1 ? process_binarySearch(arr2, arr1, K) : result;
    return result;
}
// 方便调换数组的方向，如果一个数组中没有 TopK，则返回 -1
int process_binarySearch(const vector<int>& A, const vector<int>& B, const int& K)
{
    int M = A.size();
    int N = B.size();
    // 当前从 A 中取出的中位数在整体数组中属于第 (mid - 1)/2 + posInB(index) + 1 小
    // 那么现在我们要写一个函数，它可以返回在一个数组中指定范围内，用二分法找出地板位置（最大的地板位置）
    // 比如 {1, 2, 3, 3}，我们找 3 的话，希望它返回的是位置 3
    int LA = 0; int LB = 0;
    // 注意，是在数组 A 二分，然后在数组 B 去查找
    int RA = M - 1; int RB = N - 1;
    // midIndex 就是当前数在 A 中压住的数的个数
    int midIndex = (LA + RA) / 2;
    while (LA <= RA)
    {
        int destStackedNumber_inB = K - 1 - midIndex;
        if (destStackedNumber_inB < 0)
        {
            // 如果已经小于 0 了，说明结果必然不是当前 mid 数，说明它太大了，需要向前二分
            RA = midIndex - 1;
            midIndex = (LA + RA) / 2;
            // 直接进行下一次循环
            continue;
        }
        // biggestFloorPosition 返回的是当前 mid 数在 B 中的最大 floor key 位置
        // 首先，如果它返回 -1，说明当前 mid 数在 B 中压不住任何数，刚好 + 1 = 0，没有问题
        // 然后，它有可能会压住很多个相同的数字
        int position_inB =  biggestFloorPosition(B, LB, RB, A[midIndex]);
        int stackedNumber_inB = position_inB + 1;
        if (stackedNumber_inB == destStackedNumber_inB)
            // 说明已经找到了，则返回对应数字
            return A[midIndex];
        else if (stackedNumber_inB > destStackedNumber_inB)
        {
            // 此时说明压住的数过于多，但有可能是由于压住了很多个相同的数，所以我们可以做一步检查
            // 检查的方法就是，直接看 B 中目标位置上的数是不是和 mid 数相等，如果是，则直接返回 mid 数，否则向前二分
            if (position_inB != -1 && B[position_inB] == A[midIndex] && B[destStackedNumber_inB] == A[midIndex])
                return A[midIndex];
            // 否则说明确实是数太大（数相等的情况是可以判断出来的），向前二分
            RA = midIndex - 1;
            // + 1 没有问题，按照我们的原理，这样不会舍掉可能比新的 mid 数大的数
            RB = position_inB + 1;
        }
        else
        {
            // 向后二分，因为就算把 B 中的所有重复数都算上此时数都还是少了，说明确实是当前 mid 数太小
            LA = midIndex + 1;
            // 还是要 + 1，不加 1 的话可能会舍掉比新 mid 数大的数（主要是针对新 mid 数和老 mid 数相同的情况）
            LB = position_inB + 1;
        }
        midIndex = (LA + RA) / 2;
    }
    // 说明最终也没有找到，则返回 -1
    return -1;
}
// 找出最大的 floor 位置
int biggestFloorPosition(const vector<int>& arr, const int& startIndex, const int& endIndex, const int& dest)
{
    // 如果没有更新，说明当前数组中，没有任何数比给定数大，则最终应该返回 arr 最后一个位置
    int resultIndex = -1;
    // 首先通过二分查找找出数组中第一个大于（不能等于，必须大于） dest 的数
    int midIndex = (startIndex + endIndex) / 2;
    int L = startIndex;
    int R = endIndex;
    while (L <= R)
    {
        if (arr[midIndex] > dest)
        {
            // 应该向前二分
            resultIndex = midIndex;
            R = midIndex - 1;
        }
        else
            // 向后二分，且不记录 index
            L = midIndex + 1;
        midIndex = (L + R) / 2;
    }
    // 值得注意的是，如果数组中的所有数都比 dest 大，那么此时的 resultIndex 应该是 0，则最终返回 -1，此时在函数外也可以进行对应处理
    resultIndex = resultIndex == -1 ? arr.size() - 1 : resultIndex - 1;
    return resultIndex;
}
```

**解题思路3：**

**算法原型：**上中位数表示偶数个元素的数组中，中间靠前的那个元素。然后，如果现在有两个长度相同的数组，求它们整体的上中位数的方法为：

1. 如果两个数组的长度为偶数（单数组的上中位数下标为 N / 2 - 1，**或者用最后一个数的下标 / 2**），则先看两个数组的上中位数是否相同，如果相同直接返回；如果不同则看谁的上中位数比较大，取大上中位数数组的前 N / 2 个数和小上中位数数组的后 N / 2 个数递归求解上中位数，子数组的上中位数就是整体数组的上中位数**（如下图所示，蓝色是有可能取到的情况）**；

<img src="C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230527160722916.png" alt="image-20230527160722916" style="zoom: 50%;" />

2. 如果两个数组的长度为奇数（但数组的中位数下标为 N / 2，**或者用最后一个数的下标 / 2**），则先看两个数组的中位数是否相同，如果相同直接返回；如果不同看谁的上中位数比较大，此时大中位数数组的前 (N - 1) / 2 个数和小中位数数组的后 (N - 1) / 2  + 1 个数都有可能是整体的上中位数，但由于此时两个子数组的长度不等，所以把小中位数数组的中位数 dest 拿出来和大中位数数组的中位数往前一个数比较，如果 dest 较大，此时明显其压住了目标个数，则其就是整体上中位数，否则舍掉它，那么此时两个子数组的长度相同，继续递归求解**（如下图所示，蓝色是有可能的取到的情况，但是实际上，我们可以不必判断图中的黄色块是否能够取到，而是直接把它划归到下一级的子数组中求解即可，这样也是不会错的，因为在子数组的求解中，黄色块的 3 也不可能被识别为子数组的上中位数）**。

<img src="C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230527160857077.png" alt="image-20230527160857077" style="zoom: 50%;" />

这个基本原型的时间复杂度为 $O(logN)$。

**具体解法：**分为 3 种情况：

1. 目标 K 长度比短数组的长度小**（小于等于）**，如下图

<img src="C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230527094857833.png" alt="image-20230527094857833" style="zoom:67%;" />

此时只有**蓝色框中的部分是有可能的**，那么我们只需要找出两个等长数组（长度为 K）的上中位数**（实际上对于长度为 m 的等长数组而言，它们整体的上中位数就是整体第 m 大的数）**，就可以找到最终整体数组的第 K 小的元素。

2. 目标 K 长度比长数组的长度大**（大于等于）**，如下图

<img src="C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230527095259949.png" alt="image-20230527095259949" style="zoom:67%;" />

此时只有蓝色框中的部分是可能的，但此时还不能直接去取这两个等长数组的上中位数，因为找出来的上中位数仅仅是 K - 1 小的数，比如上例，其能够压住 1 + 4 + 4，也就是第 10 大的数，所以这里需要手动判断 A2 和 B5，如果 A2 大于 B9，那么 A2 是目标结果，返回，否则 A2 不是，直接删除它，同理对 B5，如果它大于 A6，那么它是目标结果，否则不是，直接删除它，那么此时找出两长度为 4 的等长数组的上中位数，此时它就是第 2 + 5 + 4 小的数了。

3. 目标 K 长度比短数组的长度长**（大于）**，比长数组的长度小**（小于）**，如下图

<img src="C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230527100302002.png" alt="image-20230527100302002" style="zoom:67%;" />

此时只有蓝色框中的部分是可能的，但此时 B 中的可能数组长度比 A 中的多一个，所以还需要将 B 中的某个数字手动排除，不妨直接排除 B2，只需要判断其是不是大于 A6，如果是，则返回它，如果不是，则将他删除即可，则最终直接返回两个等长数组的上中位数即可。

``` c plus
// 方法3. 基于等长数组上中位数求法算法原型的方法
int method_median(vector<int>& arr1, vector<int>& arr2, const int& K, const bool& ifRC)
{
    if (K < 1)
        return -1;
    if (arr1.empty() && arr2.empty())
        return -1;
    if (arr1.empty())
        return arr2[K - 1];
    if (arr2.empty())
        return arr1[K - 1];
    int size1 = arr1.size();
    int size2 = arr2.size();
    vector<int>* longArray = size1 > size2 ? &arr1 : &arr2;
    vector<int>* shortArray = (longArray == &arr1 ? &arr2 : &arr1);
    int longSize = longArray->size();
    int shortSize = shortArray->size();
    if (K <= shortSize)
        // 最简单的情况，值得注意的是，如果两个数组的长度为 n，那么两个数组的上中位数就是整体数组的第 n 小的数
        return ifRC ? getUpMedian_RC(*longArray, 0, K - 1, *shortArray, 0, K - 1) : \
         getUpMedian_DR(*longArray, 0, K - 1, *shortArray, 0, K - 1);
    else if (shortSize < K && K < longSize)
    {
        // 比短数组长，比长数组短的情况，需要手动排除长数组中子数组的第一个元素
        // 还需要注意从哪一个位置开始，对短数组而言，全部位置都可能
        // 但对长数组而言，前 K - shortSize - 1 个元素是不可能的，所以其可能的第一个元素下标为 K - shortSize - 1
        // 以及从下标 K 开始的元素是不可能的（最后一个可能下标为 K - 1）
        if (longArray->at(K - shortSize - 1) >= *shortArray->rbegin())
            return longArray->at(K - shortSize - 1);
        else
            // 因为排除了 K - shortSize - 1 位置，所以从 K - shortSize 开始数
            return ifRC ? getUpMedian_RC(*longArray, K - shortSize, K - 1, *shortArray, 0, shortSize - 1) : \
            getUpMedian_DR(*longArray, K - shortSize, K - 1, *shortArray, 0, shortSize - 1);
    }
    else
        // 比长数组长，那么自然，对长短数组而言，其从 K - opositeSize - 1 开始，到数组结尾都有可能
        // 此外，由于此时求出来的上中位数是 K - 1 小，所以还需要手动判断两个数组 K - opositeSize - 1 数的情况
        if (longArray->at(K - shortSize - 1) >= *shortArray->rbegin())
            return longArray->at(K - shortSize - 1);
        else if (shortArray->at(K - longSize - 1) >= *longArray->rbegin())
            return shortArray->at(K - longSize - 1);
        else
            return ifRC ? getUpMedian_RC(*longArray, K - shortSize, longSize - 1, *shortArray, K - longSize, shortSize - 1) : \
            getUpMedian_DR(*longArray, K - shortSize, longSize - 1, *shortArray, K - longSize, shortSize - 1);
}

// 找出给定整体数组中某个范围内的子数组的上中位数，遵循解题逻辑的递归求法
int getUpMedian_RC(vector<int>& arr1, const int& start1, const int& end1,
    vector<int>& arr2, const int& start2, const int& end2)
{
    // 先计算两个数组的大小，奇数大小和偶数大小结果是不一样的
    int size1 = end1 - start1 + 1;
    int size2 = end2 - start2 + 1;
    if (size1 != size2)
        // 说明有问题，返回 -1
        return -1;
    if (size1 == 1)
        // 如果两个数组的长度为 1，此时直接进奇数数组判断下标会越界，故单独讨论
        return arr1[start1] <= arr2[start1] ? arr1[start1] : arr2[start2];
    // 这样取到的必然是上中位数，无论数组的长度奇偶
    int mid1 = (start1 + end1) / 2;
    int mid2 = (start2 + end2) / 2;
    // 相等的情况直接返回
    if (arr1[mid1] == arr2[mid2])
        return arr1[mid1];
    // 指向大中位数数组
    vector<int>* bigMidArr = (arr1[mid1] > arr2[mid2] ? &arr1 : &arr2);
    int bigMidStart = (bigMidArr == &arr1 ? start1 : start2);
    int bigMidEnd = (bigMidArr == &arr1 ? end1 : end2);
    int bigMid = (bigMidArr == &arr1 ? mid1 : mid2);
    // 指向小中位数数组
    vector<int>* smallMidArr = (bigMidArr == &arr1 ? &arr2 : &arr1);
    int smallMidStart = (bigMidArr == &arr1 ? start2 : start1);
    int smallMidEnd = (bigMidArr == &arr1 ? end2 : end1);
    int smallMid = (bigMidArr == &arr1 ? mid2 : mid1);
    if (size1 & 1)
    {
        // 处理数组长度是奇数的情况
        // 此时小中位数数组的长度比大中位数数组的长度多 1，所以要手动判断
        if (smallMidArr->at(smallMid) >= bigMidArr->at(bigMid - 1))
            return smallMidArr->at(smallMid);
        // 到这个位置就排除了对应多余的数，然后递归调用
        return getUpMedian_RC(*bigMidArr, bigMidStart, bigMid - 1, *smallMidArr, smallMid + 1, smallMidEnd);
    }
    else
        // 处理数组长度是偶数的情况
        return getUpMedian_RC(*bigMidArr, bigMidStart, bigMid, *smallMidArr, smallMid + 1, smallMidEnd);
}

// 直接求法
int getUpMedian_DR(vector<int>& arr1, const int& start1, const int& end1,
    vector<int>& arr2, const int& start2, const int& end2)
{
    // 有更简单的写法，在不考虑舍去元素的情况下，我们观察到：
    // 大中位数数组总是将 end 下标设置为 mid 下标
    // 小中位数数组在偶数长度情况下将 start 下标设置为 mid 下标 + 1，在奇数长度情况下将 start 下标设置为 mid 下标
    int L1 = start1;
    int R1 = end1;
    int L2 = start2;
    int R2 = end2;
    // 至于说为什么不取到等于，因为当两个数组的元素变为 1 时，是需要单独讨论的，就和递归求解一样，此时返回小的那一个
    while (L1 < R1)
    {
        int M1 = (L1 + R1) / 2;
        int M2 = (L2 + R2) / 2;
        // 按照我们总结的，只有小中位数数组的下标变换可能受数组长度影响，且在数组为偶数长的时候下标 + 1，奇数长的时候不 + 1
        // 所以 (R1 - L1 + 1) & 1 其实在判断数组长度是否是奇数，而又因为奇数的情况下不 + 1，所以 ^ 1 实际上相当于做了一个 !
        int offset = ((R1 - L1 + 1) & 1 ^ 1);
        if (arr1[M1] == arr2[M2])
            return arr1[M1];
        else if (arr1[M1] > arr2[M2])
        {
            R1 = M1;
            L2 = M2 + offset;
        }
        else
        {
            L1 = M1 + offset;
            R2 = M2;
        }
    }
    return min(arr1[L1], arr2[L2]);
}
// 方法4. 对数器
int method_brutal(const vector<int>& arr1, const vector<int>& arr2, const int& K)
{
    if (arr1.empty() && arr2.empty())
        return -1;
    if (arr1.empty())
        return arr2[K - 1];
    if (arr2.empty())
        return arr1[K - 1];
    vector<int> result;
    int startIndex1 = 0;
    int startIndex2 = 0;
    while (startIndex1 != arr1.size() && startIndex2 != arr2.size())
        result.push_back(arr1[startIndex1] <= arr2[startIndex2] ? arr1[startIndex1++] : arr2[startIndex2++]);
    while(startIndex1 != arr1.size())
        result.push_back(arr1[startIndex1++]);
    while (startIndex2 != arr2.size())
        result.push_back(arr2[startIndex2++]);
    return result[K - 1];
}
void main()
{
	for (int i = 0; i < 8; i++)
	{
		vector<int> arr1 = RandVector(10, 80, 60, true);
		sort(arr1.begin(), arr1.end(), less<int>());
		vector<int> arr2 = RandVector(10, 80, 100, true);
		sort(arr2.begin(), arr2.end(), less<int>());
		int K = 50;
		cout << "Brutal: " << DoubleArrayTopK::method_brutal(arr1, arr2, K) << ", ";
		cout << "DoublePointer: " << DoubleArrayTopK::method_doublePointer(arr1, arr2, K) << ", ";
		cout << "Median(RC): " << DoubleArrayTopK::method_median(arr1, arr2, K, true) << ", ";
		cout << "Median(DR): " << DoubleArrayTopK::method_median(arr1, arr2, K, false) << ", ";
		cout << "BinarySearch: " << DoubleArrayTopK::method_binarySearch(arr1, arr2, K) << endl;
	}
	system("pause");
}
```

## 2.4 摩天大楼问题

**[题目]** 给定一个 N×3 的矩阵 matrix，对于每一个长度为 3 的小数组 arr，都表示一个大楼的三个数据。arr[0] 表示大楼的左边界，arr[1] 表示大楼的右边界，arr[2] 表示大楼的高度（一定大于0）。每座大楼的地基都在 x 轴上，大楼之间可能会有重叠，请返回整体的轮郭线数组，整体轮廓线数组中的单个数组元素的含义为 arr[0] 表示左轮廓 x 坐标，arr[1] 表示右轮廓 x 坐标，arr[2] 表示高度。

**解题思路：**将给定的原楼高数据转换为高度的变化数据，以便我们通过最大高度来构建楼的轮廓信息，比如有输入数据
$$
matrix=\begin{matrix}\{2,5,6\}\\
\{1,7,4\}\\
\{4,6,7\}
\end{matrix}
$$

比如拿出 {2, 5, 6}，其可以被分解为新的信息为 {position, operation, height}，分别表示 {高度变化位置, 增加高度或减少高度, 高度数值}。 那么每一条原信息可以被分解为两条新的数据，根据这些数据，我们可以建立两张表，用于建立最高高度变化的位置，然后再进一步计算出大楼轮廓。


``` c plus
// === 摩天大楼轮廓问题 === //
namespace BuildingOutline
{
    vector<vector<int>> buildingOutline(const vector<vector<int>>& matrix)
    {
        // 因为一条原信息对应于两条增删信息，所以需要将节点个数乘 2
        vector<Node> nodes(matrix.size() * 2);
        for (int i = 0; i < matrix.size(); i++)
        {
            // 信息对应赋值
            nodes[i * 2] = Node{ matrix[i][0], true, matrix[i][2]};
            nodes[i * 2 + 1] = Node{ matrix[i][1], false, matrix[i][2] };
        }
        // 将节点排序
        sort(nodes.begin(), nodes.end(), NodeComparator());
        /*for (auto& node : nodes)
            cout << node.x << ", " << node.isAdd << ", " << node.h << endl;*/
        // 创建高度表（记录某一高度出现的次数）和各个 x 位置的最大高度表
        // 值得注意的是，mapXHeight 中维护的 x 信息是根据节点来的
        // 即原本给的信息中有哪些 x，mapXHeight 中就会维护哪些 x 信息，也就是说，两个连续的 x 信息中可能会维护了相同的最大高度
        // 所以后续判断需要注意这一点
        map<int, int> mapHeightTimes;
        map<int, int> mapXHeight;
        for (int i = 0; i < nodes.size(); i++)
        {
            if (nodes[i].isAdd)
                // 向高度表中加入高度信息
                if (mapHeightTimes.find(nodes[i].h) == mapHeightTimes.end())
                    // 之前没有出现过对应的高度，则向表中添加
                    mapHeightTimes.insert(make_pair(nodes[i].h, 1));
                else
                    // 之前出现过，则次数 ++
                    mapHeightTimes[nodes[i].h]++;
            else
                // 从高度表中减去高度信息
                if (mapHeightTimes[nodes[i].h] == 1)
                    // 如果只有一条信息，则直接删除该高度，说明它不在当前位置存在
                    mapHeightTimes.erase(mapHeightTimes.find(nodes[i].h));
                else
                    // 否则正常减去次数即可
                    mapHeightTimes[nodes[i].h]--;

            // 然后根据各个位置的存在高度来设置最大高度表
            if (mapHeightTimes.empty())
                // 说明最大高度为 0，说明在当前节点数据加入到考虑范围中之后，当前位置是某个大楼轮廓的结束端
                mapXHeight[nodes[i].x] = 0;
            else
                // 否则正常将当前位置的最高高度推入
                mapXHeight[nodes[i].x] = mapHeightTimes.rbegin()->first;
        }
        // 然后通过最大高度表来确定大楼的轮廓
        vector<vector<int>> result;
        int preX = 0;
        int preHeight = 0;
        for (auto& entry : mapXHeight)
        {
            int curX = entry.first;
            int curHeight = entry.second;
            if (preHeight != curHeight)
            {
                // 如果之前大楼高度和当前不一样，说明到了一个轮廓点了
                // 这里给了一个直观印象就是，点与点之间是完全配对的，所以 preHeight 为 0 的时候说明没有楼
                if (preHeight != 0)
                    result.push_back(vector<int>{preX, curX, preHeight});
                preX = curX;
                preHeight = curHeight;
            }
        }
        return result;
        return vector<vector<int>>();
    }
}
void main()
{
	vector<vector<int>> matrix{
		{2,5,6},
		{1,7,4},
		{4,6,7},
		{3,6,5},
		{10,13,2},
		{9,11,3},
		{12,14,4},
		{10,12,5}
	};
	ShowMatrix(BuildingOutline::buildingOutline(matrix));
	system("pause");
}
```

## 2.5 拿铜板问题

**[题目]** 给定一个非负数组，每一个值代表该位置上有几个铜板。a 和 b 玩游戏，a 先手，b 后手，轮到某个人的时候，只能在**一个位置上拿任意数量的铜板**，但是不能不拿。谁最先**把板拿完谁赢**。假设 a 和 b 都极度聪明，请返回获胜者的名字。

**解题思路：**把所有数字异或，如果最终结果非 0 则先手赢，否则后手赢。理论基础即，对于一个异或和非 0 的数组，我们总是可以通过操作某个数，将其异或和变为 0；而对于一个异或和为 0 的数组，我们不过通过什么操作，其最终必然变为一个异或和不为 0 的数组。那么根据这个思路，如果先手面对一个异或和非 0 的数组，那么它可以永远使得后手面对一个异或和为 0 的数组，那么在不断将数组累加和变小的过程中，后手将必然面对累加和为 0 的情况，即失败；反之，如果先手面对的是一个异或和为 0 的数组，那么它将永远面对一个异或和为 0 的数组，则必然失败。

``` c plus
// === Nim 博弈问题 === //
namespace Nim
{
    void printWinner(const vector<int>& arr)
    {
        int eor = 0;
        for (auto& num : arr)
            eor ^= num;
        // 异或和不为 0，说明先手赢，异或和为 0 则后手赢
        cout << (!eor ? "Later wins!" : "Former wins!") << endl;
    }
}
```

## 2.6 chars 与数字的转换问题

**[题目]** 一个 char 类型的数组 chs，其中所有的字符都不同。例如，chs=［'A', 'B', 'C', ..., Z']，则字符串与整数的对应关系如下：
A, B, ..., Z, AA, AB, ..., AZ, BA, BB, ..., ZZ, AAA, ..., ZZZ, AAAA, ...
1, 2, ..., 26, 27, 28, ..., 52, 53, 54, ..., 702, 703, ..., 18278,18279, ...

**例如：**chs = ['A'，'B'，'C']，则字符串与整数的对应关系如下：
A, B, C, AA, AB, ..., CC, AAA, ..., CCC, AAAA, ...
1, 2, 3, 4, 5, ..., 12, 13, ..., 39, 40, ...
给定一个数组 chs，实现根据对应关系完成字符串与整数相互转换的两个函数。

**解题思路：**K 伪进制，意思是，每个位上要求至少有 1（普通 K 进制的话，各个位置可以为 0）。**主要思路看下函数中的注释。**

``` c plus
// === K 伪进制问题 === //
namespace FakeK
{
    // 给定一个字符数组 chs，以及一个目标数字 n，返回对应的 K 伪进制字符串
    string getString(const vector<char>& chs, const int& n)
    {
        int N = n;
        if (chs.size() == 0 || N < 1)
            return "";
        // 表示当前的单位，k ^ 0 = 1，也是添加当前位的数 1 之后，实际产生的增量
        int cur = 1;
        // chs 的个数即进制数
        int base = chs.size();
        // 目标字符串的长度
        int len = 0;
        // 下面这个循环的目的是找出，由最低位向高位推导的过程中，实际上需要多少位
        // 具体过程就是，我从最低位开始，每一位都假设先填 1，直到在某一位的时候，最终形成的数比目标数大
        // 至于这么做的逻辑在于，因为现在我们每一位都填的 1，所以其是形成的 k 伪进制并拥有 len 位情况下的最小值
        while (N >= cur)
        {
            len++;
            N -= cur;
            cur *= base;
        }
        // 循环结束后，cur 是我们目标最高位再高一位
        string res = string(len, 0);
        int index = 0;
        int nCur = 0;
        // 值得注意的是，当前的 N 并没有返回到函数之初，其依然是各个位置都填了 1 之后，原 n 还剩余的数
        do
        {
            // 计算当前位
            cur /= base;
            // 计算当前位对应的数
            nCur = N / cur;
            // nCur + 1 说明了由于此时原本已经在对应位置上给了 1，所以实际我们应该在该位上填的字母对应为 nCur + 1
            res[index++] = getKthCharAtChs(chs, nCur + 1);
            // 将当前 N 变为拿掉最高位之后的状态
            N %= cur;
        } while (index != res.size());
        return res;
    }
    // 给定一个数，返回对应字母
    char getKthCharAtChs(const vector<char>& chs, const int& k)
    {
        // 这个检查其实是不必要的，因为一旦进入了这个 if，说明逻辑错误
        if (k < 1 || k > chs.size())
            return 0;
        return chs[k - 1];
    }
    // 给定一个字符数组 chs，以及对应的字符串 str，返回对应的 K 伪进制数
    int getNumber(const vector<char>& chs, const string& str)
    {
        // 理论上应当检查 str 中的字符是不是全是 chs 中有的，我们省略这一步
        if (chs.empty() || str.size() < 0)
            return 0;
        int len = str.size();
        int base = chs.size();
        int cur = 1;
        int result = 0;
        auto c2n = char2Number(chs);
        for (int i = str.size() - 1; i >= 0; i--)
        {
            result += cur * c2n[str[i]];
            cur *= base;
        }
        return result;
    }
    // 给定一个 chr，返回其对应的数字
    unordered_map<char, int> char2Number(const vector<char>& chs)
    {
        unordered_map<char, int > result;
        for (int i = 0; i < chs.size(); i++)
            result[chs[i]] = i + 1;
        return result;
    }
}
int main() 
{
    int destValue = 10000;
	vector<char> chs{ 'A','B','C','D','H' };
    // 由于 chs 中有 4 个元素，说明此时是 4 伪进制，4 进制是 0 ~ 3，4 伪进制是 1 ~ 4
    // 那么明显知道，最高位 4 ^ 4 = 256 上为 3，占去 768，剩 232
    // 第二位 4 ^ 3 = 64 上为 3，占去 192，剩 40
    // 第三位 4 ^ 2 = 16 上为 2，占去 32，剩 8
    // 第四位 4 ^ 1 = 4 上为 1，占去 4，剩 4，注意，这里不能全部用第四位占
    // 最低位 4 ^ 0 = 1 上位 4，占去4，剩 0
    // 实际过程中，从最低位向高位试，保证每个位上至少伪 1
    string str = FakeK::getString(chs, destValue);
    cout << str << endl;
    cout << FakeK::getNumber(chs, str) << endl;
    system("pause");
    return 0;
}
```

## 2.7 二叉树最大路径和问题

**[题目]** 给定一棵二叉树的头节点 head，可以从树中的任何一点出发，如果走的话只能向下，也可以选择随时停止，所形成的轨迹叫做一条路径，路径上所有值的累加和叫作路径和。求这棵树上的最大路径和。

<font color =red>**讲过？**</font>

## 2.8 超能力🐍问题

**[题目]** 给定一个二维数组 matrix，每个单元都是一个整数，有正有负。最开始的时候小 Q 操纵一条长度为 0 的蛇从矩阵最左侧**任选一个单元格**进入地图，蛇每次只能够到达当前位置的右上相邻，右侧相邻和右下相邻的单元格。蛇到达一个单元格后，自身的长度会瞬间加上该单元格的数值，任何情况下长度为负则游戏结束。小 Q 是个天才，他拥有一个超能力，可以在游戏开始的时候把地图中的某一个节点的值变为其相反数（注：最多只能改变一个节点）。问在小 Q 游戏过程中，他的蛇蛇最长长度可以到多少？

**比如：**
$$
\begin{matrix}
1&-4&10\\
3&-2&-1\\
2&-1&0\\
0&5&-2\\
\end{matrix}
$$
最优路径为从最左侧的 3 开始，3 -> -4（利用能力变成 4）->10，所以返回17。

**解题思路：**给定两个参数 i 和 j，那么自然，如果改动态规划，dp[i]\[j] 表示的即🐍抵达 {i, j} 位置时候的最大长度，那么明显，base case 为第一列的时候，此时要么置反，要么不置反，而一般情况似乎也不是那么难以理解，对第一行和最后一行，它们只能来自前一列中的某两行，而对于非第一行和最后一行，它们可以来自前一列中的某三行，分类讨论，组织数据递归即可。

**声明：**

```c++
// === 超能力蛇问题 === //
namespace SnakeProblem
{
    struct Info
    {
        // 分别代表使用能力和不使用能力的情况下，达到当前位置后能达到的最大长度
        int no;
        int yes;
        Info(const int& n, const int& y) :no(n), yes(y) {}
    };
    // 方法1. 纯递归
    int snake1(const vector<vector<int>>& matrix);
    Info process1(const vector<vector<int>>& matrix, const int& i ,const int& j);
    // 方法2. 记忆化搜索
    int snake2(const vector<vector<int>>& matrix);
    Info process2(const vector<vector<int>>& matrix, const int& i, const int& j, vector<vector<Info*>>& dp);
    // 方法3. 动态规划
    int snake3(const vector<vector<int>>& matrix);
}
```

**代码——暴力递归：**

``` c plus
int snake1(const vector<vector<int>>& matrix)
{
    if (matrix.empty() || matrix[0].empty())
        return 0;
    const int M = matrix.size();
    const int N = matrix[0].size();
    int result = 0;
    // 遍历所有位置，查找出最大的情况
    for (uint32_t i = 0; i < M; i++)
        for (uint32_t j = 0; j < N; j++)
        {
            Info localResult = process1(matrix, i, j);
            result = max(result, max(localResult.no, localResult.yes));
        }
    return result;
}

Info process1(const vector<vector<int>>& matrix, const int& i, const int& j)
{
    if (j == 0)
    {
        // 第一列的情况，此时直接返回 += 矩阵值即可
        return Info(matrix[i][j], -matrix[i][j]);
    }
    // 表示不考虑当前位置的情况下，前面三个可能达到当前位置的情况下，在使用了负值和不使用负值的情况下的最大值
    int preNo = -1;
    int preYes = -1;
    if (i > 0)
    {
        // 在不为第一行的情况下，可以拿到左上角的元素
        Info leftOver = process1(matrix, i - 1, j - 1);
        // 这里用 max 就是最好的判断方法
        preNo = max(preNo, leftOver.no);
        preYes = max(preYes, leftOver.yes);
    }
    // 任何情况下，都能拿到正左边的元素
    Info left = process1(matrix, i, j - 1);
    preNo = max(preNo, left.no);
    preYes = max(preYes, left.yes);
    if (i < matrix.size() - 1)
    {
        // 在不为最后一行的情况下，可以拿到左下角的元素
        Info leftBottom = process1(matrix, i + 1, j - 1);
        preNo = max(preNo, leftBottom.no);
        preYes = max(preYes, leftBottom.yes);
    }
    // 此时已经得到了，在不计当前 i, j 位置情况下，到底当前位置时候，使用负值和不使用负值情况下的最大长度
    // 然后在考虑当前位置的情况下，对于不使用负值的情况，其只有一种情况，即之前不用负值并且当前依然不用
    // 对于使用负值的情况，其有两种分支情况，即之前用当前不用以及之前不用当前用
    int no = -1;
    int yes = -1;
    // 仅这种情况会出现不用负值的情况
    no = preNo >= 0 ? preNo + matrix[i][j] : -1;
    // 求出之前不用负值，当前位置用负值的情况对应值
    int preNo_curYes = preNo >= 0 ? preNo - matrix[i][j] : -1;
    int preYes_curNo = preYes >= 0 ? preYes + matrix[i][j] : -1;
    // 求出之前用了负值，当前不用负值的情况
    yes = max(preNo_curYes, preYes_curNo);
    return Info(no, yes);
}
```

 **代码——记忆化搜索：**

``` c plus
// 方法2. 记忆化搜索
int snake2(const vector<vector<int>>& matrix)
{
    if (matrix.empty() || matrix[0].empty())
        return 0;
    const int M = matrix.size();
    const int N = matrix[0].size();
    vector<vector<Info*>> dp(M, vector<Info*>(N, NULL));
    int result = 0;
    for (int i = 0; i < M; i++)
        for (int j = 0; j < N; j++)
        {
            Info localResult = process2(matrix, i, j, dp);
            result = max(result, max(localResult.no, localResult.yes));
        }
    // 释放空间
    for (int i = 0; i < M; i++)
        for (int j = 0; j < N; j++)
        {
            delete dp[i][j];
        }
    return result;
}
Info process2(const vector<vector<int>>& matrix, const int& i, const int& j, vector<vector<Info*>>& dp)
{
    // 进来先确定当前位置是否计算过，如果计算过就直接返回
    if (dp[i][j] != NULL)
        return *dp[i][j];
    if (j == 0)
    {
        dp[i][j] = new Info(matrix[i][j], -matrix[i][j]);
        // 第一列的情况，此时直接返回 += 矩阵值即可
        return *dp[i][j];
    }
    // 表示不考虑当前位置的情况下，前面三个可能达到当前位置的情况下，在使用了负值和不使用负值的情况下的最大值
    int preNo = -1;
    int preYes = -1;
    if (i > 0)
    {
        // 在不为第一行的情况下，可以拿到左上角的元素
        Info leftOver = process1(matrix, i - 1, j - 1);
        // 这里用 max 就是最好的判断方法
        preNo = max(preNo, leftOver.no);
        preYes = max(preYes, leftOver.yes);
    }
    // 任何情况下，都能拿到正左边的元素
    Info left = process1(matrix, i, j - 1);
    preNo = max(preNo, left.no);
    preYes = max(preYes, left.yes);
    if (i < matrix.size() - 1)
    {
        // 在不为最后一行的情况下，可以拿到左下角的元素
        Info leftBottom = process1(matrix, i + 1, j - 1);
        preNo = max(preNo, leftBottom.no);
        preYes = max(preYes, leftBottom.yes);
    }
    // 此时已经得到了，在不计当前 i, j 位置情况下，到底当前位置时候，使用负值和不使用负值情况下的最大长度
    // 然后在考虑当前位置的情况下，对于不使用负值的情况，其只有一种情况，即之前不用负值并且当前依然不用
    // 对于使用负值的情况，其有两种分支情况，即之前用当前不用以及之前不用当前用
    int no = -1;
    int yes = -1;
    // 仅这种情况会出现不用负值的情况
    no = preNo >= 0 ? preNo + matrix[i][j] : -1;
    // 求出之前不用负值，当前位置用负值的情况对应值
    int preNo_curYes = preNo >= 0 ? preNo - matrix[i][j] : -1;
    int preYes_curNo = preYes >= 0 ? preYes + matrix[i][j] : -1;
    // 求出之前用了负值，当前不用负值的情况
    yes = max(preNo_curYes, preYes_curNo);
    dp[i][j] = new Info(no, yes);
    return *dp[i][j];
}
```

**代码——纯动态规划：**

``` c plus
// 方法3. 动态规划
int snake3(const vector<vector<int>>& matrix)
{
    if (matrix.empty() || matrix[0].empty())
        return 0;
    int M = matrix.size();
    int N = matrix[0].size();
    // 初始化动态规划表
    vector<vector<int>> dp_no(M, vector<int>(N, -1));
    vector<vector<int>> dp_yes(M, vector<int>(N, -1));
    int result = 0;
    // Base case
    for (int i = 0; i < M; i++)
    {
        dp_no[i][0] = matrix[i][0];
        result = max(result, dp_no[i][0]);
    }
    for (int i = 0; i < M; i++)
    {
        dp_yes[i][0] = -matrix[i][0];
        result = max(result, dp_yes[i][0]);
    }
    // 按列循环，不要搞错了
    for (int j = 1; j < N; j++)
        for (int i = 0; i < M; i++)
        {
            int preNo = -1;
            int preYes = -1;
            if (i > 0)
            {
                // 在不为第一行的情况下，可以拿到左上角的元素
                // 这里用 max 就是最好的判断方法
                preNo = max(preNo, dp_no[i - 1][j - 1]);
                preYes = max(preYes, dp_yes[i - 1][j - 1]);
            }
            // 任何情况下，都能拿到正左边的元素
            preNo = max(preNo, dp_no[i][j - 1]);
            preYes = max(preYes, dp_yes[i][j - 1]);
            if (i < M - 1)
            {
                // 在不为最后一行的情况下，可以拿到左下角的元素
                preNo = max(preNo, dp_no[i + 1][j - 1]);
                preYes = max(preYes, dp_yes[i + 1][j - 1]);
            }
            // 此时已经得到了，在不计当前 i, j 位置情况下，到底当前位置时候，使用负值和不使用负值情况下的最大长度
            // 然后在考虑当前位置的情况下，对于不使用负值的情况，其只有一种情况，即之前不用负值并且当前依然不用
            // 对于使用负值的情况，其有两种分支情况，即之前用当前不用以及之前不用当前用
            int no = -1;
            int yes = -1;
            // 仅这种情况会出现不用负值的情况
            no = preNo >= 0 ? preNo + matrix[i][j] : -1;
            // 求出之前不用负值，当前位置用负值的情况对应值
            int preNo_curYes = preNo >= 0 ? preNo - matrix[i][j] : -1;
            int preYes_curNo = preYes >= 0 ? preYes + matrix[i][j] : -1;
            // 求出之前用了负值，当前不用负值的情况
            yes = max(preNo_curYes, preYes_curNo);
            dp_no[i][j] = no;
            dp_yes[i][j] = yes;
            result = max(result, max(no, yes));
        }
    return result;
}
void main()
{
	vector<vector<int>> matrix =
	{
		{1, -4, 10, 13},
		{3, -2, -1, 24},
		{2, -1, -12, 12},
		{0, 5, -2, 9}
	};
	cout << SnakeProblem::snake1(matrix)<<endl;
	cout << SnakeProblem::snake2(matrix)<<endl;
	cout << SnakeProblem::snake3(matrix)<<endl;
	system("pause");
}
```

## 2.9 字符串转数值运算问题

**[基本问题]** 如果字符串中不包含左右括号，返回其对应的公式计算结果。

**解题思路：**用栈，读到符号，把数字截断，查看栈顶是不是乘除号，是则从栈中弹两个元素，先运算之前的乘除号，然后将得到的结果以及当前符号入栈，最终栈中仅剩下加减，则挨个计算即可。

**[题目]** 给定一个字符串 str，str 表示一个公式，公式里可能有整数、加减乘除符号和左右括号，返回公式的计算结果。

**[举例]**
str = "48 \* ((70 - 65) - 43 ) + 8\*1"，返回 -1816。
str = "3 + 1\*4"，返回 7。
str = "3 + (1\*4)"，返回 7。

**[说明]**

1. 可以认为给定的字符串一定是正确的公式，即不需要对 str 做公式有效性检查；
2. 如果是负数，就需要用括号括起来，比如 "4\*(-3)"。但如果负数作为公式的开头或括号部分的开头，则可以没有括号，比如"-3\*4"和"(-3\*4)"都是合法的；
3. 不用考虑计算过程中会发生溢出的情况。

**解题思路：**递归 + 基本问题，即每次遇到左括号，创建一个基本子问题，调用下级函数，而每次遇到右括号，结算一个基本子问题，向上返回，返回结果有两个值，一个是子问题的计算结果，另一个是当前子问题算到的位置。

**基本问题的解法：**用栈的思想，遇到数字，直接压入栈，如果遇到运算符，判断当前符号是不是乘除以及栈顶符号是不是乘除，来确定要不要将栈中的元素和当前记录的数 cur 进行结合。

``` c plus
// === 字符串转数值计算问题 === //
namespace String2Calculation
{
    // 主调函数
    int getValue(const string& str)
    {
        if (str.empty())
            return 0;
        // 返回从 0 开始计算的基本问题的数值运算结果即可
        return str[0] == '-' ? -value(str, 1)[0] : value(str, 0)[0];
    }
    // str 表示给定的字符串算数运算，index 表示当前基本问题从 index 位置开始
    // 返回值的第一个表示基本问题的计算结果，第二个表示基本问题计算完后，其对应的下一个位置
    vector<int> value(const string& str, const int& index)
    {
        int i = index;
        stack<string> stk;
        // pre 表示当前形成的数字有多大
        int pre = 0;
        // 在子问题结尾（右括号）或者字符串结尾处跳出循环，并清算基本问题的结果
        while (i < str.size() && str[i] != ')')
        {
            if (str[i] >= '0' && str[i] <= '9')
            {
                // 说明当前位置是一个数字，将该数字和 pre 结合并更新
                pre = pre * 10 + (str[i++] - '0');
            }
            else if (str[i] != '(')
            {
                // 只要当前不是左括号（不用考虑右括号，其作为循环条件被处理），说明当前位置是一个运算符号
                // 则将当前记录的数“压栈”，具体处理方式交给这个函数去执行
                addNum(stk, pre);
                // 然后将当前符号压栈
                stk.push(mStringHandler(str[i++]).toString());
                // 既然当前数已经被处理过了，现在要重新构造 pre，即要将其清零
                pre = 0;
            }
            else
            {
                // 当前位置是左括号，则需要创建一个子问题
                // returnedValue 用于表示儿子基本问题中的结果，因为不能计入当前括号，所以实际上是从 i + 1 位置开始进行下一个基本问题
                vector<int> returnedValue = value(str, i + 1);
                pre = returnedValue[0];
                // 至于这里为什么要 + 1，因为只要遍历到右括号就跳出循环，此时对应 i 位置就是右括号，所以要往右括号后面一位继续进行遍历
                i = returnedValue[1] + 1;
            }
        }
        // 在遇到右括号或字符串结尾的时候，前面必然有一个数字还没进行压栈
        addNum(stk, pre);
        // 通过 getNum 结算当前栈，并返回当前遍历到的位置
        return vector<int>{getNum(stk), i};
    }
    // 将一个数放到栈里面去，要根据栈顶的符号决定，是否要将 num 和栈中的元素进行结合运算
    // 值得注意的是，在执行 addNum 前，stack 的顶层元素是一个符号，而执行后，stack 的顶层元素将变为一个数字
    void addNum(stack<string>& stack, const int& num)
    {
        int result = num;
        // 如果当前栈是空的，则直接把数压入栈中即可
        if (!stack.empty())
        {
            // 在栈不为空的情况下，需要判断栈顶的元素符号是什么，如果是乘除，说明先要和当前数进行运算，否则直接压入当前数即可
            // cur 表示栈中最顶上的数字
            int cur = 0;
            string top = stack.top();
            stack.pop();
            if (top == "+" || top == "-")
            {
                // 将刚刚弹出的元素压回去
                stack.push(top);
            }
            else
            {
                // 说明需要先做乘除运算，进行优先结合，则还需要从栈里面再弹一个数出来
                // 将顶层的数转换为 int 类型
                cur = mStringHandler(stack.top()).toInt();
                // 再将刚刚的数弹出栈
                stack.pop();
                result = (top == "*") ? (cur * result) : (cur / result);
            }
        }
        stack.push(to_string(result));
    }
    // 对于一个栈中，最后理应只剩下 + - 号以及运算数，则通过这个函数计算基本问题的数值运算结果
    int getNum(stack<string>& stack)
    {
        if (stack.empty())
            return 0;
        // 计算最终结果
        int result = 0;
        // 存储遍历到的符号
        string cur = "";
        // 判断当前应该加还是减
        bool add = true;
        int num = 0;
        while (!stack.empty())
        {
            // 弹出栈顶元素
            cur = stack.top();
            stack.pop();
            if (cur == "+")
                add = true;
            else if (cur == "-")
                add = false;
            else
            {
                // 值得注意的是，第一次运算的时候默认是 add = true，所以 result 会加上当前取出来的第一个数
                num = mStringHandler(cur).toInt();
                result += add ? num : (-num);
            }
        }
        return result;
    }
}
void main()
{
	string exp = "48*((70-65)-43)+8*1";
	cout << String2Calculation::getValue(exp) << endl;

	exp = "4*6-9";
	cout << String2Calculation::getValue(exp) << endl;

	exp = "10-5*3";
	cout << String2Calculation::getValue(exp) << endl;

	exp = "-3*4";
	cout << String2Calculation::getValue(exp) << endl;

	exp = "3+1*4";
	cout << String2Calculation::getValue(exp)<<endl;
	system("pause");
}
```

## 2.10 最长公共子串

**[题目]** 请注意区分子串**（连续）**和子序列**（可以不连续）**的不同，给定两个字符串 str1 和 str2，求两个字符串的最长公共子串。该问题主要理解空间压缩技巧。

**解题思路：**对于普通动态规划方法，dp[i]\[j] 的含义为 str1 以 i 位置字符结尾 str2 以 j 位置字符结尾，**两者能够形成的子串中的公共子串以 str1[i] 和 str2[j] 结尾的**最大长度。那么 base case 非常明显，如果 str1[i] 和 str2[j] 不同，则两者对应的结果必然为 0，而如果 str1[i] 和 str2[j] 相同，那么两者对应的结果为 dp[i - 1]\[j - 1] + 1 。所以表中的元素仅仅依赖其左上角的元素，那么我们最终可以将额外空间压缩为有限的几个变量，同时遍历所有可能性。 

``` c plus
// === 求最长公共子串问题 === //
namespace LongestSubString
{
    // 无空间压缩的动态规划
    string solve(const string& str1, const string& str2)
    {
        if (str1.empty() || str2.empty())
            return "";
        int M = str1.size();
        int N = str2.size();
        // 每个位置的元素表示以 str1[i] 字符结尾并以 str2[j] 字符结尾的情况下
        // 能够产生的最长公共子串
        vector<vector<int>> dp(str1.size(), vector<int>(0, str2.size()));
        int maxLength = 0;
        // 需要记录最长的子串出现在 str1 的某个位置，或记录其出现在 str2 的某个位置
        int offset1 = 0;
        // 按对角线遍历的定式，需要牢记，这是是从右上到左下遍历（对应的对角线元素方式是左上到右下的）
        // 这种遍历方式的要素在于：起始位置下标和遍历边界位置
        int row = 0;
        int col = N - 1;
        while (row < M)
        {
            // 这里是用于确定起始位置
            int i = row;
            int j = col;
            int curLength = 0;
            // 遍历边界位置即在横向元素下标或纵向元素下标超出范围的时候
            while (i < M && j < N)
            {
                if (str1[i] == str2[j])
                    curLength++;
                if (maxLength < curLength)
                {
                    maxLength = curLength;
                    // 因为目标是记录 str1 的位置，所以记录 row
                    offset1 = i;
                }
                // 这里不要动 row 和 col
                i++;
                j++;
            }
            // 根据不同的情况改变初始元素的下标
            if (col > 0)
                col--;
            else
                row++;
        }
        string result = "";
        try
        {
            for (int i = offset1 - maxLength + 1; i <= offset1; i++)
            {
                if (i == M)
                    throw string("Out of range!");
                result += str1[i];
            }
        }
        catch (const std::string& e)
        {
            cout << e << endl;
        }
        return result;
    }
}
void main()
{
	string str1 = "ABC1234567DE1234567921FG";
	string str2 = "HIJKL1234567MNO1234567921asdhiuiuqiP";
	cout << LongestSubString::solve(str1, str2) << endl;
	system("pause");
}
```

## 2.11 最长公共子序列

**[题目]** 如题。

**解题思路：**dp[i]\[j] 的含义为 str1 以 i 位置字符结尾 str2 以 j 位置字符结尾，两者能够形成的子串中的公共子串的最大长度，**此时不要求子序列以 str1[i] 和 str2[j] 的字符结尾。**讨论可能性：

1. 要求不以 str1[i] 的字符结尾也不以 str2[j] 的字符结尾，此时等价于 dp[i - 1]\[j - 1]；
2. 要求以 str1[i] 的字符结尾结尾但不以 str2[j] 的字符结尾，此时等价于 dp[i]\[j - 1]；
3. 要求不以 str1[i] 的字符结尾但以 str2[j] 的字符结尾，此时等价于 dp[i - 1]\[j]；
4. 要求以 str1[i] 的字符结尾也以 str2[j] 的字符结尾，此时必须有 str1[i] == str2[j]，此时等价于 dp[i - 1]\[j - 1] + 1。

显然，对情况 1 的讨论是没有必要的，其得到的结果必然小于等于情况 2 和情况 3 的结果，而情况 4 如果能够成立，其必然是最好的情况。

``` c plus
// === 求最长公共子序列问题 === //
namespace LongestSubSequence
{
    // 输出子序列
    string getSubSequence(const string& str1, const string& str2)
    {
        if (str1.empty()|| str2.empty())
            return "";
        // 拿到动态规划表
        auto dp = getDp(str1, str2);
        int M = str1.size() - 1;
        int N = str2.size() - 1;
        int length = dp[M][N];
        // 以 string 为单位进行循环
        string result = string(length, 0);
        int index = length - 1;
        while (index >= 0)
        {
            // 为了得到最终的相同子序列，我们必须找出切实地让子序列增长的那些位置的字符
            // 而从正向推导的过程中可以知道，要么 dp[M][N] 只可能从 dp[M][N - 1]、dp[M - 1][N] 以及 dp[M - 1][N - 1] + 1 这三种情况产生
            // 而前面两种情况明显都是没有使得子序列有效增长的情况，由此就可以知道，我们的逻辑可以按以下内容书写
            // 值得注意的是 N > 0 和 M > 0 这两个边界条件，看起来简单实则非常妙，其完美囊括了边界情况，看下面一个例子就懂了
            // 0: subStr1 = ah1bz, subStr2 = abcdef，执行 if
            // 1: subStr1 = ah1bz, subStr2 = abcde，执行 if
            // 2: subStr1 = ah1bz, subStr2 = abcd，执行 if
            // 3: subStr1 = ah1bz, subStr2 = abc，执行 if
            // 4: subStr1 = ah1bz, subStr2 = ab，执行 else if
            // 5: subStr1 = ah1b, subStr2 = ab，执行 else
            // 6: subStr1 = ah1, subStr2 = a，执行 else if
            // 7: subStr1 = ah, subStr2 = a，执行 else if
            // 8: subStr1 = a, subStr2 = a，此处前面两个 if 中，N 和 M 都同时为 0，所以直接执行 else，逻辑完全正确
            if (N > 0 && dp[M][N] == dp[M][N - 1])
                N--;
            else if (M > 0 && dp[M][N] == dp[M - 1][N])
                M--;
            else
            {
                // 这里用 str1[M] 和 str2[N] 是等价的
                result[index--] = str1[M];
                M--;
                N--;
            }
        }
        return result;
    }
   	// 计算得到 dp 表
    vector<vector<int>> getDp(const string& str1, const string& str2)
    {
        int M = str1.size();
        int N = str2.size();
        // 用于记录以某个位置结尾的 str1 子串和 str2 子串能够找出的最长子序列
        vector<vector<int>>dp(M, vector<int>(N, 0));
        // Base case，第一行和第一列
        dp[0][0] = str1[0] == str2[0];
        for (int i = 1; i < N; i++)
            dp[0][i] = dp[0][i - 1];
        for (int i = 1; i < M; i++)
            dp[i][0] = dp[i - 1][0];
        // 递推关系很明显，i, j 位置的元素依赖其左、上以及左上元素，所以按行按列循环均可
        for (int i = 1; i < M; i++)
        {
            for (int j = 1; j < N; j++)
            {
                if (str1[i] == str2[j])
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                else
                    dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);
            }
        }
        return dp;
    }
}
void main()
{
	string str1 = "1J2K3L4M5N6abc";
	string str2 = "1A2B3C4D5H603a94bapoghkcjkoy";
	auto dp = LongestSubSequence::getDp(str1, str2);
	ShowMatrix(dp);
    // 应该输出 123456abc
	cout << LongestSubSequence::getSubSequence(str1, str2) << endl;
	system("pause");
}
```

## 2.12 摇船过河问题

**[题目]** 给定一个数组 arr，长度为 N  且每个值都是正数，代表 N 个人的体重。再给定一个正数 limit，代表一艘船的载重。以下是坐船规则：

1）每艘船最多只能坐两人；

2）乘客的体重和不能超过 Iimit。返回如果同时让这 N 个人过河最少需要几条船。

**解题思路：**

1. 如果有人体重已经超 limit，则无解；
2. 将数组 arr 升序排序，然后找出 <= limit / 2 的那个位置的数，比如其在 found**（直接地板除，这样做的意义在于，包含这个找出的数在内的左边所有数都可以两两组一艘船）**，此外，如果 found 在 end 位置，说明所有数都小于等于 limit / 2，那么最终结果就是 (arr.size() + 1) / 2 ，如果 found 在 rend 位置，说明所有数都大于 limit / 2，那么最终结果就是 arr.size()；
3. 然后准备两个指针，一个 left 指向 found，一个 right 指向 found + 1，看 left 和 right 能不能进一艘船，如果能，right 向右滑，直到不能，此时 right 滑动的次数代表有几个元素可以配对**（越界的情况没有讨论，具体的看代码）**，如果不能，left 向左滑，直到能；
4. 最终结果就是，左半区未配对元素 / 2 + 配对数 + 右半区未配对元素

```c++
// === 最少船过河问题 === //
namespace MinBoat
{
    // arr 表示体重，weight 表示每一艘船能够承受的最大重量
    int minBoat(vector<int>& arr, const int& weight)
    {
        if (arr.empty())
            return -1;
        // 排序
        sort(arr.begin(), arr.end(), [&](const int& number1, const int& number2) {
            return number1 < number2;
            });
        if (*arr.rbegin() > weight)
            // 体重如果已经超过了船的最大荷载，则返回 -1
            return -1;
        int halfLoad = weight / 2;
        int N = arr.size();
        // 如果最大的体重也小于等于 halfLoad，则最终结果就是 (N + 1) / 2
        if (*arr.rbegin() <= halfLoad)
            return (N + 1) / 2;
        // 如果最小的体重也大于 halfLoad，则最终结果就是 N
        if (arr[0] > halfLoad)
            return N;
        int lessR = -1;
        // 二分找出 arr 中最大的小于等于 halfLoad 的数的位置
        int left = 0;
        int right = N - 1;
        while (left <= right)
        {
            int mid = (left + right) / 2;
            if (arr[mid] <= halfLoad)
            {
                left = mid + 1;
                lessR = mid;
            }
            else
                right = mid - 1;
        }
        // 表示左半区 <= halfLoad 的指针
        int lessIndex = lessR;
        // 表示右半区 > halfLoad 的指针
        int moreIndex = lessR + 1;
        // 表示左半区没有被使用到的元素（左半区的两边部分，左边部分是因为右半区配对的数不够，右边部分是数还不够小）
        int lessUnuesd = 0;
        while (lessIndex >= 0)
        {
            int solved = 0;
            // 在以下这个循环条件中，只要满足就说明右指针可以向右滑动，且配对的对数 + 1
            while (moreIndex < N && (arr[lessIndex] + arr[moreIndex] <= weight))
            {
                solved++;
                moreIndex++;
            }
            if (solved == 0)
            {
                // 说明当前左指针对应的数不能和右区域中的任意数进行配对，则左指针向左滑动
                // 如果右边已经没有数了，此时依然可以继续通过这一步记录没有使用的左区域的数
                lessUnuesd++;
                lessIndex--;
            }
            else
            {
                // 说明当前左指针向左数有若干个数可以和当前右区域中的数进行匹配，但可能个数不够
                // 其实没有必要这么写，如果左区域的数不够配对，lessIndex - solved 必然会小于 0，此时逻辑也不会出错
                // 其实最主要的变量是 lessUnuesd，只要这个变量正确计算，其它变量都能被正确地算出来
                lessIndex = max(-1, lessIndex - solved);
            }
        }
        // 左区域的元素总数
        int lessAll = lessR + 1;
        // 成功配对数
        int pairs = lessAll - lessUnuesd;
        // 右区域没有配对的数目，含义很明确，不赘述
        int moreUnuesd = N - lessAll - pairs;
        return pairs + moreUnuesd + (lessUnuesd + 1) / 2;
    }
}
void main()
{
	// 维度为 10
	vector<int> arr = { 1, 2, 2, 2, 2, 4, 4, 4, 4, 5 };
	int weight = 5;
	// 应当输出 7
	cout << MinBoat::minBoat(arr, weight) << endl;
	system("pause");
}
```

## 2.13 最长回文序列

**[题目]** 给定一个字符串 str，求最长的回文子序列。注意区分子序列和子串的不同。

**解题思路：**范围尝试，找出 str[i...j] 中的最长回文子序列是多少。形成的 dp 明显是一个右上对角矩阵。

**<font color =red>总结：这类范围上尝试的问题，其状态转移可以归结于以下几种可能性</font>**

1. 设 i ~ j 的最长回文以 str[i] 开始但不以 str[j] 结尾，那么此时由于 str[j] 没有使用，dp\[i][j] 可能等于 dp\[i][j - 1]；
2. 设 i ~ j 的最长回文不以 str[i] 开始但以 str[j] 结尾，那么此时由于 str[i] 没有使用，dp\[i][j] 可能等于 dp\[i + 1][j]；
3. 设 i ~ j 的最长回文不以 str[i] 开始也不以 str[j] 结尾，那么此时由于 str[i] 和 str[i] 均没有使用，dp\[i][j] 可能等于 dp\[i + 1][j - 1]；
4. 设 i ~ j 的最长回文以 str[i] 开始也以 str[j] 结尾，此时要求 str\[i] == str[j]，dp\[i][j] 可能等于 dp\[i + 1][j - 1] + 2；

类似于最长公共子序列问题，其实上面四种可能性的分割方法不是很直观，应该按以下可能性进行理解

1. 如果 str\[i] == str[j]，此时 dp\[i][j] 必然为 dp\[i + 1][j - 1] + 2；
2. 如果 str\[i] != str[j]，此时 dp\[i][j] 必然为 dp\[i][j - 1] 和 dp\[i + 1][j] 中较大的那一个。这两种情况的成立条件是可以证明的。

那么表中的元素实际上只依赖于其左边、下边以及左下边的元素，而在 base case 的情况下，我们可以初始化出来两条对角线**（因为要用到左下边的元素，所以需要两条对角线，当然，不将其当作 base case，用带条件的状态转移也不是不可以）**。

**注：**所谓状态转移其实就是元素之间的递推。

```c++
// === 最长回文子序列 === //
namespace LongestPalindromeSubsequence
{
    // 方法 1. 标准动态 dp
    int solve1(const string& str)
    {
        if (str.empty())
            return 0;
        int N = str.size();
        vector<vector<int>> dp(N, vector<int>(N, 0));
        // Base case
        for (int i = 0; i < N; i++)
            dp[i][i] = 1;
        for (int i = 0; i < N - 1; i++)
            dp[i][i + 1] = str[i] == str[i + 1] ? 2 : 1;
        // 初始化了两条对角线，所以应该从 i = N - 3 按行向前循环
        for (int i = N - 3; i >= 0; i--)
            for (int j = i + 2; j < N; j++)
            {
                // 从接近对角线位置向右循环
                if (str[i] == str[j])
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                else
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
            }
        return dp[0][N - 1];
    }
    // 方法 2. 将字符串翻转，然后求其和原来字符串的最长公共子序列
    // 比如 abhcjbla 的翻转字符串为 albjchba，两者的公共子序列为 abcba，其就是原来字符串的最长回文子序列
    // 原理在于，作为回文的序列在翻转之后依然和其在原本字符串中的状态相等，因而可以通过找两者的最长公共序列的方式得到
    int solve2(const string& str)
    {
        if (str.empty())
            return 0;
        int N = str.size();
        string reverStr(N, 0);
        for (int i = 0; i < N; i++)
            reverStr[N - 1 - i] = str[i];
        return LongestSubSequence::getDp(str, reverStr)[N - 1][N - 1];
    }
}
void main()
{
	// 测试最长回文子串的解
	string str = "a1bfc4d234f456e8g7e6fd9c9b33dgqwea";
	cout << LongestPalindromeSubsequence::solve1(str) << ", " << LongestPalindromeSubsequence::solve2(str) << endl;
	system("pause");
}
```

## 2.14 添加字符形成回文问题

**[题目]** 给定一个字符串 str，如果可以在 str 的任意位置添加字符，请返回在添加字符最少的情况下，让 str 整体都是回文字符串的一种结果。

**[举例]** str = "ABA"。str 本身就是回文串，不需要添加字符，所以返回 "ABA"。str = "AB"。可以在 'A' 之前添加 'B' ，使str整体都是回文串，故可以返回"BAB"。也
可以在 'B' 之后添加 'A' ，使 str 整体都是回文串，故也可以返回 "ABA"。总之，只要添加的字符数最少，返回其中一种结果即可。

**解题思路：**

​		个人感觉这里的可能性分析还是具有一定的贪心，这个可能性分析是很直观的，即要求 dp\[i][j]，就看

1. 以最小添加代价形成 str[i + 1]\[j]，然后通过向尾部添加 str[i] 形成 str[i]\[j] 的回文子串；
2. 以最小添加代价形成 str[i]\[j - 1]，然后通过向头部添加 str[j] 形成 str[i]\[j] 的回文子串；
3. 以最小添加代价形成 str[i + 1]\[j - 1]，若 str[i] == str[j]，则此时已经直接形成回文子串。

其实这种类似问题都基本是这三种情况，且这道题中也可以证明，若 str[i] == str[j]，情况 3 必然能够得到最小的代价。但是如何证明这三种情况一定会形成 str[i]\[j] 以添加形成回文的最小代价的全部可能？

```c++
// === 通过添加字符获取回文 === //
namespace PalindromeMinAdd
{
    // 标准解法，但只返回一个可能结果
    string solve_Standard(const string& str)
    {
        if (str.empty()) {
            return str;
        }
        int N = str.size();
        auto dp = getDp_Standard(str);
        string res(N + dp[0][N - 1], 0);
        int i = 0;
        int j = N - 1;
        int resl = 0;
        int resr = res.size() - 1;
        while (i <= j) {
            if (str[i] == str[j]) {
                res[resl++] = str[i++];
                res[resr--] = str[j--];
            }
            else if (dp[i][j - 1] < dp[i + 1][j]) {
                res[resl++] = str[j];
                res[resr--] = str[j--];
            }
            else {
                res[resl++] = str[i];
                res[resr--] = str[i++];
            }
        }
        return res;
    }
    // 最终需要返回得到的具体回文（所有）是什么
    vector<string> solve(const string& str)
    {
        if (str.empty())
            return vector<string>();
        int N = str.size();
        auto dp = getDp(str);
        // 最终字符串的长度为原 str 的长度 + 需要添加的字符个数
        int length = str.size() + dp[0][N - 1];
        string cur(length, 0);
        vector<string> result;
        // 逆向回溯，具体看最终的结果是从哪里来的，具体就是和其左、左下、下元素进行比较，如果可以通过任意一条路径到达当前位置
        // 就说明其可以形成目标长度对应的回文结果
        // 1. 如果 dp[i][j] == dp[i + 1][j - 1]，此时应该将 str[i] 和 str[j] 添在当前未填的左边和右边，并且 i = i + 1，j = j - 1
        // 2. 如果 dp[i][j] == dp[i + 1][j] + 1，此时应该将 str[i] 添加在当前未填的左边和右边，并且 i = i + 1
        // 3. 如果 dp[i][j] == dp[i][j - 1] + 1，此时应该将 str[j] 添加在当前未填的左边和右边，并且 j = j - 1
        searchBack(dp, str, cur, 0, 0, N - 1, result);
        return result;
    }
    // 实际上左指针的位置和当前 dp 中的元素位置是绑定的，所以其实是一个二维问题
    void searchBack(const vector<vector<int>>& dp, const string& ori, string& dest, const int& left, const int& dpi, const int& dpj,
        vector<string>& result)
    {
        if (dpi > dpj)
        {
            result.push_back(dest);
            // 结束
            return;
        }
        int right = dest.size() - 1 - left;
        // 下面的三种情况不能用 if else 语句，三种情况均需要经过判断
        if (ori[dpi] == ori[dpj])
        {
            dest[left] = ori[dpi];
            dest[right] = ori[dpj];
            searchBack(dp, ori, dest, left + 1, dpi + 1, dpj - 1, result);
        }
        // 下面两种情况中，如果达到了 dpi == dpj 的情况，此时应该要结束，此时无法再往下继续，此时不会产生分支，则直接返回
        if (dpi == dpj)
        {
            return;
        }
        if (dp[dpi][dpj] == dp[dpi + 1][dpj] + 1)
        {
            // 此时相当于最后添 str[i]
            dest[left] = ori[dpi];
            dest[right] = ori[dpi];
            searchBack(dp, ori, dest, left + 1, dpi + 1, dpj, result);
        }
        if (dp[dpi][dpj] == dp[dpi][dpj - 1] + 1)
        {
            // 此时相当于最后添 str[j]
            dest[left] = ori[dpj];
            dest[right] = ori[dpj];
            searchBack(dp, ori, dest, left + 1, dpi, dpj - 1, result);
        }
    }
    vector<vector<int>> getDp(const string& str)
    {
        int N = str.size();
        // -1 表示无效
        vector<vector<int>> dp(N, vector<int>(N, -1));
        // Base case
        for (int i = 0; i < N; i++)
            // 对单独某个字符的情况，不需要添加任何字符，其本身就是回文
            dp[i][i] = 0;
        for (int i = 0; i < N - 1; i++)
            // 对两个字符的情况，根据两个字符是否相等，其需要添加 0 个或 1 个字符以形成回文
            dp[i][i + 1] = str[i] == str[i + 1] ? 0 : 1;
        for (int i = N - 3; i >= 0; i--)
        {
            for (int j = i + 2; j < N; j++)
            {
                if (str[i] == str[j])
                    // 如果首尾元素相同，则无需额外添加字符
                    dp[i][j] = dp[i + 1][j - 1];
                else
                    // 否则需要先将左右两部分先搞成回文，然后多添一个元素为剩下那个字符配对使得整体形成回文
                    dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1;
            }
        }
        return dp;
    }
    vector<vector<int>> getDp_Standard(const string& str)
    {
        int N = str.size();
        vector<vector<int>> dp(N, vector<int>(N, 0));
        for (int j = 1; j < str.size(); j++) {
            dp[j - 1][j] = str[j - 1] == str[j] ? 0 : 1;
            for (int i = j - 2; i > -1; i--) {
                if (str[i] == str[j]) {
                    dp[i][j] = dp[i + 1][j - 1];
                }
                else {
                    dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1;
                }
            }
        }
        return dp;
    }
}
void main()
{
	// 1. AOJSDSAQIJOJIQASDSJOA
	// 2. AOJSDSAQIOJOIQASDSJOA
	// 3. AOJDSDAQIJOJIQADSDJOA
	// 4. AOJDSDAQIOJOIQADSDJOA
	// 5. AOJDSADQIJOJIQDASDJOA
	// 6. AOJDSADQIOJOIQDASDJOA
	// 7. AOJDSAQDIJOJIDQASDJOA
	// 8. AOJDSAQDIOJOIDQASDJOA
	// 9. JDSAQIOJSDIDSJOIQASDJ
	// 10. JDSAQIOJSIDISJOIQASDJ
	// 11. JDSAQIOJISDSIJOIQASDJ
	// 12. JDSAQIOJIDSDIJOIQASDJ
	string str = "AOJSDIJOIQASDJ";
	cout << "The standard result is: " << endl << PalindromeMinAdd::solve_Standard(str) << endl;
	vector<string> palindromeStrs = PalindromeMinAdd::solve(str);
	cout<< "All the possible results are shown as below: " << endl;
	int index = 1;
	for(string& palindromeStr : palindromeStrs)
	{
		cout << index++ << ". " << palindromeStr << endl;
	}
	system("pause");
}
```

## 2.15 切割字符形成回文问题

**[题目]** 给定一个字符串 str，返回把 str 全部切成回文子串的最小分割数。

**[举例]** str = "ABA"。不需要切割，str 本身就是回文串，所以返回 0。Str = "ACDCDCDAD"。最少需要切 2 次变成 3 个回文子串，比如 "A"、"CDCDC" 和 "DAD"，所以返回 2。

**解题思路：**

1. 主要问题，从左向右的尝试模型，从 i 位置开始到 last 位置，以 str[i ~ last] 为起头的切割形式（要求其为回文），后续以 str[last+ 1 ~ end] 为子问题继续分割，逐步返回最小的分割数目。
2. 次要问题，范围尝试模型，即如何得到一张表，可以以常数时间查询 str[i ~ j] 的子字符串是否是回文。

```c++
namespace PalindromeMinCut
{
    int solve(const string& str)
    {
        if (str.empty())
            return -1;
        // 字符串的长度
        int len = str.size();
        // 最后一个位置填 -1
        // dp[i] 表示 str[i ~ end] 返回中全部切成回文需要的切割次数
        vector<int> dp(len + 1, 0);
        // 用于统一边界情况
        dp[len] = -1;
        vector<vector<bool>> p(len, vector<bool>(len, false));
        for (int i = len - 1; i >= 0; i--)
        {
            dp[i] = INT_MAX;
            for (int j = i; j < len; j++)
            {
                if (str[i] == str[j] && (j - i < 2 || p[i + 1][j - 1]))
                {
                    // j - i < 2 的意思是：i == j 或者 i 和 j 相邻，那么此时如果 str[i] == str[j]，由于两个字符中间没有其它字符，自然 i ~ j 为回文
                    // p[i + 1][j - 1] 是一个道理，头上两个字符相同，中间又是回文，那么总体的字符串也一定是回文
                    p[i][j] = true;
                    // 遍历以 str[i ~ j] 为 str[i ~ end] 的初始回文分割（已经确定了 str[i ~ j] 是回文）的情况下，str[i ~ end] 范围内的最少切割次数
                    // 值得注意的是，j >= i，所以 dp[j + 1] 一定是已知的（从后往前求）
                    dp[i] = min(dp[i], dp[j + 1] + 1);
                }
            }
        }
        return dp[0];
    }
}
void main()
{
	string str = "ACDCDCDAD";
	cout << PalindromeMinCut::solve(str)<<endl;
	str = "ABACDCHEA";
	cout << PalindromeMinCut::solve(str) << endl;
	str = "AAAAAA";
	cout << PalindromeMinCut::solve(str) << endl;
	system("pause");
}
```

## 2.16 移除字符形成回文问题

**[题目]** 对于一个字符串，从前开始读和从后开始读是一样的，我们就称这个字符串是回文串。例如 "ABCBA”，"AA"，"A" 是回文串，而"ABCD"，"AAB" 不是回文串。牛牛特别喜欢回文串，他手中有一个学符串 s，牛牛在思考能否从字符串中移除部分（0 个或多个）字符使其变为回文串，并且牛牛认为**空串不是回文串**。牛牛发现移除的方案可能有很多种，希望你来帮他计算一下一共有多少种移除方案可以使 s 变为回文串。对于两种移除方案，如果移除的字
符依次构成的序列不一样就是不同的方案。

例如，XXY，4 种，对应为 [X, X, Y, XX]，ABA，5 种，对应为 [A, B, A, ABA, AA]。

**[说明]**

​		这是今年的原题，提供的说明和例子都很让人费解。现在根据当时题自的所有测试用例，重新解释当时的题目。

**含义：**

1）"1AB23CD21"，你可以选择删除 A、B、C、D，然后剩下子序列 [12321]，只要剩下的子序列是同一个，那么就只算 1 种方法，和 A、B、C、D 选择什么样的删除顺序没有关系；

2）"121A1"，其中有两个 [121] 的子序列，第一个 [121] 是由 [位置0, 位置1, 位置2] 构成，第二个 [121] 是由 [位置0, 位置1, 位置4] 构成。这两个子序列被认为是不同的子序列。也就是说在本题中，**认为字面值一样但是位置不同的字符就是不同的**；

3）其实这道题是想求，str 中有多少个不同的子序列，每一种子序列只对应一种删除方法，那就是把多余的东西去掉，而和去掉的顺序无关；

4）也许你觉得我的解释很荒谬，但真的是这样，不然解释不了为什么，XXY 4 种 ABA 5 种，而且其他的测试用例都印证了这一点。

**解题思路：**

​		真是挺难想，依然是一个范围尝试的模型，dp\[i][j] 表示 str[i ~ j] 范围上的子字符串通过移除字符能够形成的回文种类数。那么其所有可能情况可以分成四种互斥的形式**（相并为全集，想与为空集）**，以 "ABA" 为例：

1. 通过移除字符，形成 **必须以 str[i] 起头** 且 **以 str[j] 结尾** 的回文，含有 [ABA, AA]；
2. 通过移除字符，形成 **必须不以 str[i] 起头** 但 **以 str[j] 结尾** 的回文，含有 [A]；
3. 通过移除字符，形成 **必须以 str[i] 起头** 但 **不以 str[j] 结尾** 的回文，含有 [A]；
4. 通过移除字符，形成 **必须不以 str[i] 起头** 且 **不以 str[j] 结尾** 的回文，含有 [B]；

以上是组成 dp\[i][j] 的所有情况，此时我们要通过这些情况来分析状态转移形式：

1. dp\[i + 1][j] 实际上就是 **必须不以 str[i] 起头** 而 **结尾不做要求** 的回文，即 **情况 2 + 情况 4**；
2. dp\[i][j - 1] 实际上就是 **起头不做要求** 而 **必须不以 str[j] 结尾**的回文，即 **情况 3 + 情况 4**；

那么明显的，我们的目标是求出 **情况 1 + 情况 2 + 情况 3 + 情况 4**，现在我们需要求出单独的 **情况 1** 和 **情况 4** 如何用表中的其它元素表示，**情况 1** 其实只需要分析，str[i] 和 str[j] 是否相同，如果相同，则 **情况 1** 为 dp\[i + 1][j - 1] + 1，如果不同则为 0，这是显然的；而 **情况 4 **自然就是 dp\[i + 1][j - 1]，这也是显然的。

```c++
// === 移除字符形成获取回文 === //
namespace PalindromeMinRemove
{
    int solve(const string& str)
    {
        if (str.empty())
            return -1;
        int N = str.size();
        vector<vector<int>> dp(N, vector<int>(N, -1));
        // Base case，明显的，对于单字符而言，其结果必然为 1
        // 而对双字符而言，根据两字符是否相同，结果为 3 或者 2
        for (int i = 0; i < N; i++)
            dp[i][i] = 1;
        for (int i = 0; i < N - 1; i++)
            dp[i][i + 1] = str[i] == str[i + 1] ? 3 : 2;
        // 然后这个问题依然依赖的是 左、左下、下 三个位置
        for (int i = N - 3; i >= 0; i--)
        {
            for (int j = i + 2; j < N; j++)
            {
                // 表示删剩下的回文必须不以首尾字符为端点字符
                int noLelf_noRight = dp[i + 1][j - 1];
                // 表示删剩下的回文必须以首尾字符为端点字符，+ 1 是因为中间全部不要，只要两头字符也满足要求
                int yesLeft_yesRight = str[i] == str[j] ? dp[i + 1][j - 1] + 1 : 0;
                // 而 dp[i + 1][j] 包括的情况是 noLeft_noRight + noLeft_yesRight
                // dp[i][j - 1] 包括的情况是 noLeft_noRight + yesLeft_noRight
                // 而目标是 noLelf_noRight + noLeft_yesRight + yesLeft_noRight + yesLeft_yesRight
                // 因而结果为
                dp[i][j] = dp[i + 1][j] + dp[i][j - 1] + yesLeft_yesRight - noLelf_noRight;
            }
        }
        return dp[0][N - 1];
    }
}
void main()
{
	string str1 = "XXY";
	cout << PalindromeMinRemove::solve(str1) << endl;
	string str2 = "ABA";
	cout << PalindromeMinRemove::solve(str2) << endl;
	string str3 = "XX";
	cout << PalindromeMinRemove::solve(str3) << endl;
	system("pause");
}
```

## 2.17 最小 k 数

**[题目]** 在一个无序数组中，求最小的第 k 个数。

**解题思路 1 ——一般方法：**

1. 数组中随机挑选一个数 x；
2. 数组中，比 x 小的放左边，比 x 大的放右边；
3. 如果中间区域的起始 index <= k - 1 &&  k - 1 <= 终止 index，那么此时的 x 就是目标结果，否则左边区域递归或者右边区域递归。

由于整个过程中，左右区域没有进行排序，所以最终的时间复杂度就是 $O(N)$。

```c++
```

**解题思路 2 —— BFPRT 方法：**

​		**主要目的在于避免快排中出现最差情况。**

1. 先将原数组分为若干个子数组，不妨设分出来的子数组为 5 个；
2. 然后取所有子数组的中位数；
3. 然后将取出来的所有中位数，拿到它们的中位数；
4. 然后用拿到的这个数去做荷兰国旗问题即可。

<img src="C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230630095529955.png" alt="image-20230630095529955" style="zoom:80%;" />

**值得注意的是：**是给每个子数组划分 5 个元素，不是把所有数一共划成 5 个子数组，这样能够保证，每个子数组的排序时间为常数时间**（只要元素个数是确定的，那么对任意排序方法而言，时间复杂度都是常数时间）**，那么所有数组分别排序之后的时间复杂度为 $O(N)$。

```c++
// === BFPRT 算法解第 k 小数问题 === //
namespace BFPRT
{
    // 返回原数组中第 k 小的元素
    vector<int> getMinKNums(const vector<int>& arr, const int& k)
    {
        if (arr.empty() || k < 1)
            return vector<int>();
        // 拿到第 k 小的数
        int minKth = getMinKthNum(arr, k);
        vector<int> result(k, 0);
        int index = 0;
        for (int i = 0; i < arr.size(); i++)
            if (arr[i] < minKth)
                // 把比目标小的数全部放进去
                result[index++] = arr[i];
        // 最后推入第 k 小的数
        result[index] = minKth;
        return result;
    }
    // 找到第 k 小的元素
    int getMinKthNum(const vector<int>& arr, const int& k)
    {
        // 为了不修改原数组
        vector<int> copy = arr;
        return select(copy, 0, arr.size() - 1, k - 1);
    }
    // 给定数组 arr 和目标范围，返回在对 arr 进行排序后，处于 i 位置的元素（其实就是返回第 i + 1 小的元素）
    int select(vector<int>& arr, const int& begin, const int& end, const int& i)
    {
        // 如果只有一个数，那就直接返回对应元素即可
        if (begin == end)
            return arr[begin];
        // 拿到我们的目标数，也就是那个可以保证数组中至少有 3N / 10 个数比它大的那个“非常讲究的数”
        int pivot = medianOfMedians(arr, begin, end);
        // 用目标数来划分 arr，把小的数放其左边，大的数放其右边，相等的数放中间
        vector<int> pivotRange = partition(arr, begin, end, pivot);
        if (i >= pivotRange[0] && i <= pivotRange[1])
            // 如果 i 在目标范围内，也直接返回 i 位置对应元素即可
            return arr[i];
        else if (i < pivotRange[0])
            // 如果 i （第 i + 1 小的数）在划分的目标区域往前，说明当前选用的 pivot 大了，需要重新划分，且 i 必然在前段区域
            return select(arr, begin, pivotRange[0] - 1, i);
        else
            // 如果 i （第 i + 1 小的数）在划分的目标区域往后，说明当前选用的 pivot 小了，需要重新划分，且 i 必然在后段区域
            return select(arr, pivotRange[1] + 1, end, i);
    }
    // 荷兰国旗问题，通过 pivotValue 对 arr 进行划分，将比 pivotValue 小的数放左边，大的数放右边，并返回中间区域的 [起始, 终止] 下标
    vector<int> partition(vector<int>& arr, const int& begin, const int& end, const int& pivotValue)
    {
        // a			b			c			d			e			f
        // lbound		begin								end			rbound
        //				cur
        // small 和 big 指向的是边界位置的 比 pivotValue 小的值 和 比 pivotValue 大的值
        // 所以在没有检查任何数的时候，这两个边界在 begin 和 end 范围之外
        int small = begin - 1;
        int big = end + 1;
        int cur = begin;
        while (cur != big)
        {
            if (arr[cur] < pivotValue)
                swap(arr, ++small, cur++);
            else if (arr[cur] > pivotValue)
                swap(arr, cur, --big);
            else
                cur++;
        }
        vector<int> range(2, 0);
        // 因为要返回中间目标 pivotValue 闭区间的下标
        // 所以要将小大边界分别 + 1 和 - 1
        range[0] = small + 1;
        range[1] = big - 1;
        return range;
    }
    // 拿到那个不会使划分变得很极端的很讲究的 pivotValue 值
    int medianOfMedians(vector<int>& arr, const int& begin, const int& end)
    {
        // 计算数组元素总个数
        int num = end - begin + 1;
        // 将原数组 5 个一组划分为若干数组，将这些子数组的中位数全部取出来，放到 mArr 数组中
        // 如果不能整除，则必然总量必然是变小了，此时要 + 1 来保证该数组能存放所有子数组形成的中位数
        int offset = num % 5 == 0 ? 0 : 1;
        vector<int> mArr(num / 5 + offset, 0);
        for (int i = 0; i < mArr.size(); i++)
        {
            // 从 begin 开始
            int beginI = begin + i * 5;
            // 因为是左右闭区间，所以 + 4
            int endI = beginI + 4;
            // 找对应区间范围内子数组的中位数
            mArr[i] = getMedian(arr, beginI, min(end, endI));
        }
        // 值得注意的是，select 就是我们的第 k 小的主调函数，它的时间复杂度为 O(N)，所以这里直接用它来找中位数
        // 如果能找到其它方法，可以以 O(N) 的时间复杂度找到中位数，此处也可以用
        // 因为 mArr 的规模数量级其实和原数组是一样的。
        return select(mArr, 0, mArr.size() - 1, mArr.size() / 2);
    }
    // 拿到一个数组的中位数，先通过插入排序，然后拿中位数
    int getMedian(vector<int>& arr, const int& begin, const int& end)
    {
        // 先对数组目标区域进行插入排序
        insertionSort(arr, begin, end);
        // 拿到数组中目标区域内的起始和终止下标的和
        int sum = end + begin;
        // 取的是下中位数，如果 sum 是偶数，/ 2 就是目标中位数下标
        // 如果 sum 是奇数，比如 0 1 2 3，那么 (sum / 2) + (sum % 2) = 2，明显是下中位数
        int mid = (sum / 2) + (sum % 2);
        return arr[mid];
    }
    // 插入排序，逐步有序，时间复杂度为 O(N ^ 2)，[begin, end] 闭区间
    void insertionSort(vector<int>& arr, const int& begin, const int& end)
    {
        for (int i = begin + 1; i != end + 1; i++)
            for (int j = i; j != begin; j--)
                if (arr[j - 1] > arr[j])
                    swap(arr, j - 1, j);
                else
                    // 因为每一次都造成了局部有序，所以如果当前 arr[j - 1] 比 arr[j] 小，那么 arr[j - 1] 前面的数都比 arr[j] 小
                    break;
    }
    // 交换数组中的两个元素的位置
    void swap(vector<int>& arr, const int& index1, const int& index2)
    {
        int temp = arr[index1];
        arr[index1] = arr[index2];
        arr[index2] = temp;
    }
}
void main()
{
	vector<int> arr = RandVector(0, 40, 20);
	int k = 15;
	ShowVector(arr);
	vector<int> minKths = BFPRT::getMinKNums(arr, k);
	ShowVector(minKths);
	sort(arr.begin(), arr.end(), less<int>());
	ShowVector(arr);

	system("pause");
}
```

## 2.18 数的分解

**[题目]** 给定一个正数 1，裂开的方法有一种，(1)
给定一个正数 2，裂开的方法有两种，(1、1)、(2)
给定一个正数 3，裂开的方法有三种，(1、1、1)、(1、2) 、(3)
给定一个正数 4，裂开的方法有五种，(1、1、1、1)、(1、1、2) 、(1、3)、(2、2) 、(4)
给定一个正数 n，求裂开的方法数。

动态规划优化状态依赖的技巧。

**解题思路：**题目中，要求一个数在分解的过程中，**新分解的数不能比前面分解的数小**，那么设计一个函数 **f(limit, number)，意为将 number 分解，并且分解的过程中，第一个部分不要比 limit 小。**

```c++
// === 分解数字 === //
namespace SplitNumber
{
    // 暴力递归
    int solve1(const int& number)
    {
        if (number < 1)
            return 0;
        // 分割至少为 1
        return process(1, number);
    }
    // pre 表示之前已经划分了最大值，之后划分不可小于该值
    // rest 表示当前还剩下的待划分值
    int process(const int& pre, const int& rest)
    {
        // 结束位，说明给定的值被完全合法分割，则说明生成了一种可行解，返回 1
        if (rest == 0)
            return 1;
        // 如果能够进行的分割比剩余的数值大，说明当前是一种失败的分割，返回 0
        if (pre > rest)
            return 0;
        int ways = 0;
        for (int i = pre; i <= rest; i++)
            // 既然当前剩余的是 rest，且 pre <= rest，那么至少可以分割一个 pre 出来
            ways += process(i, rest - i);
        return ways;
    }
    // 动态规划
    int solve2(const int& number)
    {
        if (number < 1)
            return 0;
        // pre 的取值从 1 ~ number（还是从 0 开始取），rest 的取值从 0 ~ number
        // 所以目标长度应该为 number + 1
        int N = number + 1;
        vector<vector<int>> dp(N, vector<int>(N, 0));
        // 一. Base case
        // 1. 对角线元素，pre == rest，这种情况下必然存在一种（是间接知道的，因为其等价于 pre，rest = 0）
        // 2. 第一列 pre，rest = 0，全部填 1
        // 3. 如果 pre > rest，此时全部填 0，没有有效解
        for (int i = 1; i < N; i++)
        {
            dp[i][i] = 1;
            dp[i][0] = 1;
        }
        // 二. 分析递推关系
        // 从暴力递归中容易想到 dp[i][j] = dp[i][j - i] + dp[i + 1][j - i - 1] + dp[i + 2][j - i - 2]... + dp[j][0]
        // 容易看出，dp[i][j] 的依赖从与其同行的小 i 列的元素开始，沿左下方一直搜索
        // 三. 分析循环方式
        // 通过递归关系可以看出，循环应从下往上，从左至右
        for (int i = N - 2; i >= 1; i--)
            for (int j = i + 1; j < N; j++)
                for (int cur = i; cur <= j; cur++)
                    dp[i][j] += dp[cur][j - cur];
        // 返回初始切割为 1，待分割数为 number 的位置
        return dp[1][N - 1];
    }
    // 动态规划 + 斜率优化
    int solve3(const int& number)
    {
        if (number < 1)
            return 0;
        int N = number + 1;
        vector<vector<int>> dp(N, vector<int>(N, 0));
        for (int i = 1; i < N; i++)
        {
            dp[i][i] = 1;
            dp[i][0] = 1;
        }
        // 容易看出来 dp[i][j] 所依赖的第二个元素为 dp[i + 1][j - i - 1]
        // 而dp[i + 1][j] 所依赖的第一个元素为 dp[i + 1][j - i - 1]
        // 所以其实有 dp[i][j] = dp[i][j - i] + dp[i + 1][j]
        for (int i = N - 2; i >= 1; i--)
            for (int j = i + 1; j < N; j++)
                    dp[i][j] += dp[i][j - i] + dp[i + 1][j];
        // 返回初始切割为 1，待分割数为 number 的位置
        return dp[1][N - 1];
    }
}
void main()
{
	int destNumber = 50;
	// === 输出 204226 === //
	cout << SplitNumber::solve1(destNumber) << endl;
	cout << SplitNumber::solve2(destNumber) << endl;
	cout << SplitNumber::solve3(destNumber) << endl;
	system("pause");
}
```

## 2.19 满足搜索二叉树条件的最大拓扑结构

**[题目]** 给定一棵二叉树的头节点 head，已知所有节点的值都不一样，返回其中最大的且符合搜索二树条件的最大拓扑结构的大小。**拓扑结构：不是子树，只要能连起来的结构都算。**

**解题思路：**定义一个概念 “拓扑空间记录”，其针对某一个**指定的节点**，能够说明其下各个子结点能够为**其**贡献的满足搜索二叉树条件的拓扑结构的结点数。那么现在要做的事情就是，对一个节点而言，要想办法将其左右节点中，已知的其左右节点为它们贡献的满足搜索二叉树条件的结点数转移到当前节点上面来。

​		这个转移方法就是，对左树而言，不必沿途搜索其左路径，其自动满足，而搜索**左树的右路径**的时候，一直搜索，直到有一个节点，其对应的节点值大于当前目标节点，然后沿途删除当前节点所贡献的节点数值，此时左路径的搜索结束。对**右树而言，沿其左边界**进行搜索，搜索到第一个比目标节点小的位置，从这一点开始向上，沿途删除当前节点所贡献的节点数值。

<font color = red>**这样操作最后的时间复杂度为 O(N)，容易看出，整个过程中不需要检查重复的左右边界。**</font>

​		<font color = red>**这道题隐含的一个比较关键思想在于：在 BST 中，左树上的节点值必然小于根节点值；同理作用于右树，但是在一个非 BST 的树中，如果一个节点左节点节点值比根节点小，并且只看左子树，其是一个 BST；同理作用于其右子树，但最终形成的树可能并非 BST。**</font>

```c++
// === 最大搜索二叉树子结构问题 === //
namespace BiggestBSTTopologyInTree
{
    // 1. 暴力法求解
    // 找出 head 中，以 head 以及其所有子结点为根节点的所有子树能，能够出现的最大 BST 拓扑结构
    int BSTTopoSize1(Solutions::TNode* head)
    {
        if (head == NULL)
            return 0;
        int result = maxTopo(head, head);
        result = max(BSTTopoSize1(head->left), result);
        result = max(BSTTopoSize1(head->right), result);
        return result;
    }
    // 该函数的效果在于，仅找出以 h 为根节点的树中，以其下某个子结点（不一定是直接子结点） n 为起始
    // 能够形成的最大 BST 拓扑结构包含多少个节点
    // 相当于这个函数指定了根节点
    int maxTopo(Solutions::TNode* h, Solutions::TNode* n)
    {
        // isBSTNode 的局限性正如下面函数中的说明，不过好在，一旦出现有一个节点不存在于当前头结点的拓扑结构中，就会返回 0 而不会继续向下检查
        if (h != NULL && n != NULL && isBSTNode(h, n, n->data))
            return maxTopo(h, n->left) + maxTopo(h, n->right) + 1;
        return 0;
    }
    // 判断节点 n 是不是在节点 h 的搜索二叉树拓扑结构中
    // 以 n 的值为准，假装将其从头结点开始往下添加（实际操作的时候是看当前 n 移动到了哪一个头结点 h，所以修改的是 h）
    // 值得注意的是，这个函数不能检查到中间过程，也就是说最终如果返回的是 true，其不能保证从 h 沿途到 n 的过程中完全是 BST
    // 也就是说，在我们默认 h -> n 过程中是满足 BST 的情况下，这个函数才能正常工作
    bool isBSTNode(Solutions::TNode* h, Solutions::TNode* n, const int& value)
    {
        // 如果一直检查到 h 为空也没有检查到 n 实际在的位置，那么返回 false
        if (h == NULL)
            return false;
        // 如果沿着一路下来，始终满足 BST 规则，并且找到了 n 实际在的位置，那么返回 true
        if (h == n)
            return true;
        // 如果 n->value < h->value，如果 n 存在于 h 的搜索二叉树拓扑结构中，它应该向左子树移动，否则向右子树移动
        return isBSTNode(h->data > value ? h->left : h->right, n, value);
    }
    // 2. 递归套路
    int BSTTopoSize2(Solutions::TNode* head)
    {
        // 准备一张 map，其中的 key 表示的是某个子结点（该表记录的是针对某个节点的 BST 拓扑信息）
        // value 表示针对某个节点时，对应于 key 的子结点其对 BST 拓扑节点数量做出的贡献
        unordered_map<Solutions::TNode*, Record*> mp;
        int result = posOrder(head, mp);
        // 释放堆区空间
        for (auto it = mp.begin(); it != mp.end(); it++)
            if (it->second != NULL)
                // 由于 map 的自动填充操作，此时有可能会存在 NULL
                delete it->second;
        return result;
    }

    // 求出当 mp 是针对节点 h 的情况下，各个子结点为当前节点 h 的 BST 拓扑结构做出的节点数目贡献
    int posOrder(Solutions::TNode* head, unordered_map<Solutions::TNode*, Record*>& mp)
    {
        // 如果当前访问到空节点，其对其父节点的 BST 拓扑贡献必然为 0
        // 且此时不需要修改 mp
        if (head == NULL)
            return 0;
        // 拿到左右两个树对应的最大 BST 拓扑结点数，并修改 mp 中的对应节点（左子树的所有节点针对左节点，右子树的所有节点针对右节点）
        // 第一次到 h 节点
        int leftResult = posOrder(head->left, mp);
        // 第二次到 h 节点
        int rightResult = posOrder(head->right, mp);
        // 第三次到 h 节点

        // ***** 重要论述 ***** //
        // 这里最有意思的是在初始状态下的 mp 创建过程，最初 mp 中没有任何信息
        // 而当传入的 h->left 和 h->right 为 NULL 的时候，并不会对 mp 进行任何修改，并且 lr 和 rr 也可以正确地得到 NULL
        // 然后就可以正确地建立起叶子节点在 mp 中的信息（l 和 r 都是 0）
        // 以当前节点的值 h->data 为基准，将 h->left 子树上节点的数据（mp 中的）进行修改
        modifyMap(head->left, head->data, mp, true);
        // 以当前节点的值 h->data 为基准，将 h->right 子树上节点的数据（mp 中的）进行修改
        modifyMap(head->right, head->data, mp, false);
        // 这里涉及到 map 的自动填充操作，如果访问之前 mp 中不存在 key，此时会自动给 mp 的 value 填充一个默认值
        // 所以这里要求 value 必须要有一个无参的构造函数
        Record* leftRecord = mp.find(head->left)!= mp.end() ? mp[head->left] : NULL;
        Record* rightRecord = mp.find(head->right) != mp.end() ? mp[head->right] : NULL;
        // 加工出来对当前节点而言，其左子树和右子树各个节点对其的 BST 拓扑结构贡献是多少
        // 如果 lr 或 rr 为空
        // 1. 说明我们在 modifyMap 函数中直接删除了对应节点，那么对应子树的贡献为空，则设置为 0 即可
        // 2. 说明当前节点没有左右某个孩子（或都没有），那么自然其对应的左右树对其 BST 拓扑结构的贡献为 0
        int lbst = (leftRecord == NULL ? 0 : (leftRecord->l + leftRecord->r + 1));
        int rbst = (rightRecord == NULL ? 0 : (rightRecord->l + rightRecord->r + 1));
        mp[head] = new Record(lbst, rbst);
        return max(lbst + rbst + 1, max(leftResult, rightResult));
    }

    // s 表示当前搜索是否是左子树，若是则应该搜索右边界，否则搜索左边界
    // n 表示当前搜索到的节点
    // v 表示目标根节点对应的节点值，其用于判断当前节点的值是否满足 BST 规则
    // minus 表示
    int modifyMap(Solutions::TNode* curNode, const int& headValue, unordered_map<Solutions::TNode*, Record*>& mp, const bool& isLeftNode)
    {
        if (curNode == NULL || (mp.find(curNode) == mp.end()))
            return 0;
        Record* record = mp[curNode];
        // (s && n->data > v) 表示当前是沿左子树向下搜寻的右路径，若 n 节点的节点值大于目标根节点的节点值
        // 或者 ((!s) && n->data > v) 表示当前是沿右子树向下搜寻的左路径，若 n 节点的节点值小于目标根节点的节点值
        // 此时的节点是不满足 BST 需求的，需要向上删除沿途所有的由这两个节点对应子树引起的 BST 贡献数目
        // 值得注意的是，这里的条件同样适用于目标节点的直接左节点和右节点
        if ((isLeftNode && curNode->data > headValue) || ((!isLeftNode) && curNode->data < headValue))
        {
            // 删除对应节点，因为向上继续搜寻的过程中肯定无法再用到这个节点（保证拓扑结构连续）
            // 值得注意的是，删除这个节点并不会释放我们的堆区空间
            mp.erase(mp.find(curNode));
            // 计算该节点贡献的结点数（不要混淆的一点是 r->l 和 r->r 不是指代该节点子树上的所有节点）
            return record->l + record->r + 1;
        }
        else
        {
            // 如果目标是左树，则向右节点搜寻
            // 如果目标是右树，则向左节点搜寻
            int minus = modifyMap((isLeftNode ? curNode->right : curNode->left), headValue, mp, isLeftNode);
            if (isLeftNode)
                record->r = record->r - minus;
            else
                record->l = record->l - minus;
            mp[curNode] = record;
            // 继续返回 minus，使得沿途的所有值都得到修改
            return minus;
        }
    }
}
void main()
{
	Solutions::TNode* head = new Solutions::TNode(6);
	head->left = new Solutions::TNode(1);
	head->left->left = new Solutions::TNode(0);
	head->left->right = new Solutions::TNode(3);
	head->right = new Solutions::TNode(12);
	head->right->left = new Solutions::TNode(10);
	head->right->left->left = new Solutions::TNode(4);
	head->right->left->left->left = new Solutions::TNode(2);
	head->right->left->left->right = new Solutions::TNode(5);
	head->right->left->right = new Solutions::TNode(14);
	head->right->left->right->left = new Solutions::TNode(11);
	head->right->left->right->right = new Solutions::TNode(15);
	head->right->right = new Solutions::TNode(13);
	head->right->right->left = new Solutions::TNode(20);
	head->right->right->right = new Solutions::TNode(16);

	cout<<(BiggestBSTTopologyInTree::BSTTopoSize1(head))<<endl;
	cout<<BiggestBSTTopologyInTree::BSTTopoSize2(head)<<endl;
	system("pause");
}
```

## 2.20 完美洗牌问题

**[题目]** 给定一个长度为偶数的数组 arr，长度记为 2 * N。前 N 个为左部分，后 N 个为右部分。arr 就可以表示为 [L1, L2, .., Ln, R1, R2, .., Rn]，请将数组调整成[R1, L1, R2, L2, ..., Rn, Ln] 的样子。**目标是不用额外的空间的条件下。**

**解题思路：**如果可以像多米诺骨牌一样，从一个数出发，挨个挤出下一个数最终达到目标排序，那是最好的，但可惜的是，下标的循环归位是分为若干个循环的环，而不是一次性可以全部归位的。对于长度为 $$N= 3^k-1$$ 的数组，从 $$1, 3, 9, ...,3^{k-1} $$ 开始进行循环，一定可以遍历整个数组。

**原型算法：**如果一个整体数组，将其左边划分一部分，右边划分一部分，要求两个区间换个位置，此时只需要左右区间分别逆序，然后整体逆序即可。

**整体思路：**怎么搞，看下面的示意图就懂了。

<img src="C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230630091035434.png" alt="image-20230630091035434" style="zoom: 67%;" />

```c++
// 问题 1. 将一个数组 [L1 L2 L3 L4... R1 R2 R3 R4...] 转换为 [R1 L1 R2 L2 R3 L3 R4 L4...]
// 要求只是用有限个数的几个额外空间
// 数组的长度为 len，调整前的位置是 i，返回调整之后的位置
// 设下标不从 0 开始，从 1 开始
int modifyIndex1(int i, int len)
{
	// 仅考虑偶数个数的情况
	//	before	1	2	3	4	5	6	7	8
	//	after	5	1	6	2	7	3	8	4	
	if (i <= len / 2)
		return 2 * i;
	else
		return 2 * (i - (len / 2)) - 1;
}
// 效果和 modifyIndex1 一样，只是用了一个统一的公式
int modifyIndex2(int i, int len)
{
	return (2 * i) % (len + 1);
}
void shuffle(vector<int>& arr)
{
	// 仅在给定的数组是偶数个的情况下做洗牌操作
	if (!arr.empty() && (arr.size() & 1) == 0)
		shuffle(arr, 0, arr.size() - 1);
}
// 在给定范围内进行目标洗牌操作
void shuffle(vector<int>& arr, int L, int R)
{
	while (R - L + 1 > 0)
	{
		// 计算当前还未搞定的数组的长度
		int len = R - L + 1;
		// 基数
		int base = 3;
		// 记录当前要进行洗牌的子段有多少个起始点
		int k = 1;
		// 比如现在总长为 10，那么第一段应该划分出来 8（3 ^ 2 - 1）
		// 其实不就是看现在的最大的 n 使得 3 ^ n - 1 <= len，即 3 ^ n <= len + 1 吗，其中 n 从 1 开始取，对应最短数组为 2
		// 这种类似的问题的循环条件可以考虑为如下的形式
		// 先写出 base <= (len + 1)，然后代入 len == 2 的时候，此时不应该执行循环，所以应该将循环条件除以一个 3，然后再看，刚好满足要求
		// 这个地方需要注意的是，能不能取等号我们在边界位置取值来确定，而作为指数运算的条件，要增加一轮或减少一轮一定是通过乘除基数来完成
		// 不能妄想通过修改等号来达到目的
		while (base <= (len + 1) / 3)
		{
			base *= 3;
			k++;
		}
		// 这样想，如果我们现在要先得到前 8 个位置的 R1 L1 R2 L2 R3 L3 R4 L4，此时需要连续的 8 个 L1 L2... R1 R2... R4
		// 所以一共要换 4 个数到前面来
		int half = (base - 1) / 2;
		// 此时拿到的是这个区间内的上中位数
		int mid = (L + R) / 2;
		// 从下面代码也看出，rotate 的目标子区间是 [L + half, mid] [mid + 1 mid + half]
		rotate(arr, L + half, mid, mid + half);
		// 目标子区间的起始下标为 L，子区间的长度为 base，该区间内能够执行的循环次数为 k 次
		cycles(arr, L, base - 1, k);
		// 下标 + 区间长度，得到的就是区间外的第一个元素的下标
		L = L + base - 1;
	}
}
// 从 start 位置开始，往右边 len 长度这一段，进行下标连续置换操作
// 出发的位置为 1、3、9... n (n = 3 ^ (k - 1) < 3 ^ k - 1)
void cycles(vector<int>& arr, int start, int len, int k)
{
	// 找到每一个出发的位置 trigger，即 1、3、9、...，一共具有 k 个
	// 对每一个元素，加上一个偏置 start - 1 即可，就可以很完美地利用以 1 起始的下标函数 modifyIndex1 来完成 0 起始的下标变换任务
	for (int i = 0, trigger = 1; i < k; i++, trigger *= 3)
	{
		// 拿到 trigger 位置上的值
		int preValue = arr[trigger + start - 1];
		// 计算出该 trigger 位置上的数应该去向哪一个位置
		int cur = modifyIndex1(trigger, len);
		// 因为一旦 cur == trigger，说明已经完成一个循环，此时起始的 trigger 位置元素还没有被放入正确的值
		// 这一步在循环外做
		while (cur != trigger)
		{
			// 因为要用排序后的值来替代原本 cur 位置的值，所以需要先记录原来 cur 位置的值
			int temp = arr[cur + start - 1];
			arr[cur + start - 1] = preValue;
			preValue = temp;
			// 计算当前被挤出来的值，应该去往哪一个位置
			cur = modifyIndex1(cur, len);
		}
		arr[cur + start - 1] = preValue;
	}
}
// 将 arr 划分成两块 arr[L ~ M] 和 arr[M + 1 ~ R]
// 然后将两块区域进行原地反转（不消耗额外空间复杂度的情况下）
void rotate(vector<int>& arr, int L, int M, int R)
{
	reverse(arr, L, M);
	reverse(arr, M + 1, R);
	reverse(arr, L, R);
}
// 将 arr[L ~ R] 中的元素按中心对称进行位置交换
void reverse(vector<int>& arr, int L, int R)
{
	while (L < R)
	{
		int temp = arr[L];
		arr[L] = arr[R];
		arr[R] = temp;
		L++;
		R--;
	}
}
```

**[推广]** Wiggle sort 问题。要求在不使用常数项以上的空间的情况下，将一个无序数组 [a1, a2 ,a3, ..., an] 重组为，[ai, aj, ak, ..., am]，且有关系
$$
a_i \leq a_j \geq a_K...
$$
即各个数之间两两大小关系为小于等于和大于等于交错。

**解题思路：**第一步通过堆排序（额外空间复杂度为 $O(1)$）完成升序排序，对数组长度为偶数的情况，执行一次完美洗牌，然后数之间两两交换位置即可；对数组长度为奇数的情况，把第一个数单独拿出来，后面的所有数执行完美洗牌即可。

```c++
// 问题2. 给定一个数组，在经过 wiggle 洗牌之后得到数组之间元素关系为
// num1 <= num2 >= num3 <= num4 >= num5...
void wiggleSort(vector<int>& arr)
{
	if (arr.empty())
		return;
	// 先通过堆排序（常数额外空间复杂度，这里直接调用系统排序）
	sort(arr.begin(), arr.end(), less<int>());
	if (arr.size() & 1 == 1)
		// 奇数情况比较简单，直接从第二个位置开洗
		shuffle(arr, 1, arr.size() - 1);
	else
	{
		// 偶数情况洗完之后，元素之间两两互换位置即可
		shuffle(arr, 0, arr.size() - 1);
		for (int i = 0; i < arr.size(); i += 2)
		{
			int temp = arr[i];
			arr[i] = arr[i + 1];
			arr[i + 1] = temp;
		}
	}
}
void main()
{
	vector<int> arr{ 1,2,3,4,5,6,7,8,9,10,11,12 };
	shuffle(arr);
	for (auto it = arr.begin(); it != arr.end(); it++)
		cout << *it << ", ";
	cout << endl;
	arr = vector<int>{ 1,2,3,4,5,6,25,7,8,9,10,11,12 };
	wiggleSort(arr);
	for (auto it = arr.begin(); it != arr.end(); it++)
		cout << *it << ", ";
	cout << endl;
	system("pause");
}
```

## 2.21 字符匹配问题

**[题目]** 判定一个由 [a-z] 字符构成的字符串和一个包含 '.' 和 '*' 通配符的字符串是否匹配。通配符 '.' 匹配任意单一字符**（不能表示空字符）**，'\*' 匹配任意多个字符包括 0 个字符**（其必须和前面的字符组合，可以生成任意个数的前面的字符，其也可以和 '.' 字符匹配，生成任意个数的相同的字符）**。字符串长度不会超过 100，字符串不为空。

**输入描述：**

​		字符串 str 和包含通配符的字符串 pattern。1<= 字符串长度 <=100 

**输出描述：**

​		true表示匹配，false表示不匹配

**解题思路：**

​		很经典的思路，给定一个函数 process(str, exp, start1, start2)，表示原字符串 str[start1 ~ end] 和带有配对符号的字符串 exp[start2 ~ end] 是否能够完全匹配**（相当于从后往前，从前往后也行？）**。 

```c++
// 1. 暴力递归法
// 判断输入字符串是否有效
bool isValid(const string& str, const string& exp)
{
    for (int i = 0; i < str.size(); i++)
        // 要求原始的 str 必须是 a ~ z 字符中的一个
        if (str[i] < 'a' || str[i]>'z')
            return false;
    for (int i = 0; i < exp.size(); i++)
        // 要求第一个字符不能是 *，并且不能有两个 * 连续
        if (exp[i] == '*' && (i == 0 || exp[i - 1] == '*'))
            return false;
}
// 判断输入的两个字符串是否匹配
bool isMatch(const string& str, const string& exp)
{
    if (str.empty() || exp.empty())
        return false;
    // 表示 str[0 ~ end] 和 exp[0 ~ end] 能否完全匹配
    return isValid(str, exp) && process(str, exp, 0, 0);
}
// 递归过程，strStart 表示 str 的起始下标，expStart 表示 exp 的起始下标
bool process(const string& str, const string& exp, int strStart, int expStart)
{
    // Base case
    if (expStart == exp.size())
        // 如果具有通配符的字符串起始下标已经到达终止位置，此时不可能有其它操作，所以只需要看当前是不是对 str 进行了完全配对
        // 即如果 str 的起始下标也到达了终止位置，说明完全配对，返回 true，否则返回 false
        return strStart == str.size();
    // ***** 非常关键的一点在于 expStart 不能压在一个 * 字符上面，否则整个递归的含义将很复杂 ***** //
    // 而这个过程是可以保证这一点的，下面再具体分析
    if (expStart == exp.size() - 1 || exp[expStart + 1] != '*')
    {
        // 只要 exp 当前位置的下一个位置不是 *（当然，要先保证当前位置不是最后一个位置）
        // 此时只需要比较两字符串的当前位置字符是否相同，然后把问题交给下一个位置即可
        // 1. 若 strStart == str.size() 即如果当前 exp 没到最后的位置并且下一个位置不是 *，而 str 已经走完，此时不可能匹配
        // 2. 若 str[strStart] != exp[expStart] 同理，因为下一个位置不是 *，此时没有操作空间，此时也不可能匹配
        // 3. 若 当前位置字符匹配了，但后续不匹配，依然不可能匹配
        // ** 看这里，因为 exp[expStart + 1] != '*'，所以这里我们 expStart 向下面跳，必然不会踩到 *
        return strStart != str.size() && str[strStart] == exp[expStart] && process(str, exp, strStart + 1, expStart + 1);
    }
    // 如果 exp[expStart] == str[strStart] 或者 exp[expStart] == '.'，说明两字符串在当前对应 start 位置的字符匹配
    // 检查 process(str, exp, strStart, expStart + 2) 的含义是，将 str[strStart] 与 exp[expStart ~ expStart + 1] 进行配对
    // 而随着 strStart++，这个配对过程连续进行（就在这一级递归层内部），说明将 str 中多个相同字符的与 exp[expStart ~ expStart + 1] 进行配对
    while (strStart != str.size() && (exp[expStart] == str[strStart] || exp[expStart] == '.'))
    {
        if (process(str, exp, strStart, expStart + 2))
            return true;
        strStart++;
    }
    // ** 看这里，因为已经保证了 exp[expStart + 1] == '*'，所以这里向下跳两个也必然不是 *
    // 如果 exp[expStart] != str[strStart]，这里相当于尝试的是将 exp 中的 "x*" 变为空字符，然后从对应的后续位置继续进行配对
    // 这里其实隐含了一个 Base case，就是在 strStart == str.size() 的情况下，会不停向下跳，直到当前的 expStart + 1 位置不是 '*'
    return process(str, exp, strStart, expStart + 2);
}
```

**动态规划：**

​		这道题有一个不同的地方在于其根据暴力递归得到的 Base case 不足以填充所有的表，所以需要先根据实际情况，构造出满足所有状态转移的求取过程后，再填表。

```c++
// 2. 动态规划法
bool isMatch_DP(const string& str, const string& exp)
{
    if (str.empty() || exp.empty())
        return false;
    if (!isValid(str, exp))
        return false;
    int strLength = str.size();
    int expLength = exp.size();
    auto dp = getDP(str, exp);
    // 递归关系，根据递归表达式可以看出，[i][j] 元素依赖于其右下角元素以及其右二列，同行往下的所有元素（可能）
    // 所以确定递推的顺序为：从下往上，从右往左，而且是列优先（行优先也是可以的）
    // 需要注意的是这里的起始位置，如果用的是 dp 的 size，这里应该稍作修改
    for (int j = expLength - 2; j >= 0; j--)
        for (int i = strLength - 1; i >= 0; i--)
        {
            // 和暴力递归一样的讨论方式
            if (exp[j + 1] != '*')
                // 同时满足当前位置字符相同且后续也相同，才能设置为 true
                dp[i][j] = ((str[i] == exp[j] || exp[j] == '.') && dp[i + 1][j + 1]);
            else
            {
                int strIndex = i;
                // 如果对应位置的元素不相等会直接执行循环体外的语句
                while (strIndex != strLength && (exp[j] == str[strIndex] || exp[j] == '.'))
                {
                    // 值得注意的是，在第一次循环的时候，判断的就是把 exp[j ~ j + 1] 变为空，直接比较后续和 str[i] 的情况
                    // 即使我们知道 exp[j] == str[i]
                    dp[i][j] = dp[strIndex][j + 2];
                    if (dp[i][j])
                        break;
                    strIndex++;
                }
                // 如果 dp[i][j] 在上一步中已经被设置为 true 了，这里就不需要再进行操作
                if(!dp[i][j])
                    dp[i][j] = dp[strIndex][j + 2];
            }
        }
    // 返回结果，即 start 均从 0 开始
    return dp[0][0];
}
// 生成对应的动态规划表
vector<vector<bool>> getDP(const string& str, const string& exp)
{
    // 将整张表初始化为 false，然后只需要设置几个可能为 true 的 Base case 对应位置即可，对应为
    // 1. 两字符串均到达终止位置时，true
    // 2. exp 到达终止位置，str 没到终止位置，全 false
    // 3. str 到达终止位置，exp 没到终止位置，这个需要具体讨论
    // 4. exp 到达最后一个位置（不是终止位置），因为我们不讨论起始为 * 的情况，所以此时 exp 最多只能对应 str 中的单个字符
    // 其它情况下都无法进行配对（终止位置情况已经讨论），所以只有在 str.rbegin() == exp.rbegin() 的情况下，在对应位置为 true
    int strLength = str.size();
    int expLength = exp.size();
    // 默认全部初始化为 false
    vector<vector<bool>> dp(strLength + 1, vector<bool>(expLength + 1, false));
    // 两者均到达终止位置，说明有有效配对
    dp[strLength][expLength] = true;
    // 先设置 strStart 到达终止而 expStart 还未到达终止的情况
    for (int j = expLength - 2; j >= 0; j -= 2)
    {
        // 从倒数第二个位置开始看，如果直接踩在 * 上面，最后一个位置肯定是无法配对的
        // 并且在 j 位置不为 * 的情况下，还要求其下一个位置必须是 *，此时 j 和 j + 1 位置才能变成空
        // 容易理解错误的一点是，* 最多只能消除其前面一个位置的字符
        if (exp[j] != '*' && exp[j + 1] == '*')
            dp[strLength][j] = true;
        else
            // 因为其它位置已经初始化为 false 了
            break;
    }
    if (strLength > 0 && expLength > 0)
        if (exp[expLength - 1] == '.' || str[strLength - 1] == exp[expLength - 1])
            dp[strLength - 1][expLength - 1] = true;
    return dp;
}	
void main()
{
	string str = "abcccdefg";
	string exp = "ab.*d.*e.*";
	cout << RegularExpressionMatch::isMatch(str, exp) << endl;
	cout << RegularExpressionMatch::isMatch_DP(str, exp) << endl;
	system("pause");
}
```

## 2.22 数组最大异或和

**[题目]** **数组异或和的定义：**把数组中所有的数异或起来得到的值给定一个整型数组 arr，其中可能有正、有负、有零，求其中子数组的最大异或和。

**[举例]**
arr = [3]
数组只有1个数，所以只有一个子数组，就是这个数组本身，最大异或和为 3。
arr = [3, -28, -29, 2]
子数组有很多，但是 [-28, -29] 这个子数组的异或和为 7，是所有子数组中最大的。

**解题思路1——逆天暴力法：**不实现，时间复杂度 $O(N^3)$，这个太笨了，用下面代码的对数器，很简单时间复杂度还仅仅是 $O(N^2)$；

**解题思路2——前缀异或和优化：**由于二进制异或的特殊性（无进位加法），arr[0 ~ i] ^ arr[0 ~ start - 1] = arr[start ~ i]。那么可以先求出所有的前缀异或和，此时的时间复杂度为 $O(N^2)$；

**解题思路3——前缀树实现：**一个贪心：从二进制高位开始，对符号位而言，其希望遇到的是与本身相同的数字，因为此时异或出来的结果是 0，表示最终的结果是正数；而对其它位而言，其希望遇到的数字是与本身不同的数字，因为此时异或出来的结果是 1。

```c++
// === 最大异或和问题 === //
	namespace MaxEOR
	{
		// 1. 暴力法
		int solve1(const vector<int>& arr)
		{
			if (arr.empty())
				return 0;
			int result = INT_MIN;
			for (int i = 0; i < arr.size(); i++)
			{
				int eor = 0;
				// 表示以 arr[i] ^ arr[i + 1] ^ arr[i + 2]... arr[j] 的异或结果
				for (int j = i; j < arr.size(); j++)
				{
					eor ^= arr[j];
					result = max(result, eor);
				}
			}
			return result;
		}

		// 前缀树节点
		struct Node
		{
			Node* nexts[2] = { NULL ,NULL };
		};
		// 前缀树
		struct NumTrie
		{
			Node* head = new Node();
			// 给定一个数，根据其二进制形式把节点添加到前缀树中
			void add(int num)
			{
				Node* cur = head;
				// 由于高位的数字影响比较大，所以从最高位开始添加
				for (int move = 31; move >= 0; move--)
				{
					// 查看 move 位上的数是什么
					int path = (num >> move) & 1;
					// 根据当前位是 0 还是 1，选择将其挂在上层节点的左边还是右边（数组 index 0 表示左边，index 1 表示右边）
					// 如果原本的路径已经存在，则不需要增加新的节点
					cur->nexts[path] = cur->nexts[path] == NULL ? new Node() : cur->nexts[path];
					// 将 cur 继续向下移动，直到把整个数都填充到前缀树中
					cur = cur->nexts[path];
				}
			}
			// 给定一个数，找到其在当前前缀树中表示的数的最大异或和
			int maxXor(int num)
			{
				Node* cur = head;
				int result = 0;
				for (int move = 31; move >= 0; move--)
				{
					// 同理，先找出 move 位上的数是 0 还是 1
					int path = (num >> move) & 1;
					// 根据 move 位的情况，找到当前希望的路径，对最高位而言，其希望路径和 move 位状态一样
					// 对非最高位而言，其希望路径和 move 位状态相反
					int best = move == 31 ? path : (path ^ 1);
					// 然后根据当前希望路径是否存在，确定真正的路径
					best = cur->nexts[best] != NULL ? best : (best ^ 1);
					// 然后把真正的路径移动到对应位置和 move 位的数字进行异或（path 已经被移动到最低位，所以操作的时候是先异或再移位）
					result |= (path ^ best) << move;
					// 根据当前选择的路径继续向下移动
					cur = cur->nexts[best];
				}
				return result;
			}
		};

		// 2. 前缀树贪心
		int solve2(const vector<int>& arr)
		{
			if (arr.empty())
				return 0;
			int result = INT_MIN;
			int eor = 0;
			NumTrie numTrie;
			// 添加 0 对应的前缀树路径，代表以 arr[0 ~ i] 范围内的异或和取其本身为最大值的情况
			// 值得注意，此处的主要思想依然是 arr[0 ~ i] ^ arr[0 ^ start - 1] = arr[start, i]
			// 所以是通过改变 i，即异或范围的最后一个位置，然后通过其和不同 start 的 arr[0 ^ start - 1] 进行异或来获得不同起头的位置结果
			numTrie.add(0);
			// 上面说过了，每一次循环看的是 arr[0, 1, 2, ... ~ i] 中的最大异或和
			// 对 i 小的情况，比如 i 为 0 的时候，此时前缀树中只需要有 0 一个数，代表此时仅考虑 arr[0] 一种情况
			// 然后将 arr[0] 加入到前缀树中，下一次在看 i = 1 的时候，由于前缀树中已经存储了 arr[0 ~ 0] 的情况，所以自然也能够考虑到对应情况
			// 依次类推，说实话，确实很巧妙啊
			for (int i = 0; i < arr.size(); i++)
			{
				eor ^= arr[i];
				result = max(result, numTrie.maxXor(eor));
				numTrie.add(eor);
			}
			return result;
		}
	}
void main()
{
	for (int i = 0; i < 20; i++)
	{
		auto arr = RandVector(-20, 50, 10, 1);
		int result1 = MaxEOR::solve1(arr);
		int result2 = MaxEOR::solve2(arr);
		cout << "The result1 is: " << result1 << ", the result2 is: " << result2 << endl;
	}
	system("pause");
}
```

## 2.23 打气球问题

**[题目]** 给定一个数组 arr，代表一排有分数的气球。每打爆一个气球都能获得分数，假设打爆气球的分数为 X，获得分数的规则如下：

1）如果被打爆气球的左边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 L；如果被打爆气球的右边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 R。获得分数为 L\*X\*R；

2）如果被打爆气球的左边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 L；如果被打爆气球的右边所有气球都已经被打爆。获得分数为 L\*X；

3）如果被打爆气球的左边所有的气球都已经被打爆：如果被打爆气球的右边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 R：如果被打爆气球的右边所有气球者经被打爆。获得分数为 X*R；

4）如果被打爆气球的左边和右边所有的气球都已经被打爆。获得分数为 X。

自标是打爆所有气球，获得每次打爆的分数。通过选择打爆气球的顺序，可以得到不的总分，请返回能获得的最大分数。

**解题思路：**给出一个函数 f(L, R)，其表示的是，在 L - 1 位置和 R + 1 位置上的气球都没爆的情况下，以 L ~ R 之间每一个气球作为最后一个被打爆的气球的情况下，能够获得的最大分数。

```c++
// === 打气球问题 === //
namespace BurstBallons
{
    // 方法1. 暴力递归
    int maxCoins1(const vector<int>& arr)
    {
        if (arr.empty())
            return 0;
        if (arr.size() == 1)
            return arr[0];
        int N = arr.size();
        // 两头各加一个 1，可以使得边界处理比较方便
        vector<int> support(N + 2, 1);
        // 给 support[1 ~ N] 之间的所有元素赋值，其它位置默认为 1
        for (int i = 1; i < N + 1; i++)
        {
            support[i] = arr[i - 1];
        }
        // 其实左右没有气球的情况可以看作左边有一个数值为 1 的气球以及右边有一个数值为 1 的气球
        return process(support, 1, N);
    }
    // 表示 L - 1 位置和 R + 1 位置没有被打爆的情况下
    // 以 arr[L ~ R] 中的任意一个位置作为最后一个打爆的气球的情况下，能够得到的最高分数
    int process(const vector<int>& arr, int L, int R)
    {
        // 因为已经保证 arr[L - 1] 和 arr[R + 1] 没有被打爆，所以如果 L == R，此时直接返回
        if (L == R)
            return arr[L - 1] * arr[L] * arr[L + 1];
        // 先比较最后打爆 L 和最后打爆 R 的两种情况
        // 这两种情况的特殊之处在于，最后打爆 L 的情况，其左边没有子过程
        // 最后打爆 R 的情况，其右边没有子过程，也可以将这两个过程融合到循环中，不过要考虑增加 Base case
        int result = max(
            // 只要最后打爆的是 L ~ R 中的任意一个气球 i，那么打爆这个气球所赚取的分数一定是 arr[L - 1] * arr[i] * arr[R + 1]
            arr[L - 1] * arr[L] * arr[R + 1] + process(arr, L + 1, R),
            arr[L - 1] * arr[R] * arr[R + 1] + process(arr, L, R - 1)
        );
        for (int i = L + 1; i <= R - 1; i++)
        {
            result = max(
                result,
                // 正如前面所说，此时会产生两个子过程，那么如果 i 直接取到 L 和 R，会出现 Base case 中没有囊括的情况
                arr[L - 1] * arr[i] * arr[R + 1] + process(arr, L, i - 1) + process(arr, i + 1, R)
            );
        }
        return result;
    }
    // 方法2. 动态规划
    int maxCoins2(const vector<int>& arr)
    {
        if (arr.empty())
            return 0;
        if (arr.size() == 1)
            return arr[0];
        int N = arr.size();
        // 两头各加一个 1，可以使得边界处理比较方便
        vector<int> support(N + 2, 1);
        // 给 support[1 ~ N] 之间的所有元素赋值，其它位置默认为 1
        for (int i = 1; i < N + 1; i++)
            support[i] = arr[i - 1];
        // 只用 dp[1 ~ N][1 ~ N] 范围内的结果
        vector<vector<int>> dp(N + 2, vector<int>(N + 2, 0));
        // 1. Base case，对角线元素首先初始化
        for (int i = 1; i <= N; i++)
            dp[i][i] = support[i] * support[i - 1] * support[i + 1];
        // 2. 递推过程分析，[L][R] 依赖于 [L + 1][R] 和 [L][R - 1] 以及 [L][L ~ R - 2] 以及 [L + 2 ~ R][R]
        // 综合而言，依赖的是 [L][L ~ (R - 1)] 以及 [(L + 1) ~ R][R]
        // 明显的，dp 表是一张左下角无效的表，所以每个元素依赖的是其同行左边从对角线开始的元素以及同列下边从对角线开始的元素
        // 所以确定循环从下往上，从左往右，且按行循环
        for (int L = N - 1; L >= 1; L--)
        {
            int result = INT_MIN;
            for (int R = L + 1; R <= N; R++)
            {
                // 因为这个部分一定是要乘以这个数
                int boundaryMultiplcation = support[L - 1] * support[R + 1];
                result = max(
                    boundaryMultiplcation * support[L] + dp[L + 1][R],
                    boundaryMultiplcation * support[R] + dp[L][R - 1]
                );
                for (int i = L + 1; i <= R - 1; i++)
                    result = max(
                        result,
                        boundaryMultiplcation * support[i] + dp[L][i - 1] + dp[i + 1][R]
                    );
                dp[L][R] = result;
            }
        }
        return dp[1][N];
    }
}
void main()
{
	vector<int> arr = { 4, 2, 3, 5, 1, 6 };
	cout << BurstBallons::maxCoins1(arr) << ", " << BurstBallons::maxCoins2(arr) << endl;
	system("pause");
}
```

## 2.24 汉诺塔问题进阶版本

**[题目]** 汉诺塔游戏的要求把所有的圆盘从左边都移到右边的柱子上，给定一个整型数组 arr，其中只含有 1、2 和 3，代表所有圆盘目前的状态，1 代表左柱，2 代表中柱，3 代表右柱 ，arr[i] 的值代表第 i+1 个圆盘的位置。
比如，arr = [3, 3, 2, 1]，代表第 1 个圆盘在右柱上、第 2 个圆盘在右柱上、第 3 个圆盘在中柱上、第 4 个圆盘在左柱上。
如果 arr 代表的状态是最优移动轨迹过程中出现的状态，返回 arr 这种状态是最优移动轨迹中的第几个状态；如果 arr 代表的状态不是最优移动轨迹过程中出现的状态，则返回 -1。

**解题思路：**以最顶上的圆盘是否被放到 to 上为一个分割，对原问题进行分解，如果其已经被放到 to 上，那么我们可以计算此时 “整的步数” 是多少步，然后递归或循环求解 “不满当前高位” 的步数有多少；如果最顶圆盘没有被放到 to 上，说明此时没有 “整的步数”，则直接递归或循环求解 “不满当前高位” 的步数有多少。

```c++
// === 汉诺塔问题进阶版 === //
namespace HanoiProblem
{
    int solve1(const vector<int>& arr)
    {
        if (arr.empty())
            return -1;
        // 表示初始状态下，from 柱的下标为 1，other 柱的下标为 2，to 柱的下标为 3
        return process(arr, arr.size() - 1, 1, 2, 3);
    }
    // process 表示的是，在将 0 ~ i 盘子从 from 转移到 to 的过程中，各个盘子在给定的 arr 状态下，一共已经进行到汉诺塔问题的第多少步
    // 0 盘子表示的是最顶层的盘子，i 盘子表示的是最底层的盘子
    // 值得注意的是，最初的汉诺塔问题的递归方法就是最优解，其一共需要 2 ^ N - 1 步 
    int process(const vector<int>& arr, int i, int from, int other, int to)
    {
        // 如果 i 为 -1，说明当前没有盘子需要转移，则返回 0 即可
        if (i == -1)
            return 0;
        // 我们先分析汉诺塔问题的步骤，也就是说把 0 ~ i 盘子全部从 from 转移到 to 的过程
        // 过程 1. 将 0 ~ i - 1 盘子转移到 other
        // 过程 2. 将 i 盘子转移到 to
        // 过程 3. 将 0 ~ i - 1 盘子转移到 to
        // 在最优解的情况下，整个过程中底层的盘子 i 不可能在 other 上（关键点），所以如果中途出现了这种情况，则必然是错误的，则直接返回 -1
        if (arr[i] != from && arr[i] != to)
            return -1;
        // 如果 i 盘子在 from 上，则此时必然处于过程 1（对将 0 ~ i 盘子从 from 移动到 to 这个问题而言）
        // 则此时需要看 0 ~ i - 1 盘子从 from 移动到 other（对 0 ~ i 规模问题而言）的子问题处于哪一个阶段
        if (arr[i] == from)
            return process(arr, i - 1, from, to, other);
        else
        {
            // 说明此时必然处于 过程 2 或者 过程 3
            // 那么对 i - 1 的问题规模而言，此时必然已经处于在将 0 ~ i - 1 盘子从 other 上移动到 to 这个过程
            // 如果 i == 0，说明最上层的盘子也已经被移动到 to 上了，此时问题应该结束，此时 i - 1 = -1，刚好对应正常结束的 Base case，返回 0
            // rest 表示的是过程 3 已经进行了多少步，由于进行的是过程 3，所以是将 0 ~ i - 1 盘子从 other 转移到 to
            int rest = process(arr, i - 1, other, from, to);
            if (rest == -1)
                return -1;
            // 由于已经把 0 ~ i - 1 盘子转移到了 other 上，所以这个过程一共已经使用了 2 ^ (i + 1 - 1) - 1 步
            // 其中 i + 1 - 1 是由于此时实际转移的是 i 个盘子，而又因为 i 盘子已经在 to 上了，所以至少已经走了 2 ^ i 步
            return (1 << i) + rest;
        }
    }
    int solve2(const vector<int>& arr)
    {
        if (arr.empty())
            return -1;
        int from = 1;
        int other = 2;
        int to = 3;
        int i = arr.size() - 1;
        int result = 0;
        int temp = 0;
        // 观察原递归，实际上 i 就是一个从 arr.size() - 1 不断减小直到等于 -1 的时候结束的过程
        // 所以可以将递归转化为一个循环
        while (i >= 0)
        {
            // 其实究竟对应于哪个状态，完全就是看当前处理的 i 是哪一个盘子，然后通过 i 是处于 过程 1 还是 过程 3 来计算总的步数
            if (arr[i] != from && arr[i] != to)
                return -1;
            // 最后感觉其实就是一个进制问题，如果 arr[i] == to，说明应该进位，所以直接把低位上的数计入到 result 中
            // 比如 10 进制中 113，此时我们应该把最高位的 100 记下来，然后把低位的东西丢给低位的循环或递归去做
            // 而对 99 而言，其没有满 100，所以不计入任何结果，而是直接将其丢到低位的循环或递归中去求解
            if (arr[i] == to)
            {
                // 实际上是 (i - 1) + 1，i - 1 表示当前其实研究的是子问题，+ 1 表示盘的个数
                result += 1 << i;
                // 这个操作并不重要，反正对 arr[i] == to 的情况，子问题应该有以下赋值
                // from = other, other = from, to = to
                // 对 arr[i] != to 的情况，子问题应该有以下赋值
                // from = from, other = to, to = other
                // 其实可以看到，两种分支中，需要交换位置的其实始终只有两个元素，并且 other 是始终要被交换的那一个，所以最终写成了以下的形式
                temp = from;
                from = other;
            }
            else
            {
                temp = to;
                to = other;
            }
            other = temp;
            i--;
        }
        return result;
    }
}
void main()
{
	vector<int> arr = { 3, 3, 2, 1};
	cout << HanoiProblem::solve1(arr) << ", " << HanoiProblem::solve2(arr) << endl;
	system("pause");
}
```

## 2.25 求旋变串

**[题目]** 比如给定一个字符串 abcd，其可以分解为：

1. abcd -> a + [ bcd -> b + [ cd -> c + d ] ]
2. abcd -> a + [ bcd -> [ bc -> b + c  ] + d ]
3. abcd -> [ ab -> a + b ] + [ cb -> c + d ]
4. abcd -> [ abc -> [ ab -> a + b ] + c ] + d
5. abcd -> [ abc -> a + [ bc -> b + c ] ] + d

所谓旋变串，就是比如对上面的几个案例，里面有若干个 '+'，然后将 + 左右的字符或字符串的结合顺序进行颠倒，然后向上合并最终合并成一个新串，这个新串就是原串的旋变串。现在的目标是判断给定的两个字符串是不是旋变串。

**解题思路：**研究长度为 k，str1[L1 ~ L1 + k - 1] 和 str2[L2 ~ L2 + k - 1] 范围上的子串是不是旋变串。理解问题求解的关键在于，如果我们将 A 字符串划分为两个子部分 subA1 和 subA2（比如 3 2），那么能否以相同划分（3 2）或相反划分（2 3）的情况下，使得 B 字符串被划分为的两个子串 subB1 和 subB2 有：
		subA1 和 subB1 互为旋变串以及 subA2 和 subB2 互为旋变串（划分相反的情况下反过来），如果满足这个条件，那么通过 A 和 B 一定就是旋变串，这个还是非常直观的。

```c++
// === 判断两字符串是否互为旋变字符串 === //
namespace ScrambleString
{
    bool isSameTypeSameNumber(const string& str1, const string& str2)
    {
        if (str1.size() != str2.size())
            return false;
        // mp 用于表示各个字符出现的次数
        vector<int> mp(256, 0);
        // 用欠费的思路来确定两个字符串含有的字符是不是完全相同
        for (int i = 0; i < str1.size(); i++)
            mp[str1[i]]++;
        for (int i = 0; i < str2.size(); i++)
            if (--mp[str2[i]] < 0)
                return false;
        return true;
    }
    // 方法 1. 暴力递归
    bool solve1(const string& str1, const string& str2)
    {
        // 如果两个字符串长度不等或者含有的字符不同，则返回 false
        if (!isSameTypeSameNumber(str1, str2))
            return false;
        // 如果两个字符串均为空或直接是相等的，则直接返回 true
        if (str1.empty() && str2.empty() || str1 == str2)
            return true;
        int N = str1.size();
        return process(str1, str2, 0, 0, N);
    }
    // L1 表示 str1 的起始位置，L2 表示 str2 的起始位置，size 表示两子串的长度
    bool process(const string& str1, const string& str2, int L1, int L2, int size)
    {
        // Base case，两子串的长度为 1，则只需要比较对应位置的字符是否相同
        if (size == 1)
            return str1[L1] == str2[L2];
        // leftPart 表示以 str1 为标准，将 str1 分解为 str1[L1 ~ (L1 + leftPart - 1)] 和 str1[(L1 + leftPart) ~ (L1 + size  - 1)]
        // 值得注意的是，str1 只用分解依次，然后让 str2 去配合 str1 做两次分解，如果两个字符串同时翻转了，这是没有意义的（在遍历的过程中重复）
        // 并将 str2 分解为 str2[L2 ~ (L2 + leftPart - 1)] 和 str2[(L1 + leftPart) ~ (L1 + size  - 1)]，正向分解即目标 subA_1 = subB_1
        // 或者将 str2 分解为 str2[L2 ~ (L2 + size - leftPart - 1)] 和 str2[(L2 + size - leftPart) ~ (L2 + size - 1)]，逆向分解即目标 subA_1 = subB_2
        for (int leftPart = 1; leftPart < size; leftPart++)
        {
            if (
                // 满足正向分解即 subA_1 = subB_1 && subA_2 = subB_2
                (process(str1, str2, L1, L2, leftPart) && process(str1, str2, L1 + leftPart, L2 + leftPart, size - leftPart)) ||
                // 或满足逆向分解即 subA_1 = subB_2 && subA_2 = subB_1
                (process(str1, str2, L1, L2 + size - leftPart, leftPart) && process(str1, str2, L1 + leftPart, L2, size - leftPart))
                )
            {
                return true;
            }
        }
        // 如果上面所有的分解都无法通过，说明当前两子串确实不互为旋变字符串
        return false;
    }
    // 方法 2. 动态规划
    bool solve2(const string& str1, const string& str2)
    {
        // 该问题是一个三可变参数的问题，即其需要一张三维表
        if (!isSameTypeSameNumber(str1, str2))
            return false;
        if (str1.empty() && str2.empty() || str1 == str2)
            return true;
        int N = str1.size();
        // 分析可知，dp[i][j][size] 表示的是两字符串分别以 i 和 j 位置开头，以 size 为长度的子串是否是旋变字符串
        // 而由于 size 不为 0，所以一共申请 N + 1 的高度，size == 0 的那一层不用
        vector<vector<vector<int>>> dp(N, vector<vector<int>>(N, vector<int>(N + 1, false)));
        // 1. Base case，在 size == 1 的情况下，根据对应位置字符是否相同，可以将这一层的表全部填上
        for (int i = 0; i < N; i++)
            for (int j = 0; j < N; j++)
                dp[i][j][1] = str1[i] == str2[j];
        // 2. 递推关系，观察原递归函数，容易看出，由于 leftPart >= 1，所以 dp[i][j][size] 依赖的一定是低层的元素，所以递推关系很好写（下向上）
        // 不过过程中需要注意不能越界，翻译成原题意表示子字符串不能够越界（size 对 i 和 j 的位置有限制）
        for (int size = 2; size <= N; size++)
            // 可以举个例子，如果 size 为 2，N 为 2，那么此时循环条件是 L1 <= 0，则一般情况为 L1 <= N - size
            for (int L1 = 0; L1 <= N - size; L1++)
                for (int L2 = 0; L2 <= N - size; L2++)
                {
                    for (int leftPart = 1; leftPart < size; leftPart++)
                        if (
                            // 满足正向分解即 subA_1 = subB_1 && subA_2 = subB_2
                            (dp[L1][L2][leftPart] && dp[L1 + leftPart][L2 + leftPart][size - leftPart]) ||
                            // 或满足逆向分解即 subA_1 = subB_2 && subA_2 = subB_1
                            (dp[L1][L2 + size - leftPart][leftPart] && dp[L1 + leftPart][L2][size - leftPart])
                            )
                        {
                            // 如果 true 则直接break 掉
                            dp[L1][L2][size] = true;
                            break;
                        }
                    // 这里不用设置任何东西，因为如果此处没有将 dp[L1][L2][size] 设置为 true，其默认为 false
                }
        return dp[0][0][N];
    }
}
void main()
{
	// 1.
	string test1 = "abcd";
	string test2 = "cdab";
	cout << ScrambleString::solve1(test1, test2) << ", " << ScrambleString::solve2(test1,test2) << endl;
	// 2.
	test1 = "abcd";
	test2 = "cadb";
	cout << ScrambleString::solve1(test1, test2) << ", " << ScrambleString::solve2(test1, test2) << endl;
	// 3.
	test1 = "bcdebcdebcdebcdebcdebcdebcdebcdebcdebcdebcdeb";
	test2 = "ebcdeebcdebebcdebcdebcdecdebcbcdcdebcddebcbde";
	cout << ScrambleString::solve1(test1, test2) << ", " << ScrambleString::solve2(test1, test2) << endl;
	system("pause");
}
```

## 2.26 包含子串字符问题

**[题目]** 给定字符串 str1 和 str2，求 str1 的子串中含有 str2 **所有字符（顺序无所谓）**的最小子串长度。

**[举例]**

str1 = "abcde"，str2 = "ac"
因为 "abc" 包含 str2 所有的字符，并且在满足这一条件的 str1 的所有子串中，"abc" 是最短的，返回3。

str1 = "12345", str2 = "344"
最小包含子串不存在，返回 0。

**解题思路：**滑动窗口计算以 str1 的每一个字符为开头的情况下，能够包含 str2 中所有字符的最小子串长度。给一张 “欠款表”，表示离包含目标串 str2 的所有字符，各个字符还差多少个，并用一个数字来记录一共还差的字符个数。

```c++
// === 判断一个字符串是否完整包含另一个字符串的所有字符
namespace StringContainsChars
{
    int solve(const string& str1, const string& str2)
    {
        if (str1.empty())
            return false;
        if (str2.empty())
            return true;
        // 一个欠费数组
        vector<int> arrears(256, 0);
        // 表示欠的总账
        int total = 0;
        // 统计 str2 的字符出现次数
        for (int i = 0; i < str2.size(); i++)
        {
            arrears[str2[i]]++;
            total++;
        }
        int result = INT_MAX;
        // str1 的长度
        int N = str1.size();
        // 左右指针用于指示的范围代表以 left 起始的 str1 的子串能够包含 str2 的最短长度
        // 初值状态 [0, -1] 表示没有任何元素
        // 左指针
        int left = 0;
        // 右指针
        int right = -1;
        // 比如 str1 长度为 2，str2 长度为 2，此时 left 只能到 0，所以用 <= N - str2.size()
        while (left <= N - str2.size())
            // 如果欠账大于 0，说明当前 [left, right] 没有包含 str2，右指针右移
            if (total > 0)
            {
                // 如果右指针已经踩到边界了此时却还不能包括 str2，那么就算后续移动左指针也不可能找到包括 str2 的子串，则 break 掉
                if (right == N - 1)
                    break;
                right++;
                // 只有当对应位置的字符词频大于 0，才对总欠费进行 --，否则就算对应位置的字符词频将为负数也不对总欠费 --
                // 不过对应位置字符的词频总是要 --
                if (arrears[str1[right]]-- > 0)
                    total--;
            }
            else
            {
                // 每次进入这个判断，都代表找到了以 left 开头的 str1 字符包含 str2 字符的最短情况
                result = min(result, right - left + 1);
                // 值得注意的是这里的关系运算符是 >= 0，因为在 == 0 的情况下，说明一个字符刚好不欠，但一旦左移，该字符就欠一个，所以要囊括该情况 
                if (arrears[str1[left]]++ >= 0)
                    total++;
                // 这里一定要注意，滑动窗口中，通常而言，左边界移动放在操作之后，右边界移动放在操作前
                // 如果欠账小于等于 0，说明当前 [left, right] 已经完整包含 str2，左指针右移
                left++;
            }
        // 如果 result 未经过修改，其是 INT_MAX，说明 str1 不包含 str2，否则正常返回其结果
        return result == INT_MAX ? 0 : result;
    }
}
void main()
{
	string str1 = "12a3b4cdefg5fg";
	string str2 = "abcdefg";
	cout << StringContainsChars::solve(str1, str2) << endl;
	system("pause");
}
```

## 2.27 LFU 缓存替换算法

**[题目]** 一个缓存结构需要实现如下功能

**void set(int key, int value)：**加入或修改 key 对应的 value
**int get(int key)：**查询 key 对应的 value 值

但是缓存中最多放 K 条记录，如果新的第 K + 1 条记录要加入，就需要根据策略删掉一条记录，然后才能把新记录加入。

这个策略为：在缓存结构的 K 条记录中，哪一个 key 从进入缓存结构的时刻开始，被调用 set 或者 get 的次数最少，就删掉这个 key 的记录；如果调用次数最少的key有多个，上次调用发生最早的 key 被删除。这就是 LFU 缓存替换算法。实现这个结构，K 作为参数给出。要求词频的更新时间复杂度为 $O(1)$。

**解题思路：**二维双向链表。

```c++
// === LFU 缓存结构 === //
namespace LFU
{
    // 1. 把新的节点加入桶
    void NodeList::addNodeFromHead(Node* newHead)
    {
        // 新加入的节点被放在桶的最顶层
        newHead->down = head;
        head->up = newHead;
        head = newHead;
    }
    // 2. 判断该桶是不是为空
    bool NodeList::isEmpty() const
    {
        return head == NULL;
    }
    // 3. 删除 node 节点并保证 node 的上下重新连接
    void NodeList::deleteNode(Node* node)
    {
        // 其实应该先判断一下 node 是不是在这个桶内
        // 如果只剩一个节点，则将桶的 head 和 tail 都指向空并释放空间
        if (head == tail)
        {
            head = NULL;
            tail = NULL;
        }
        else
        {
            if (node == head)
            {
                // 如果想删除的是头结点，将其下一个节点作为头结点，下一个节点的上指针指向空
                head = node->down;
                head->up = NULL;
            }
            else if (node == tail)
            {
                // 如果想删除的是尾节点，将其上一个节点作为尾结点，上一个节点的下指针指向空
                tail = node->up;
                tail->down = NULL;
            }
            else
            {
                // 如果想删除的是中间节点，上下两个节点的下上指针互联即可
                node->up->down = node->down;
                node->down->up = node->up;
            }
        }
        // 这个节点应该还是要用的，不要直接释放空间
        node->up = NULL;
        node->down = NULL;
    }
    // 用于处理刚刚删除过节点的桶
    // 1. 如果桶空了，判断其是不是左边第一个桶
    // 1.1 如果其是左边第一个桶，将其删除之后，将其右边的桶作为整体缓存结构的左边第一个桶
    // 1.2 如果其不是左边第一个桶，将其左右两桶重新连接即可
    // 2. 如果桶没空，什么事情都不做
    bool LFUCache::modifyHeadList(NodeList* removeNodeList)
    {
        if (removeNodeList->isEmpty())
        {
            // 1.1 如果要移除的是第一个桶
            if (headList == removeNodeList)
            {
                // 将第一个桶指针指向当前桶的下一个桶
                headList = removeNodeList->next;
                // 在移除节点之后，有可能整个缓存结构中是没有任何数据的（似乎按题意不太可能）
                // 为了逻辑封闭，如果出现整个缓存结构都没有数据，加上下面这个判断
                if (headList != NULL)
                    headList->last = NULL;
            }
            // 1.2 如果要移除的不是第一个桶
            else
            {
                removeNodeList->last->next = removeNodeList->next;
                // 由于当前桶可能是最后一个桶（虽然其必然不是第一个桶），所以要先有这一步判断
                if (removeNodeList->next != NULL)
                    removeNodeList->next->last = removeNodeList->last;
            }
            // 这里的桶也不能直接释放空间，外部函数还会调用它的成员
            return true;
        }
        // 说明当前桶没有被删除，即当前桶在删除节点之后依然还有节点
        return false;
    }
    // node 节点对应数据刚刚被操作过，即操作次数 ++，将其放置在新桶中，并保证整体结构不出现问题
    void LFUCache::move(Node* node, NodeList* oldNodeList)
    {
        // 先从原桶中删除节点（所以函数里面不能释放 node 的空间）
        oldNodeList->deleteNode(node);
        // C++ 中需要手动释放空间，所以我们需要记录该桶在最后是否需要被释放
        bool isOldNodeListEmpty = modifyHeadList(oldNodeList);
        // 值得注意的是，modifyHeadList 函数中已经完成了 old 桶前后桶的相连
        // 如果 modifyHeadList(oldNodeList) 返回真，说明删除节点之后该桶空了，preList 是 old 桶前面的桶
        // 否则说明原来的桶就没被删除，此时 preList 设置为其本身
        // preList 的作用是：此时节点 node 需要被放到一个新的桶内，这个桶必然是挂在某个桶后面的
        // 这里需要找出新的桶的前一个桶是谁，值得注意的是，如果原来的 oldNodeList 是第一个桶，oldNodeList->last 会访问到 NULL
        NodeList* preList = isOldNodeListEmpty ? oldNodeList->last : oldNodeList;
        NodeList* nextList = oldNodeList->next;
        // 表示对应的节点是从最后一个桶出来的，说明该节点对应的 key 的操作数已经达到了一个新高
        // 此时必然需要创建一个新桶，挂在 preList 的后面（所以要判断 oldNodeList 是否被删除，来判断这个新桶需要被挂在哪个桶后面）
        if (nextList == NULL)
        {
            // 创建新桶
            NodeList* newList = new NodeList(node);
            if (preList != NULL)
                preList->next = newList;
            newList->last = preList;
            // 会发生这个判断的原因在于，我们在对 oldNodeList 进行 modify 操作的时候
            // 有可能会因为 oldNodeList 是唯一的一个桶，并且其中的唯一的节点还要移出该桶而导致这个桶需要被删除
            // 这个时候 headList 会暂时被置为 NULL
            if (headList == NULL)
                headList = newList;
            // 设置值的时候用这种方式倒是安全的，主要是访问值的时候用这个方式可能出现意想不到的错误
            heads[node] = newList;
        }
        else
        {
            // 如果原本就有对应访问频次的桶，则将拿出来的节点直接放进去
            if (nextList->head->times == node->times)
            {
                nextList->addNodeFromHead(node);
                heads[node] = nextList;
            }
            // 否则需要再创建一个新的桶，并将其接在 preList 的后面以及 nextList 的前面
            // 因为我们已经确定 old 桶必然不是最后一个桶，所以可以直接访问 nextList
            else
            {
                NodeList* newList = new NodeList(node);
                // 桶之间相互连接的逻辑
                if (preList != NULL)
                    preList->next = newList;
                newList->last = preList;
                newList->next = nextList;
                nextList->last = newList;
                // 如果原本的 head 指向 next，那么由于当前的 new 在 next 前面，所以此时的 head 应该指向 new
                if (headList == nextList)
                    headList = newList;
                // 不管哪个分支，都需要给哈希表做这个操作
                heads[node] = newList;
            }
        }
        // 如果该桶空了，则释放内存空间
        if (isOldNodeListEmpty)
            delete oldNodeList;
    }
    // set 对应 key 的 value
    void LFUCache::set(const int& key, const int& value)
    {
        // 如果缓存中已经存入了对应的数据，此时说明 key 对应的数据的操作频次还可以（当然也可能是因为缓存数据没满）
        // 可以直接操作节点
        if (records.find(key) != records.end())
        {
            // 拿到对应节点进行操作
            Node* node = records[key];
            node->value = value;
            node->times++;
            // 拿到对应节点以及其所在的桶进行操作
            NodeList* curNodeList = heads[node];
            move(node, curNodeList);
        }
        else
        {
            // 如果缓存中没有存入对应数据，那么说明之前该数据要么从来没出现过
            // 要么就是该数据之前的被访问次数太少，不够格进入缓存，而此时其访问次数增加了，需要判断其能否进入缓存
            if (size == capacity)
            {
                // 值得注意的是，头部桶的最后一个节点表示的是缓存中
                // 1. 访问频次最少
                // 2. 被操作时间最久远的节点
                // 另外，这个缓存是遵循“当前操作最优先”，也就是说，虽然之前某个记录被访问多次，但由于其被操作时间太久远
                // 依然会被当前新操作的，仅操作了一次的记录给挤掉，理解这一点很重要
                Node* node = headList->tail;
                headList->deleteNode(node);
                modifyHeadList(headList);
                // 两张 map 中也需要删除对应记录
                records.erase(node->key);
                heads.erase(node);
                // 只有这种情况下才需要真正地释放节点空间，桶空间的释放在其它函数中管理了
                delete node;
                size--;
            }
            // 创建当前操作项的记录
            Node* node = new Node(key, value, 1);
            // 说明缓存中没有任何数据
            if (headList == NULL)
                headList = new NodeList(node);
            // 说明原本缓存中有部分数据，不过需要查看，当前的 Cache 中是否有对应于操作次数为 1 的桶
            else
            {
                if (headList->head->times == node->times)
                    headList->addNodeFromHead(node);
                else
                {
                    NodeList* newList = new NodeList(node);
                    newList->next = headList;
                    headList->last = newList;
                    headList = newList;
                }
            }
            records[key] = node;
            heads[node] = headList;
            size++;
        }
    }
    // get 对应 key 的 value
    int LFUCache::get(const int& key)
    {
        if (records.find(key) == records.end())
            throw string("The given key doesn't exist!");
        Node* node = records.at(key);
        node->times++;
        NodeList* curNodeList = heads.at(node);
        // 拿到对应的节点和 key 之后直接操作即可
        move(node, curNodeList);
        return node->value;
    }
    // 显示当前缓存中的所有数据
    void LFUCache::showRecords() const
    {
        for (auto it = records.begin(); it != records.end(); it++)
        {
            cout << "The key: " << it->first\
                << ", the value: " << it->second->value\
                << ", the operation times: " << it->second->times << endl;
        }
    }
}
void main()
{
	LFU::LFUCache cache(5);
	for (int i = 0; i < 5; i++)
	{
		cache.set(i, i + 10);
		for (int j = 0; j < (pow((i - 4), 2) - 1); j++)
			cache.get(i);
	}
	// 此时的记录为
	// The key : 0, the value : 10, the operation times : 16
	// The key : 1, the value : 11, the operation times : 9
	// The key : 2, the value : 12, the operation times : 4
	// The key : 3, the value : 13, the operation times : 1
	// The key : 4, the value : 14, the operation times : 1
	cache.showRecords();
	// 那么如果我们插入一条新数据比如 (10, 100)，此时应该挤掉的是 key 为 3 的数据，因为 key 为 3 的数据是先插入的
	cache.set(10, 100);
	cache.set(10, 13);
	cout << "---------------------------" << endl;
	cache.showRecords();
	system("pause");
}
```

## 2.28 卡车加油问题

**[题目]** N 个加油站组成一个环形，给定两个长度都是 N 的非负数组 oiI 和 dis (N>1），oiI[i] 代表第 i 个加油站存的油可以跑多少干米，dis[i] 代表第 i 个加油站**到环中下一个加油站**相隔多少千米。假设你有一辆油箱足够大的车，初始时车里没有油。如果车从第 i 个加油站出发，最终可以回到这个加油站，那么第i个加油站就算良好出发点，否则就不算。请返回长度为 N 的 boolean 型数组 res，res[i] 代表第 i 个加油站是不是良好出发点。要求额外空间复杂度 $O(1)$。

**解题思路：**oil - dis，得到一个纯能值数组，表示从这个位置开走，到达下一个节点的时候，还剩多少油。

**真正的关键：**

1. **只需要找出一个 Good 点，就能直接判定所有点是不是 Good**，假如我们已经拿到了一个 RootGood 点，那么沿反方向遍历所有点，如果一个点可以走到 RootGood 点，那么其必然是一个 Good 点，但如果其无法走到 RootGood 点，其必然就不是一个 Good 点。这个结论好明显的，因为一个点只有两种情况，也就是它能走到 RootGood 和它不能走到 RootGood，则必然可以通过这个条件来判断一个点是不是 Good 点；
2. 连通区的意义在于，它可以通过**不回退地累积一段区域**，使得我们可以只需要判断一个节点能否接入该区域的头部来确定**从该点出发**是否能通过这个连通区，自然，如果一个节点连接入连通区的资格都没有，其自然不可能是 Good 点，而每当有一个节点能够接入连通区，我们还会不断将连通区的尾部扩张，来最终确定其是否是一个 Good 点；
3. 在找到一个 RootGood 节点之前，可以判断，连通区内的所有节点都不是 Good 节点，因为既然能形成连通区，那一定是从当前的 start 点开始，带着余油走过连通区中的每一个点，那带着余油都走不过，其中的节点怎么可能走完一圈，所以在找到一个 RootGood 点之后，只需要检查连通区以外的节点即可（包括 end 指针指向的点，这个点可不算在连通区中）。

```c++
// === 卡车加油问题 === //
namespace GasStations
{
    vector<bool> solve1(const vector<int>& dis, const vector<int>& oil)
    {
        if (dis.empty() || oil.empty() || dis.size() != oil.size() || dis.size() < 2)
            return vector<bool>();
        auto supDis = dis;
        auto supOil = oil;
        int N = dis.size();
        vector<bool> result(N, false);
        // 遍历一遍所有节点
        for (int i = 0; i < N; i++)
            supOil[i] -= supDis[i];
        for (int i = 0; i < N; i++)
        {
            int curOil = 0;
            for (int j = 0; j < N; j++)
            {
                curOil += supOil[(i + j) % N];
                // 中间过程有任何一个时候，剩下的油小于 0 了，表示该路径走不通
                if (curOil < 0)
                    break;
            }
            result[i] = curOil < 0 ? false : true;
        }
        return result;
    }
    vector<bool> solve2(const vector<int>& dis, const vector<int>& oil)
    {
        if (dis.empty() || oil.empty() || dis.size() != oil.size() || dis.size() < 2)
            return vector<bool>();
        // 如果 init 真的为 -1，则不用做后续工作了，直接返回全 false 即可
        auto supDis = dis;
        auto supOil = oil;
        int init = changeDisArrayGetInit(supDis, supOil);
        return init == -1 ? vector<bool>(supDis.size(), false) : enlargeArea(supDis, init);
    }
    // 找出一个起始点（起始点是其至少能够从自身出发往外走一步的节点）
    int changeDisArrayGetInit(vector<int>& dis, vector<int>& oil)
    {
        int init = -1;
        for (int i = 0; i < dis.size(); i++)
        {
            // 作为引用变量传入
            dis[i] = oil[i] - dis[i];
            // 如果整个过程计算出的元素都比 0 小，说明从任意一个节点出发甚至都不能走到下一个节点
            if (dis[i] >= 0)
                init = i;
        }
        return init;
    }
    vector<bool> enlargeArea(vector<int>& dis, int init)
    {
        // 值得注意的是，此时的 dis 是纯能值数组
        vector<bool> result(dis.size(), false);
        int start = init;
        int end = nextIndex(init, dis.size());
        int need = 0;
        int rest = 0;
        // 下面这个循环主要在做的其实就是找到一个初始的 RootGood 点
        // 由于连通区中点是不是 Good 点是可以确定的，所以一旦连通区完全充满整个环或者
        // start 走到 init，这种情况说明 end 完全没往后扩，然后 start 一直往前扩直至 init 使得连通区完全充满整个环
        do
        {
            // 此时说明连通区已经完全沾满整个环却依然没有跳出循环，则说明整个环上都没有 Good 点
            if (start != init && start == lastIndex(end, dis.size()))
                break;
            // 这一步是在看，当前的 start 能否被接入到当前的连通区中
            if (dis[start] < need)
                // 这里相当于当前节点确实无法接入连通区
                // 并且说明对应的 start 不是 Good 点，理由就是它甚至都无法走到连通区的头部 init
                // 其自然无法走完一圈
                need -= dis[start];
            else
            {
                // 说明当前节点可以接入连通区，并给以给连通区的尾部带来一定的剩余油量
                rest += dis[start] - need;
                need = 0;
                // 然后不断扩充连通区的尾部
                while (rest >= 0 && end != start)
                {
                    rest += dis[end];
                    end = nextIndex(end, dis.size());
                }
                // 如果扩到最后发现是通过 end != start 跳出循环的，说明当前 start 是一个 Good 点
                if (rest >= 0)
                {
                    result[start] = true;
                    // 然后从当前的连通区起点的前一个点开始，检查并拿到所有 Good 点（这个函数会检查所有点）
                    connectGood(dis, lastIndex(start, dis.size()), init, result);
                    break;
                }
            }
            // start 继续向 next 反方向扩张
            start = lastIndex(start, dis.size());
        // 如果 start == init，说明连通区沾满整个环，退出
        } while (start != init);
        return result;
    }
    // 如果 start 的 next 方向上有一个良好出发点
    // start 如果可以连接到这个良好出发点，那么从 start 出发自然可以转一圈（其本身也是良好出发点）
    // 其最终的效果是将 (init <= last <= start] 中的所有节点
    void connectGood(vector<int>& dis, int start, int init, vector<bool>& result)
    {
        // need 初始为 0，并且后续过程也清零的原因在于，如果一个节点的纯能值为负数，其必然不能够接到 init 上
        // 那么如果 need 给了负数，就使得纯能值为负数的节点也可能接到良好出发点上，这明显是不合理的
        int need = 0;
        while (start != init)
        {
            if (dis[start] < need)
                // 这里说明当前遍历到的 start 是不能够接入到 Good 点的，则此时它必然不是 Good 节点
                // 因为它连 init 都走不到，又怎么能够遍历一整圈呢
                // 同时，其还会为后续想要接入 Good 点的节点增加负担（纯能值为负）或减少负担（纯能值为正）
                // 且由于保证了 dis[start] < need，所以 need 不会变为负数，也就满足了我们在函数开头的解释
                need -= dis[start];
            else
            {
                result[start] = true;
                need = 0;
            }
            start = lastIndex(start, dis.size());
        }
    }
    // 因为整个过程是循环的，所以需要这两个函数
    int lastIndex(int index, int size)
    {
        // 返回对应节点 index 的上一个节点 index
        return index == 0 ? (size - 1) : (index - 1);
    }
    int nextIndex(int index, int size)
    {
        return index == (size - 1) ? 0 : (index + 1);
    }
}
void main()
{
	int size = 50;
	for (int i = 0; i < 1000; i++)
	{
		vector<int> dis = RandVector(20, 1000, size, 1);
		vector<int> oil = RandVector(20, 1000, size, 1);
		bool result = IsTheSameVector(GasStations::solve1(dis, oil), GasStations::solve2(dis, oil));
		if (!result)
			cout << "Fuck All!" << endl;
	}
	system("pause");
}
```

## 2.29 搜索二叉树纠错问题

**[题目]** 一棵二叉树原本是搜索二叉树，但是其中有两个节点调换了位置，使得这棵二叉树不再是搜索二叉树，请找到这两个错误节点并返回已知二又树中所有节点的值都不一样，给定二又树的头节点 head，返回一个长度为 2 的二叉树节点类型的数组 errs，errs[0] 表示一个错误节点，errs[1] 表示另一个错误节点。

**解题思路：**中序遍历得到的搜索二叉树是完全升序或降序的，而两个节点换位置之后，会使得中序遍历的结果出现两次降序，第一次降序的前一个节点和第二次降序的后一个节点就是一对位置错误的节点。

```c++

```

**进阶1：**

如何判断是否只有两个节点位置错误。很简单：

1. 如果超过两次降序，则必然不止两个节点的位置错误；
2. 找出两个中序遍历降序的位置，交换之后如果中序遍历升序则确实只有两个节点的位置错误，否则不止两个。

**进阶2：**
		如果在原问题中得到了这两个错误节点，我们当然可以通过交换两个节点的节点值的方式让整棵二又树重新成为搜索二又树。但现在要求你不能这么做，而是在结构上完全交换两个节点的位置，请实现调整的函数。

**解题思路：**主要是要把两个节点的所有可能性考虑清楚：

1. 两个节点如果是根节点；
2. 两个节点如果相邻；
3. 两个节点如果有父节点，它们是父节点的左孩子还是右孩子；
4. 两个节点在中序遍历中的顺序注定了有些情况是不会出现的；

```c++
[// === 修复二叉树问题 === //
namespace RecoverBST
{
    // 找到两个错误节点
    // 这里最好申请为常量指针，即不能改变值，但是可以改变指向
    vector<Node*> getTwoErrorNodes(Node* head)
    {
        vector<Node*> result(2, NULL);
        if (head == NULL)
            return result;
        stack<Node*> stack;
        Node* pre = NULL;
        while (!stack.empty() || head != NULL)
        {
            // 运用栈的中序遍历
            if (head != NULL)
            {
                stack.push(head);
                head = head->left;
            }
            else
            {
                head = stack.top();
                stack.pop();
                // 如果中序遍历过程发现 pre 的值比当前值大，说明并非中序遍历严格升序
                // 第一次碰到的时候应该设置前一个节点为错误节点，即 pre
                // 第二次碰到的时候应该设置后一个节点为错误节点，即 head（或者称之为 cur）
                if (pre != NULL && pre->value > head->value)
                {
                    result[0] = result[0] == NULL ? pre : result[0];
                    result[1] = head;
                }
                pre = head;
                head = head->right;
            }
        }
        return result;
    }
    // 找到两个错误节点的父亲节点
    vector<Node*> getTwoErrorParents(Node* head, Node* error1, Node* error2)
    {
        vector<Node*> parents(2,NULL);
        if (head == NULL) {
            return parents;
        }
        stack<Node*> stack;
        while (!stack.empty() || head != NULL) {
            // 运用栈的中序遍历，只是说如果在遍历过程中发现了如果某个错误节点是树节点的左右孩子，此时就设置其为对应返回值
            if (head != NULL) {
                stack.push(head);
                head = head->left;
            }
            else {
                head = stack.top(); stack.pop();
                if (head->left == error1 || head->right == error1) {
                    parents[0] = head;
                }
                if (head->left == error2 || head->right == error2) {
                    parents[1] = head;
                }
                head = head->right;
            }
        }
        return parents;
    }
    Node* recoverTree(Node* head)
    {
        // 拿到两个错误节点
        vector<Node*> errs = getTwoErrorNodes(head);
        // 拿到两个错误节点的父亲节点
        vector<Node*> parents = getTwoErrorParents(head, errs[0], errs[1]);
        // 因为 e1 是中序遍历先被遍历到的节点，所以只可能 e2 是 e1 的右孩子或者 e1 是 e2 的左孩子
        Node* const e1 = errs[0];
        Node* const e1P = parents[0];
        Node* const e1L = e1->left;
        Node* const e1R = e1->right;
        Node* const e2 = errs[1];
        Node* const e2P = parents[1];
        Node* const e2L = e2->left;
        Node* const e2R = e2->right;
        // 通过三种基本情况来确定一共 14 种组合情况
        // 1. 节点是否相邻
        // 2. 节点是否是头结点
        // 3. 节点是其父亲的左节点还是右节点
        // ========================================================== //
        // 下面分类讨论，一共 14 种情况，自己想
        // 1. e1 是头结点
        // 此时主要是两节点的父亲节点的操作不太一样
        if (e1 == head)
        {
            // 1.1 e2 是 e1 的右孩子
            if (e2 == e1R)
            {
                // ① 设置 e2 左右孩子
                e2->left = e1L;
                e2->right = e1;
                // ② 设置 e1 左右孩子
                e1->left = e2L;
                e1->right = e2R;
                // ③ 设置 e2 的父亲
                // ④ 设置 e1 的父亲
            }
            // 1.2 e2 不是 e1 的右孩子
            else
            {
                // 1.2.1 e2 是其父亲的左孩子
                if (e2 == e2P->left)
                {
                    // ① 设置 e2 左右孩子
                    e2->left = e1L;
                    e2->right = e1R;
                    // ② 设置 e1 左右孩子
                    e1->left = e2L;
                    e1->right = e2R;
                    // ③ 设置 e2 的父亲
                    e2P->left = e1;
                    // ④ 设置 e1 的父亲					
                }
                // 1.2.2 e2 是其父亲的右孩子
                else
                {
                    // ① 设置 e2 左右孩子
                    e2->left = e1L;
                    e2->right = e1R;
                    // ② 设置 e1 左右孩子
                    e1->left = e2L;
                    e1->right = e2R;
                    // ③ 设置 e2 的父亲
                    e2P->right = e1;
                    // ④ 设置 e1 的父亲	
                }
            }
            // 应该换成 e2，所以返回 e2
            return e2;
        }
        // 2. e2 是头结点
        else if (e2 == head)
        {
            // 2.1 e1 是 e2 的左孩子
            if (e1 == e2L)
            {
                e2->left = e1L;
                e2->right = e1R;
                e1->left = e2;
                e1->right = e2R;
            }
            // 2.2 e1 不是 e2 的左孩子
            else
            {
                // 2.2.1 e1 是其父亲的左孩子
                if (e1 == e1P->left)
                {
                    e2->left = e1L;
                    e2->right = e1R;
                    e1->left = e2L;
                    e1->right = e2R;
                    e1P->left = e2;
                }
                // 2.2.2 e1 是其父亲的右孩子
                else
                {
                    e2->left = e1L;
                    e2->right = e1R;
                    e1->left = e2L;
                    e1->right = e2R;
                    e1P->right = e2;
                }
            }
            // 应该换成 e1，所以返回 e1
            return e1;
        }
        // 3. e1 和 e2 都不是头节点
        else
        {
            // 3.1 e1 是 e2 的左孩子
            if (e1 == e2L)
            {
                // 3.1.1 e2 是其父亲的左孩子
                if (e2 == e2P->left)
                {
                    e1->left = e2;
                    e1->right = e2R;
                    e2->left = e1L;
                    e2->right = e1R;
                    e2P->left = e1;
                }
                // 3.1.2 e2 是其父亲的右孩子
                else
                {
                    e1->left = e2;
                    e1->right = e2R;
                    e2->left = e1L;
                    e2->right = e1R;
                    e2P->right = e1;
                }
            }
            // 3.2 e2 是 e1 的右孩子
            else if (e2 == e1R)
            {
                if(e1 == e1P->left)
                // 3.2.1 e1 是其父亲的左孩子
                {
                    e2->left = e1L;
                    e2->right = e1;
                    e1->left = e2L;
                    e1->right = e2R;
                    e1P->left = e2;
                }
                // 3.2.2 e1 是其父亲的右孩子
                else
                {
                    e2->left = e1L;
                    e2->right = e1;
                    e1->left = e2L;
                    e1->right = e2R;
                    e1P->right = e2;
                }
            }
            // 3.3 e1 和 e2 不相邻
            else
            {
                // 这一步明显是一样的，区别在于对两节点的父节点设置
                e2->left = e1L;
                e2->right = e1R;
                e1->left = e2L;
                e1->right = e2R;
                // 3.3.1 e1 右孩 e2 左孩
                if (e1 == e1P->right && e2 == e2P->left)
                {
                    e1P->right = e2;
                    e2P->left = e1;
                }
                // 3.3.2 e1 左孩 e2 左孩
                else if (e1 == e1P->left && e2 == e2P->left)
                {
                    e1P->left = e2;
                    e2P->left = e1;
                }
                // 3.3.3 e1 右孩 e2 右孩
                else if (e1 == e1P->right && e2 == e2P->right)
                {
                    e1P->right = e2;
                    e2P->right = e1;
                }
                // 3.3.4 e1 左孩 e2 右孩
                else
                {
                    e1P->left = e2;
                    e2P->right = e1;
                }
            }
            return head;
        }
    }
    // 打印整棵树
    void printTree(Node* head) {
        cout << "Binary Tree:" << endl;;
        printInOrder(head, 0, "H", 17);
        cout<<endl;
    }
    // 中序遍历打印
    void printInOrder(Node* head, int height, string to, int len) {
        if (head == NULL) {
            return;
        }
        printInOrder(head->right, height + 1, "v", len);
        string val = to + to_string(head->value) + to;
        int lenM = val.length();
        int lenL = (len - lenM) / 2;
        int lenR = len - lenM - lenL;
        val = getSpace(lenL) + val + getSpace(lenR);
        cout << getSpace(height * len) << val << endl;
        printInOrder(head->left, height + 1, "^", len);
    }
    // 获得空格
    string getSpace(int num) {
        string space = " ";
        string buf  = "";
        for (int i = 0; i < num; i++) {
            buf.append(space);
        }
        return buf;
    }
    // 判断一棵树是不是搜索二叉树
    bool isBST(Node* head) {
        if (head == NULL) {
            return false;
        }
        stack<Node*> stack;
        Node* pre = NULL;
        while (!stack.empty() || head != NULL) {
            if (head != NULL) {
                stack.push(head);
                head = head->left;
            }
            else {
                head = stack.top();
                stack.pop();
                if (pre != NULL && pre->value > head->value) {
                    return false;
                }
                pre = head;
                head = head->right;
            }
        }
        return true;
    }
}
    void main()
{
	// === 正常的搜索二叉树 === //
	RecoverBST::Node* head = new RecoverBST::Node(5);
	head->left = new RecoverBST::Node(3);
	head->right = new RecoverBST::Node(7);
	head->left->left = new RecoverBST::Node(2);
	head->left->right = new RecoverBST::Node(4);
	head->right->left = new RecoverBST::Node(6);
	head->right->right = new RecoverBST::Node(8);
	head->left->left->left = new RecoverBST::Node(1);
	printTree(head);
	cout << isBST(head) << endl;
	// 1. 情况 1 —— e1 是头结点，e2 是其右孩子
	cout << "// = 情况 1 —— e1 是头结点，e2 是其右孩子 = //" << endl;
	RecoverBST::Node* head1 = new RecoverBST::Node(7);
	head1->left = new RecoverBST::Node(3);
	head1->right = new RecoverBST::Node(5);
	head1->left->left = new RecoverBST::Node(2);
	head1->left->right = new RecoverBST::Node(4);
	head1->right->left = new RecoverBST::Node(6);
	head1->right->right = new RecoverBST::Node(8);
	head1->left->left->left = new RecoverBST::Node(1);
	printTree(head1);
	cout<<isBST(head1)<<endl;
	RecoverBST::Node* res1 = recoverTree(head1);
	printTree(res1);
	cout << isBST(res1) << endl;
	// 2. 情况 2 —— e1 是头结点，e2 与 e1 不相邻，且 e2 是左孩子
	cout << "// = 情况 2 —— e1 是头结点，e2 与 e1 不相邻 = //" << endl;
	RecoverBST::Node* head2 = new RecoverBST::Node(6);
	head2->left = new RecoverBST::Node(3);
	head2->right = new RecoverBST::Node(7);
	head2->left->left = new RecoverBST::Node(2);
	head2->left->right = new RecoverBST::Node(4);
	head2->right->left = new RecoverBST::Node(5);
	head2->right->right = new RecoverBST::Node(8);
	head2->left->left->left = new RecoverBST::Node(1);
	printTree(head2);
	cout << isBST(head2) << endl;
	RecoverBST::Node* res2 = recoverTree(head2);
	printTree(res2);
	cout << isBST(res2) << endl;
	// 3. 情况 3 —— e1 是头结点，e2 与 e1 不相邻，且 e2 是右孩子
	cout << "// = 情况 3 —— e1 是头结点，e2 与 e1 不相邻，且 e2 是右孩子 = //" << endl;
	RecoverBST::Node* head3 = new RecoverBST::Node(8);
	head3->left = new RecoverBST::Node(3);
	head3->right = new RecoverBST::Node(7);
	head3->left->left = new RecoverBST::Node(2);
	head3->left->right = new RecoverBST::Node(4);
	head3->right->left = new RecoverBST::Node(6);
	head3->right->right = new RecoverBST::Node(5);
	head3->left->left->left = new RecoverBST::Node(1);
	printTree(head3);
	cout << isBST(head3) << endl;
	RecoverBST::Node* res3 = recoverTree(head3);
	printTree(res3);
	cout << isBST(res3) << endl;
	// 4. 情况 4 —— 均非头结点，e2 是 e1 的右孩子，且 e1 是左孩子
	cout << "// = 情况 4 —— 均非头结点，e2 是 e1 的右孩子，且 e1 是左孩子 = //" << endl;
	RecoverBST::Node* head4 = new RecoverBST::Node(5);
	head4->left = new RecoverBST::Node(4);
	head4->right = new RecoverBST::Node(7);
	head4->left->left = new RecoverBST::Node(2);
	head4->left->right = new RecoverBST::Node(3);
	head4->right->left = new RecoverBST::Node(6);
	head4->right->right = new RecoverBST::Node(8);
	head4->left->left->left = new RecoverBST::Node(1);
	printTree(head4);
	cout << isBST(head4) << endl;
	RecoverBST::Node* res4 = recoverTree(head4);
	printTree(res4);
	cout << isBST(res4) << endl;
	// 5. 情况 5 —— 均非头结点，e1 是 e2 的左孩子，且 e2 是右孩子
	cout << "// = 情况 5 —— 均非头结点，e1 是 e2 的左孩子，且 e2 是右孩子 = //" << endl;
	RecoverBST::Node* head5 = new RecoverBST::Node(5);
	head5->left = new RecoverBST::Node(3);
	head5->right = new RecoverBST::Node(6);
	head5->left->left = new RecoverBST::Node(2);
	head5->left->right = new RecoverBST::Node(4);
	head5->right->left = new RecoverBST::Node(7);
	head5->right->right = new RecoverBST::Node(8);
	head5->left->left->left = new RecoverBST::Node(1);
	printTree(head5);
	cout << isBST(head5) << endl;
	RecoverBST::Node* res5 = recoverTree(head5);
	printTree(res5);
	cout << isBST(res5) << endl;
	// 后续测试略
	std::system("pause");
}
```

## 2.30 矩形重叠问题

**[题目]** 平面内有 n 个矩形，第 i 个矩形的左下角坐标为 (x1[i], y1[i])，右上角坐标为 (x2[i], y2[i])。如果两个或者多个矩形有公共区域则认为它们是相互重叠的（不考虑边界和角落）。请你计算出平面内重叠矩形数量最多的地方，有多少个矩形相互重叠。

**算法原型：**

​		用两个数值 [x1, x2] 表示一条轴上的线段，现在有若干线段，要求线段重合最多的区域有多少跳线段。

**原型解题思路：**按照各个**线段起始点**升序升序进行遍历，并给一张有序表，记录所有线段的**终止点横坐标**，每次遍历一个线段的时候，删除有序表中值比当前线段起始点小于或等于的那些，查看当前有序表中还剩多少个数，这就是当前线段范围内重叠的最大线段数，这样做的原理其实很简单，由于我们是按照起始点升序进行遍历，则如果有序表中有值，说明一定是在遍历到当前线段之前遍历了这些值对应的线段，那么这些线段的起始点一定在当前线段之前（也可能重合），那么如果有序表中在按照规则删除无效数值之后依然存在数值，则这些终止点对应线段一定从当前线段的起始点开始一直延伸到对应线段的终止点。

**解题思路：**将所有矩形按 down 坐标升序进行遍历，并用一张有序表，存储已遍历过的矩形的 up 坐标，每次遍历到一个矩形，先从有序表中删除 up 坐标比当前 down 坐标小的对应矩形，此时拿到的是在高度方向可能和当前矩形有重叠的所有矩形**（其实并非所有，比如 down 比当前矩形的 down 高，但是又没有超出当前矩的 up，但这个矩形的重合情况在后续也会被检测到）**，然后问题化简为一个算法原型。

**暴力法：**查找矩形的整体范围，然后遍历范围内的所有点，找出被包围的最多的点即可。

```c++
// === 矩形重叠问题 === //
namespace CoverMax
{
    bool Rectangle::operator==(const Rectangle& other) const
    {
        return (up == other.up) && (down == other.down) && (left == other.left) && (right == other.right);
    }
    // 三个比较器，分别根据矩形的下坐标、左坐标和右坐标排序
    bool DownComparator::operator()(const Rectangle& r1, const Rectangle& r2) const
    {
        return r1.down < r2.down;
    }
    bool LeftComparator::operator()(const Rectangle& r1, const Rectangle& r2) const
    {
        return r1.left < r2.left;
    }
    bool RightComparator::operator()(const Rectangle& r1, const Rectangle& r2) const
    {
        return r1.right < r2.right;
    }
    int maxCover1(vector<Rectangle>& recs)
    {
        if (recs.empty())
            return 0;
        int N = recs.size();
        // 通过四边形的底对矩形进行排序
        sort(recs.begin(), recs.end(), DownComparator());
        // 用 leftOrdered 的好处是，把基于底边同高而选出来的可能具有重叠关系的矩形直接按照 left 升序排序
        multiset<Rectangle, LeftComparator> leftOrdered;
        int result = 0;
        for (int i = 0; i < N; i++)
        {
            int curDown = recs[i].down;
            int index = i;
            // 相当于是以每个矩形的下边为单位来求重叠区域（如果有若干矩形的下边是同高的，这部分矩形应在一次求解范围内）
            while (index < N && recs[index].down == curDown) {
                leftOrdered.insert(recs[index]);
                index++;
            }
            // 这里必须要减掉 1，不然中间会跳过一些结果，主要是最后有一步给 i++ 了
            // 比如我们找到了两个等 down 的矩形，那么此时 index += 2 之后赋值给 i，那么下一次 i++ 后循环从 i == 3 开始，因而跳过了 i == 2 的情况
            i = index - 1;
            // 从纵向上排除不可能重叠的矩形
            removeLowerOnCurDown(leftOrdered, curDown);
            multiset<Rectangle, RightComparator> rightOrdered;
            for (const Rectangle& rec : leftOrdered) {
                removeLeftOnCurLeft(rightOrdered, rec.left);
                // 这里先删还是先插没有区别，因为删也不会把自己删掉
                rightOrdered.insert(rec);
                result = max(result, (int)rightOrdered.size());
            }
        }
        return result;
    }
    // 删除有序集合中，up 比给定 down 小的所有矩形
    void removeLowerOnCurDown(multiset<Rectangle, LeftComparator>& leftOrdered, int curDown)
    {
        list<Rectangle> removes;
        for (const Rectangle& rec : leftOrdered)
            // 这个里面的 leftOrdered 是按照矩形的 left 进行排序的，所以要挨个排查其对应的 up 是不是比 curDown 小
            if (rec.up <= curDown)
                removes.push_back(rec);
        for (Rectangle& rec : removes)
            leftOrdered.erase(rec);
    }
    // 线段的原型问题，删除有序集合中，right 比给定 left 小的所有矩形
    void removeLeftOnCurLeft(multiset<Rectangle, RightComparator>& rightOrdered, int curLeft)
    {
        list<Rectangle> removes ;
        for (const Rectangle& rec : rightOrdered) {
            if (rec.right > curLeft) 
                break;
            removes.push_back(rec);
        }
        for (Rectangle& rec : removes) 
            rightOrdered.erase(rec);
    }
    // 标准的
    int maxCover2(vector<Rectangle>& recs)
    {
        int leftMin = INT_MAX;
        int rightMax = INT_MIN;
        int upMax = INT_MIN;
        int downMin = INT_MAX;
        // 先统计所有范围
        for (int i = 0; i < recs.size(); i++)
        {
            leftMin = min(leftMin, recs[i].left);
            rightMax = max(rightMax, recs[i].right);
            upMax = max(upMax, recs[i].up);
            downMin = min(downMin, recs[i].down);
        }
        // 然后遍历整个范围
        int result = 0;
        for (int y = downMin; y <= upMax; y++)
            for (int x = leftMin; x <= rightMax; x++)
                result = max(result, coveringRectangles(x, y, recs));
        return result;
    }
    bool pointInRectangle(const int& x, const int& y, const Rectangle& rec)
    {
        // 不取等号
        return (rec.left < x) && (rec.right > x) && (rec.down < y) && (rec.up > y);
    }
    // 给定一个点，查看有多少个矩形包围它
    int coveringRectangles(const int& x, const int& y, vector<Rectangle>& recs)
    {
        int result = 0;
        for (int i = 0; i < recs.size(); i++)
            if (pointInRectangle(x, y, recs[i]))
                result++;
        return result;
    }
}
void main()
{
	// 值得注意的是，我们的函数默认 左 < 右，下 < 上，则如果给定的数据不是这样，有必要进行调整
	// 构造函数的顺序是 上、下、左、右
	// 值得注意的是，如果用的是 set，此时根据排序的依据不同，只要矩形在某个方向具有相同的坐标，其对应的数据在 set 中会被移除
	// 所以最终选择使用 multiset 来避免这个问题
	vector<Solutions::CoverMax::Rectangle> recs{
		Solutions::CoverMax::Rectangle(10, -10, -20, 30),
		Solutions::CoverMax::Rectangle(15, 0, -10, 25),
		Solutions::CoverMax::Rectangle(13, 8, 18, 35),
		Solutions::CoverMax::Rectangle(20, 4, 23, 50),
		Solutions::CoverMax::Rectangle(20, 4, 23, 50),
		Solutions::CoverMax::Rectangle(19, 3, 25, 55),
		Solutions::CoverMax::Rectangle(33, 1, 13, 70)
	};
	std::cout << CoverMax::maxCover1(recs) << ", " << CoverMax::maxCover2(recs) << endl;
	std::system("pause");
}
```

