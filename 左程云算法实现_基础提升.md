# 哈希函数及哈希表实现

## 1. 哈希函数

### 1.1  特征

（1）**输入域**无穷，**输出域S**有限。

​		**MD5算法**，其输出域为 $$ 0 \sim 2^{64} - 1 $$

​		**SHA-1算法**，其输出域为 $$0 \sim 2^{128}-1$$

（2）相同的输入，一定有相同的输出；

（3）不同的输入，有可能产生相同的输出；

（4）哈希函数的均匀性和离散性，本质上，输入和输出的映射关系虽然是固定的，但是给定一个输入，其对应的固定输出是离散且随机的，也就是说，即使给定的输入之间虽然很相近，但得到的输出依然可能相差很远；

（5）如果哈希函数在原本的S域上均匀分布，其mod上一个数之后，得到的范围为 $$ 0\sim m-1 $$，此时在这个返回上，哈希函数的输入输出依然是均匀的。



### 1.2 问题

#### 1.2.1 小内存问题

**问题描述：**现在有一个文件，文件的每一行都是一个数据，文件一共有40亿行，可使用的内存是1G，请你求出文件中出现次数最多的数字。比较有意思的是这个数据量的计算过程，Hash表的一条数据<int, int>需要的空间为8B，那么在最差的情况下，40亿行数据在最差的情况下（所有数据均不相同），如果采用哈希表，此时会产生40亿条哈希表数据，那么对应所需的内存空间为
$$
4 \times 10^9 \times 8 =32 \times 10^9 \approx 32 \rm G
$$
**解题思路：**

1. **Hash映射：**将40亿的数据先用哈希函数计算，然后模100，结果会被映射到100个小文件内（**其实就是先对原始文件进行扫描，用哈希函数处理这些数据，当然也可以考虑直接mod，但是因为哈希函数具有均匀性和离散型，但mod是不具有的，所以先用哈希函数进行处理，保证序列散列，即任意划分若干块被哈希函数处理过的数据域，可以认为各个域所包含的数据数目相同，这样我们才能保证第二步中，可以稳定地将需要的内存进行缩小，而哈希函数处理之后，这些数字会被处理到若干个比如100个桶中，其实就是在扫描过程中，把哈希函数计算结果相同的数给放到同一个小文件中**）；相当于，利用均匀分布的特点，将原始结果平均分100份；
2. **Hash统计：**挨个用哈希表来分别统计每个小文件中出现最多的数，其中，每个桶中内存是32G/100；
3. **合计：**最后统计所有小文件中的最大词频数中的最大词频数。

<font color =red>**注：那么实际上，上面的这个过程利用的是哈希函数处理数据的散列性（或者说均匀性和离散性）。**</font>

**这个代码没写，有兴趣可以搞搞看，其实是很简单的，比如用一个循环不停地创建数据，然后我们用哈希函数处理这个数据，并将mod 100之后的结果相同的数据存放到相同的文件里，然后针对每一个文件用哈希表进行数频统计，然后排出各个文件中的出现次数最多的数即可。**<font color = red>**另外，视问题而定，考虑使用有序表还是哈希表，比如如果只是找出最大值，其实没有必要要求序列有序，统计词频后遍历一遍哈希表就行，也就n复杂度。**</font>

**代码：**

``` c plus
// 找到哈希表中的value最大值
pair<int, int> MostFrequent(const unordered_map<int, int>& hash)
{
// 出现最多的数字
int mostFrequentNumber = INT_MIN;
// 该数字出现多少次
int maxValue = INT_MIN;
for (auto it = hash.begin(); it != hash.end(); it++)
{
    if (it->second > maxValue)
    {
        mostFrequentNumber = it->first;
        maxValue = it->second;
    }
}
return make_pair(mostFrequentNumber, maxValue);
}

// 问题1. 基于哈希函数的均匀性分解大数据问题
pair<int,int> MostFrequent_HashFunction(const vector<int>& arr)
{
    // 定义默认的哈希函数
    auto hashFunction = hash<int>();
    // 实际用的时候不这么做，而是先遍历原数组，把所有数据分解到小的文件中，最后再分别处理、排序
    vector<unordered_map<int, int>> hashMaps(100);
    for_each(arr.begin(), arr.end(), [&](const int& value) {
        // 模100之后返回在0~99之间，则直接将其作为数组的index
        int hashIndex = hashFunction(value) % 100;
        // 通过哈希函数先离散，然后再模100，此时能够保证原随机数据能够被大致等分为100份
        if (hashMaps[hashIndex].find(value) == hashMaps[hashIndex].end())
        {
            hashMaps[hashIndex].insert(make_pair(value, 1));
        }
        else
            hashMaps[hashIndex][value]++;
    });
    unordered_map<int, int> resultMap;
    for (int i = 0; i < hashMaps.size(); i++)
    {
        // 把每个哈希表的最大词频数据集成到最后的一个哈希表中，该哈希表仅100维
        resultMap.insert(MostFrequent(hashMaps[i]));
    }
    return MostFrequent(resultMap);
}

void main()
{
    // 通过哈希函数计算出来的结果始终是唯一的
    vector<int> arr = RandVector(0, pow(2, 11), 2e5);
    // 全局方式直接统计
    unordered_map<int, int> globalHash;
    for (int i = 0; i < arr.size(); i++)
    {
        if (globalHash.find(arr[i]) == globalHash.end())
            globalHash.insert(make_pair(arr[i], 1));
        else
            globalHash[arr[i]]++;
    }
    auto result1 = MostFrequent(globalHash);
    cout << "The most frequent number is: " << result1.first << ", the corresponding frequency is: " << result1.second << endl;

    auto result2 = MostFrequent_HashFunction(arr);
    cout << "The most frequent number is: " << result2.first << ", the corresponding frequency is: " << result2.second << endl;

    system("pause");
}
```

## 2. 哈希表的实现

### 2.1 特征

​		多种方法，去看王卓的视频笔记。

**补充：**一种可实现的方法是，先按照某个哈希函数将数据进行均匀离散，然后取模，将所有数据按一定的比例收缩到某一个区域上，然后将所有经过哈希函数+取模运算之后相同的结果链到同一个内存空间中，当然，取模的值越小，越容易发生碰撞，所以我们可以设置一个factor，当统计到某一个链过长，此时就可以考虑对原来的数据进行rehash，即将模值取大，以剪短链接的数据，加快存取速度。

**存取代价：**在每个内存空间链表不长的情况下，可以认为存取速度都是 $O(1)$； 

**扩容代价：**还是很容易想的，如果每次扩容都是将原数据空间拓展为原来的两倍，那么即使设定的扩容链长阈值不同，其扩容的次数一定是 $logN$，而每一次扩容需要处理的元素的规模为 $O(N)$，那么每一操作平均的扩容代价为
$$
O(N*logN/N)=O(logN)
$$
**综合代价：**所以综合存取代价和扩容代价，可以认为平均的存取代价为$O(logN)$。如果只是考虑存取的代价，其速度还是认为是常数时间。

### 2.2 问题

#### 2.2.1 设计RandomPool结构

**[题目]**
		设计一种结构，在该结构中有如下三个功能：
		**insert(key)：**将某个key加入到该结构，做到不重复加入；
		**delete(key)：**将原本在结构中的某个key移除；
		**getRandom()：**等概率随机返回结构中的任何一个key。
**[要求]**
		Insert、delete和getRandom方法的时间复杂度都是$O(1)$

**问题思路：**

​		因为要求是key值，比如string，所以不能用数组，准备两张哈希表，一张key为string，value为index，index初始按照字符串的插入顺序给，一张key为index，value为string，这张额外的表是方便我们生成随机数之后，可以通过index直接寻址，然后返回结果。后续操作直接看代码，很简单。

**代码：**

``` c plus
// 问题2，随机池问题
class RandomPool
{
public:
    // 在存储的数据中随机返回一个字符串
    T getRandom()
    {
        if (size == 0) throw string("The size is 0!");
        int index = RandInt(0, size - 1, true);
        // 返回随机字符串
        return indexKeyMap[index];
    }
    // 插入一个字符串
    void insert(const T& key)
    {
        // 先size，然后++
        keyIndexMap.insert(make_pair(key, size));
        indexKeyMap.insert(make_pair(size++, key));
    }
    // 删除一个字符串
    void remove(const T& key)
    {
        // 如果池中没有该元素，则直接返回
        if (keyIndexMap.find(key) == keyIndexMap.end()) return;
        // 用最后一个索引的值来填要删除位置的元素
        // 找出要删除位置的index
        int destIndex = keyIndexMap[key];
        // 找出当前最后一个位置的key，并将size--
        T lastString = indexKeyMap[--size];
        // 这么做的原因在于我们要保留对应表中作为key位置上的元素
        // 对<index, string>表，我们要删除最后一个元素对应记录，并修改目标index位置上的string（保留该表中，目标元素的index）
        indexKeyMap.erase(indexKeyMap.find(size));
        indexKeyMap[destIndex] = lastString;
        // 对<string, index>表，我们要删除目标元素对应记录，并修改目标key位置上的index（保留该表中，最后元素的string）
        keyIndexMap.erase(keyIndexMap.find(key));
        keyIndexMap[lastString] = destIndex;
    }
private:
    // 主要map
    unordered_map<T, int> keyIndexMap;
    unordered_map<int, T> indexKeyMap;
    int size = 0;
};

void main()
{
    RandomPool<string> rp;
    rp.insert("James");
    rp.insert("Kevin");
    rp.insert("Lebron");
    rp.insert("Curry");
    rp.insert("Kobe");
    rp.insert("Stephen");
    int JamesCount = 0;
    int KevinCount = 0;
    int LebronCount = 0;
    int CurryCount = 0;
    int KobeCount = 0;
    int StephenCount = 0;
    for (int i = 0; i < 100000; i++)
    {
        // 一定要先创建一个元素，然后再判断该元素对应于哪个字符串
        string str = rp.getRandom();
        if (str == "James")
            JamesCount++;
        else if (str == "Kevin")
            KevinCount++;
        else if (str == "Lebron")
            LebronCount++;
        else if (str == "Curry")
            CurryCount++;
        else if (str == "Kobe")
            KobeCount++;
        else
            StephenCount++;
    }
    cout << "The James count equals: " << JamesCount << endl;
    cout << "The Kevin count equals: " << KevinCount << endl;
    cout << "The Lebron count equals: " << LebronCount << endl;
    cout << "The Curry count equals: " << CurryCount << endl;
    cout << "The Kobe count equals: " << KobeCount << endl;
    cout << "The Stephen count equals: " << StephenCount << endl;
    // 删除元素
    JamesCount = 0;
    KevinCount = 0;
    LebronCount = 0;
    CurryCount = 0;
    KobeCount = 0;
    StephenCount = 0;
    rp.remove("Stephen");
    rp.remove("Kevin");
    rp.remove("Curry");
    for (int i = 0; i < 100000; i++)
    {
        // 一定要先创建一个元素，然后再判断该元素对应于哪个字符串
        string str = rp.getRandom();
        if (str == "James")
            JamesCount++;
        else if (str == "Kevin")
            KevinCount++;
        else if (str == "Lebron")
            LebronCount++;
        else if (str == "Curry")
            CurryCount++;
        else if (str == "Kobe")
            KobeCount++;
        else
            StephenCount++;
    }
    cout << "// ================ After removing elements ================ //" << endl;
    cout << "The James count equals: " << JamesCount << endl;
    cout << "The Kevin count equals: " << KevinCount << endl;
    cout << "The Lebron count equals: " << LebronCount << endl;
    cout << "The Curry count equals: " << CurryCount << endl;
    cout << "The Kobe count equals: " << KobeCount << endl;
    cout << "The Stephen count equals: " << StephenCount << endl;

    system("pause");
}
```

#### 2.2.2 布隆过滤器

**问题概述：**黑名单过滤器，主要就是查一个元素是否属于某一个集合（比如网页的违法链接，比如爬虫查询是否爬过某一个网址），但是这个原集合的数据量非常大，比如100亿条数据，如果直接用hash表，肯定是不行的，所需的内存空间过于大。 

**基础问题：**位图（bit map）。比如整型的int arr，其一个元素对应的大小是4个字节（32bits），长整型的long arr，其一个元素对应的大小是8个字节（64bits），而位图一个元素对应的大小仅1 bit。

​		那么其实可以用整型数据来制造位图，比如拥有10个int数据的arr，实际上可以看作拥有320个bit的arr。

**（1）取得<font color = red>第i位</font>状态（该位是1还是0）的方法是：**

​		(i / 32) % 32 -> 比如找 31位的信息，很明显，i / 32 = 0，它在arr[0]中，然后 i % 32 = 31，它在arr[0]元素的第31位，写成代码为

``` c plus
int numIndex = i / 32;
int bitIndex = i % 32;
int state = ( (arr[numberIndex] >> bitIndex) & 1 );	// 因为1仅在第一位上为1，所以通过移动将目标位置移动到第一位，再和1求交
```

**注：那么明显的，位图的起始index也是0。**

或者直接写成

``` c plus
int state = (arr[i / 32] >> (i % 32)) & 1;
```

**（2）修改<font color = red>第i位</font>状态为1的方法是：**

​		很简单，给一个仅在bitIndex位置上为1的数，然后和原数求**或**，写成代码为

``` c plus
arr[numberIndex] = arr[numberIndex] | (1 << bitIndex);
```

**注：那么明显的，位图的起始index也是0。**

**（3）修改<font color = red>第i位</font>状态为0的方法是：**

​		同理，给一个仅在bitIndex位置上为0的数，然后和原数求**交**，写成代码为

``` c plus
arr[numberIndex] = arr[numberIndex] & (~ (1 << bitIndex));
```

**解题思路：**在允许有一定失误的情况下**（但布隆过滤器只可能错杀，但不会放过本身处于黑名单中的元素，这一点倒是非常优秀的特征）**，其原理是：类似于采指纹的过程，设布隆过滤器的大小为 m，即有 m 位可以用于指示某个输入是否已经被加入黑名单，对于每一个样本输入，我们采用 k 个哈希函数对它进行处理，并在处理之后模 m，那么此时必然会有 k 个（可能更少，因为可能有计算重复）布隆过滤器中的位被涂黑。那么明显的，该方法必然不会放过，因为只要一个元素加入过，它对应的布隆过滤器中的 k 个位置上是一定被记录过的，但确实可能错杀。

**三个重要公式：**

​		m越大，失误率必然越小，但是此时耗费的内存也会变大，所以要根据需要的失误率计算对应的过滤器大小。而在固定的样本个数 n 和过滤器大小 m 的情况下，失误率按哈希函数的个数存在极小值。

**（1）根据失误率定过滤器的理论大小 m**
$$
m_{Theoretical} = -\frac{n\times lnp}{(ln2)^2}
$$
**（2）根据过滤器大小 m 计算理论哈希函数个数 k（向上取整）**
$$
k_{theoretical}=ln2 \times \frac{m}{n} \approx 0.7 \times \frac mn \uparrow
$$
**（3）根据实际的 m 和 k 计算实际的失误率**
$$
P_{real} = (1- e^{- \frac{n \times k_{real}}{m_{real}}})
$$
**代码实现：**

``` c plus

```

#### 2.2.3 一致性哈希原理

**问题解释1：**讨论数据服务器如何组织。逻辑端存取数据是认为数据是在一片连续的存储空间的，但实际上，数据是分别存放在若干个数据库（分布式数据库）中，所以要考虑如何分配数据的问题。

**问题解释2：**基于给定的数据，选择一个数据项作为key，然后将key过哈希函数再模 n，n为分布式数据库的个数，那么此时所有数据都可以被离散地分配到n个数据库中。另外，还需要注意负载的问题，主要跟key有关系，比如高频的key如果分配到了对应服务器，那么该服务器的负载肯定就比较大，而由于哈希函数本身的均匀性，可以认为key在高频、中频和低频都具有一定数量的情况下**（人名、地名等）**，最终的分配是负载均衡的，所以如果key在高频数量不足，此时的分配很可能不均匀**（国家名，种类比较少）**，比如**（极端的案例）**以性别为key，而又有3个数据库，此时必然有一个数据库存不到东西。

**数据迁移问题：**采用问题解释2中模的方式分配数据，其问题在于，如果数据量过大，而要发展一个新的分布式数据库，此时原本存储的所有数据都需要重新计算，此时数据迁移的代价是全量的。

**原始解决思路：**基于某个哈希函数，把服务器地址（或者名称）映射到值域中，入下图所示

<img src="https://img-blog.csdnimg.cn/20210613103026866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzc4MDM0,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom: 50%;" />

​		然后对于插入的数据，对其做哈希函数之后并不进行模操作，而是查找沿顺时针方向上的离它最近的结点，这个操作也简单，只需将计算出的结点按哈希计算值的大小放在一个有序表arr中（升序），然后对插入数据的哈希值，找出arr中大于等于该值的最小结点即可。

**改进解题思路：**虽然哈希函数具有均匀特性，但是在数据量较小的情况下，也难免不能使得数据均匀，如下图

<img src="https://img-blog.csdnimg.cn/20210613103225330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzc4MDM0,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom:50%;" />

所以考虑给每个结点设置若干个虚拟结点，比如可以通过给原结点的 key 添加一些后缀，再经过哈希函数计算得到虚拟结点在哈希环中的位置，而把数据插入哈希环的过程依然和原始方法一样，如下图所示

<img src="https://img-blog.csdnimg.cn/20210613103235718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzc4MDM0,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom:50%;" />

**代码实现：**

``` c plus

```

# 有序表

**查找的时间复杂度：** $O(logN)$

**一些特征和注意点：**

下述的 1、2、3 其实都是搜索二叉树系列的。

（1）通常来说，搜索二叉树的 key 值是不重复的，可以通过其它方式来处理 key 值相同的情况。

## 0. 搜索二叉树（BST，Binary Search Tree）

### 0.1 **基本操作简述：**

**（1）删除结点**

![image-20230419223728026](C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230419223728026.png)

​		主要分为三种情况，直接看函数，对应第三种情况中的，后续结点并不是目标删除结点的右孩子的情况会相对麻烦一点，可以看上面的图。关键在于理解 ，此时需要把右分支上最小结点的右子树全部接到对应最小结点父亲的左分支上，然后在用当前最小结点去替换目标删除结点的位置。

**代码：**

``` c plus
std::vector<TNode*> InorderTraversal(TNode*& const root)
{
    std::vector<TNode*> res;
    std::stack<TNode*> stk;
    while (root != nullptr || !stk.empty()) {
        while (root != nullptr) {
            stk.push(root);
            root = root->left;
        }
        root = stk.top();
        stk.pop();
        res.push_back(root);
        root = root->right;
    }
    return res;
}

TNode* createNode(const int& value, TNode* const parent, TNode* const left, TNode* const right)
{
    return new TNode(value, parent, left, right);
}

// ====================== 结点函数 ====================== //
bool TNode::isLeaf()
{
    return (left == NULL) && (right == NULL);
}

// ====================== 搜索二叉树函数 ====================== //
    // 搜索对应 value 的结点，如果没有对应结点，则返回 NULL
TNode* mAbstractBinarySearchTree::search(const int& value) const
{
    TNode* node= root;
    while (node != NULL && node->value != value)
    {
        // 因为是搜索二叉树，所以必然左边结点的 value 比右边结点的 value 小
        if (value < node->value)
            node = node->left;
        else
            node = node->right;
    }
    return node;
}
// 通过 value 向树中插入一个结点，并返回该结点的地址
TNode* mAbstractBinarySearchTree::insert(const int& value)
{
    if (root == NULL)
    {
        // 树原本为空的情况
        root = createNode(value, NULL, NULL, NULL);
        size++;
        return root;
    }
    TNode* insertParentNode = NULL;
    TNode* searchTempNode = root;
    // 这个循环，我们可以找到我们的目标结点是以哪个结点作为其父节点
    while (searchTempNode != NULL)
    {
        insertParentNode = searchTempNode;
        if (value < searchTempNode->value)
            searchTempNode = searchTempNode->left;
        else
            searchTempNode = searchTempNode->right;
    }
    // 以找到的父节点为准，创建一个新的结点
    TNode* newNode = createNode(value, insertParentNode, NULL, NULL);
    // 然后通过值的判断来确定其是作为其父节点的左孩子还是右孩子
    if (insertParentNode->value > newNode->value)
        insertParentNode->left = newNode;
    else
        insertParentNode->right = newNode;
    size++;
    return newNode;
}
// 通过 value 删除树中的一个结点，并返回该结点的地址
TNode* mAbstractBinarySearchTree::erase(const int& value)
{
    TNode* eraseNode = search(value);
    if (eraseNode != NULL)
        return erase(eraseNode);
    else
        // 返回 NULL 说明没有对应值，删除失败
        return NULL;
}
// 通过结点的地址来删除结点，需要注意，因为我们这是一个搜索二叉树，所以删除结点之后要保证树的结构不被破坏
TNode* mAbstractBinarySearchTree::erase(TNode*& const eraseNode)
{
    if (eraseNode != NULL)
    {
        TNode* nodeToReturn = NULL;
        if (eraseNode->left == NULL)
            // 若目标删除结点没有左孩子，则直接把它的所有右孩子挂到当前目标结点的父节点上即可
            // 当然，如果目标节点左右孩子均无，也走这一步操作
            nodeToReturn = transplant(eraseNode, eraseNode->right);
        else if (eraseNode->right == NULL)
            // 若目标删除结点没有右孩子，则直接把它的所有左孩子挂到当前目标结点的父节点上即可
            nodeToReturn = transplant(eraseNode, eraseNode->left);
        else
        {
            // 若目标删除结点左右孩子均存在
            // 1. 拿出按中序遍历下的目标删除结点的下一个结点，由于当前结点必然有左右孩子，所以直接找到其右树上的最小值对应结点
            // 理论上来说，只需要把这个小结点换到原结点位置，此时搜索二叉树的结构就是依然成立的
            TNode* successorNode = getMinimum(eraseNode->right);
            if (successorNode->parent != eraseNode)
            {
                transplant(successorNode, successorNode->right);
                successorNode->right = eraseNode->right;
                successorNode->right->parent = successorNode;
            }
            transplant(eraseNode, successorNode);
            successorNode->left = eraseNode->left;
            successorNode->left->parent = successorNode;
            nodeToReturn = successorNode;
        }
        size--;
        // 释放空间
        delete eraseNode;
        return nodeToReturn;
    }
    return NULL;
}
// 将树中的某个结点换成其它的结点，关键在于保持原树的结构关系（仅仅是父子关系，而不考虑数值大小信息）
// 这个函数只是
// 1. 把原结点 nodeToReplace 的父亲的孩子指向 newNode
// 2. 把新结点 newNode 的父亲指针指向原结点 nodeToReplace 的父亲
// 也就是说没有动 newNode 和 nodeToReplace 的孩子
TNode* mAbstractBinarySearchTree::transplant(TNode*& const nodeToReplace, TNode*& const newNode)
{
    if (nodeToReplace->parent == NULL)
        // 如果对应需要交换的结点是根结点，则直接将新结点与之交换
        this->root = newNode;
    else if (nodeToReplace == nodeToReplace->parent->left)
        // 否则将其放到对应的父节点的左树或者右树上
        nodeToReplace->parent->left = newNode;
    else
        nodeToReplace->parent->right = newNode;

    if (newNode != NULL)
        newNode->parent = nodeToReplace->parent;

    return newNode;
}
// 查看树是否包含某个 value
bool mAbstractBinarySearchTree::contains(const int& value) const
{
    return search(value) != NULL;
}
// 查找树中的最小值
int mAbstractBinarySearchTree::getMinimum() const
{
    TNode* node = root;
    return getMinimum(node)->value;
}
TNode* mAbstractBinarySearchTree::getMinimum(TNode*& const node) const
{
    TNode* tmpNode = node;
    // 由搜索二叉树的性质知道，直接按左树找下去就行
    while (tmpNode->left != NULL)
        tmpNode = tmpNode->left;
    return tmpNode;
}

// 查找树中的最大值
int mAbstractBinarySearchTree::getMaximum() const
{
    TNode* node = root;
    return getMaximum(node)->value;
}
TNode* mAbstractBinarySearchTree::getMaximum(TNode*& const node) const
{
    TNode* tmpNode = node;
    // 由搜索二叉树的性质知道，直接按右树找下去就行
    while (tmpNode->right != NULL)
        tmpNode = tmpNode->right;
    return tmpNode;
}

// 找出树中，第一个比当前给出 value 要大的值（前提是当前的 value 是树中已经存储了的数据）
int mAbstractBinarySearchTree::getSuccessor(const int& value) const
{
    TNode* node = search(value);
    if (node == NULL)
        throw string("The given value is not find in the tree! --- getSuccessor");
    return getSuccessor(node)->value;
}
TNode* mAbstractBinarySearchTree::getSuccessor(TNode*& const node) const
{
    // 它实际上的效果是，给定一个树中已经存在的结点，然后返回按照中序遍历顺序的下一个结点
    if (node->right != NULL)
        // 从中序遍历的角度来思考，如果当前结点含有右分支，则其中序遍历的下一个结点必然是右分支上最左边的结点
        return getMinimum(node->right);
    else
    {
        // 包括当前结点，找到第一个是其父节点的左孩子的结点，那么下一个中序遍历的结点就是其父节点
        // 值得一提的是，如果当前结点是中序遍历的最后一个结点，那么此时会返回空
        TNode* currentNode = node;
        TNode* parentNode = node->parent;
        while (parentNode != NULL && currentNode == parentNode->right)
        {
            currentNode = parentNode;
            parentNode = parentNode->parent;
        }
        return parentNode;
    }
}
// 查询树的大小
int mAbstractBinarySearchTree::getSize() const
{
    return size;
}
// 打印树
void mAbstractBinarySearchTree::printTree() const
{
    if (!root) return;
    auto tmp = root;
    std::vector<TNode*> intv = InorderTraversal(tmp);//中序遍历节点数组
    std::string template_str;//模板string，表示每行打印string的长度
    int location = 0;
    std::unordered_map<TNode*, int> first_locations;//存储节点对应在本行string中的首位置
    for (auto& i : intv) {
        location = template_str.size();
        template_str += std::to_string(i->value) + " ";
        first_locations[i] = location;
    }
    for (auto& i : template_str)i = ' ';//把模板全部置为空格方便后续使用
    //层序遍历
    std::queue<TNode*> q;
    q.push(root);
    while (!q.empty()) {
        int currentLevelSize = q.size();
        int cur_loc = 0;
        std::string tmp_str1 = template_str, tmp_str2 = template_str;//1为节点所在行，2为其下一行
        for (int i = 1; i <= currentLevelSize; ++i) {
            auto node = q.front();
            q.pop();
            cur_loc = first_locations[node];
            std::string num_str = std::to_string(node->value);
            //左边，如果存在左孩子，那么在第二行对应位置打印'/'，在第一行补上'_'
            if (node->left) {
                q.push(node->left);
                int first_loc = first_locations[node->left] + 1;
                tmp_str2[first_loc++] = '/';
                while (first_loc < cur_loc)tmp_str1[first_loc++] = '_';

            }
            //中间,对应位置打印节点值（有可能为多位数）
            for (int j = 0; j < num_str.length(); ++j, ++cur_loc) {
                tmp_str1[cur_loc] = num_str[j];
            }
            //右边，如果存在右孩子，那么在第二行对应位置打印'\'，在第一行补上'_'
            if (node->right) {
                q.push(node->right);
                int last_loc = first_locations[node->right] - 1;
                tmp_str2[last_loc] = '\\';
                while (cur_loc < last_loc) {
                    tmp_str1[cur_loc++] = '_';
                }
            }
        }
        //打印两行
        std::cout << tmp_str1 << std::endl;
        std::cout << tmp_str2 << std::endl;
    }
}
// 打印某个结点的值
void mAbstractBinarySearchTree::printNodeValue(TNode*& const node) const
{
    if (node != NULL)
        cout << "Node value: " << node->value << endl;
}

void main()
{
    mTree::mAbstractBinarySearchTree bst;
    bst.insert(10);
    bst.insert(3);
    bst.insert(1);
    bst.insert(12);
    bst.insert(11);
    bst.insert(17);
    bst.insert(5);
    bst.insert(8);
    bst.insert(7);
    bst.insert(6);
    bst.insert(4);
    bst.insert(16);
    bst.printTree();
    while (bst.getSize() != 0)
    {
        // 在这个循环里面删除结点
        int a = INT_MIN;
        cout << "Please input the value that you want to erase: ";
        cin >> a;
        bst.erase(a);
        system("cls");
        bst.printTree();
    }

    system("pause");
}
```

### 0.2 左旋和右旋：

**普通的搜索二叉树可能很不平衡，此时会导致查找的时间复杂度升高。**

<img src="https://img-blog.csdnimg.cn/img_convert/d5c5690ab637e0b6ca2ad995b7f274ff.png" alt="img" style="zoom:67%;" />

**左旋：头结点 X** 向左边倒，其**右孩子 Y** 变成头结点，即**头结点右孩子 Y** 变成头结点，而若**该右孩子 Y** 有左孩子，该左孩子给原来的**头结点 X**，并将原来的**头结点 X** 置为该**右孩子 Y** 的左孩子。

**右旋：**左变头，头变右，左右变头左。

![image-20230411162736185](C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230411162736185.png)

**基于左旋与右旋操作，可以对原不平衡的树进行调整，并可以将原始的不平衡搜索二叉树封装成红黑树、AVL树和SB树。**

**平衡检查时机：**对插入结点，从插入的结点开始往上检查，每个结点是否具有平衡性；对删除结点，同理，从删除结点往上检查，每个结点是否具有平衡性，但如果删除的结点同时具有左右孩子，此时的操作是，将其右树上第一个没有左孩子的结点拿出来，把其右孩子接给其父结点，然后删除头结点，并将该结点放到头结点位置，此时查平衡性，**从原右树上第一个没有左孩子的父节点开始查。**

**1、2、3 的检查不平衡检查时机完全一样，并且调整树的操作也是左旋和右旋，大家都一样，区别在于对平衡的违规条件设置不同，以及三者维护的结构信息不同，AVL树维护的是子树是否平衡，SB树维护的是树的size信息，红黑树维护的是结点是红还是黑。**

**代码：**

``` c plus
// ====================== 自平衡二叉搜索树方法 ====================== //
TNode* mAbstractSelfBalancingBinarySearchTree::rotateLeft(TNode* node)
{
    // 值得注意的是，由于我们的结点结构同时拥有双亲和孩子指针，所以设置结构的时候，两个方向均需要修改
    // 看完整个逻辑，左旋的实际含义是，选定一个结点，然后
    // 1. 把它的右孩子放到当前结点的位置
    // 2. 将右孩子的左孩子接给当前结点的右孩子位置
    // 3. 当前结点作为其右孩子的左孩子
    // 4. 右孩子的父亲变为当前结点的原父亲

    // 因为是左旋，拿到当前结点的右孩子
    TNode* temp = node->right;
    // 1. 把右孩子接到当前结点的父亲下面
    temp->parent = node->parent;
    // 由于是双向的，如果右孩子的父亲存在，则根据原结点是其父亲的左孩子还是右孩子，将右孩子设置为其父亲的左孩子或右孩子
    // 或直接将其设置为根节点
    if (temp->parent != NULL)
        if (node == temp->parent->left)
            temp->parent->left = temp;
        else
            temp->parent->right = temp;
    else
        root = temp;
    // 2. 把右孩子的左孩子接给当前结点作为右孩子
    node->right = temp->left;
    // 由于是双向的，所以如果右孩子的左分支不为空，则一定需要将其父亲设置为当前结点
    if (node->right != NULL)
        node->right->parent = node;
    // 3. 然后把当前结点设置为右孩子的左孩子
    temp->left = node;
    node->parent = temp;

    return temp;
}
TNode* mAbstractSelfBalancingBinarySearchTree::rotateRight(TNode* node)
{
    TNode* temp = node->left;
    // 1.
    temp->parent = node->parent;
    if (temp->parent != NULL)
        if (temp->parent->right == node)
            temp->parent->right = temp;
        else
            temp->parent->left = temp;
    else
        root = temp;
    // 2.
    node->left = temp->right;
    if (node->left != NULL)
        node->left->parent = node;
    // 3.
    temp->right = node;
    node->parent = temp;
    return temp;
}
```



## 1. 红黑树

**规则：**

（1）每个结点要么是红结点，要么是黑节点；

（2）头结点和叶节点（NULL）都是黑结点**（NIL结点，也就是说，没有孩子的结点并不算是真正的叶子结点）**；

（3）红节点不相邻；

（4）以 cur 为准，每条到结束的路径，黑色的结点一样多。

**原理解释：**以上述规则，则红黑树从某个结点开始的最长长度为红黑结点交替的形式往下走，而最短路径是全黑结点路径，则树中的最长最短路径长不可能超过段路径的1倍。

**时间复杂度：**插入、查询和删除的时间复杂度均为 $O(logN)$。

### 1.1 插入元素

<img src="C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230420151801738.png" alt="image-20230420151801738" style="zoom: 50%;" />

（1）插入 *Z* 结点并将其标记为**红色（因为标记红色可能会打破规则 2 和 3，这两个违规是容易修复的）**；

**（2）重新设置颜色并旋转结点。**

​		**情况1：**如果 *Z* 是根节点，则仅需将其染成黑色即可；

​		**情况2：**如果 *Z* 的叔叔结点是红色，此时只需要重新染色即可；

<img src="C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230420154429460.png" alt="image-20230420154429460" style="zoom: 80%;" />

​				**步骤1：**叔父染黑；

​				**步骤2：**祖父染红；

​				**步骤3：**cur 指向祖父。

​		**情况3：**如果 *Z* 的叔叔结点是黑色，并且其对当前违规结点而言，其祖父、父亲以及其自身组成的结构是三角形，则对其父亲结点作旋转操作，明显的，如果违规结点是其父亲的左孩子，则右旋，否则左旋：

<img src="C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230420154642714.png" alt="image-20230420154642714" style="zoom: 50%;" />

​				**步骤1：**父亲右旋；

​				**步骤2：**cur 指向右孩子（原父亲）。

​		**情况4：**如果 *Z* 的叔叔结点是黑色，并且对当前违规结点而言，其祖父、父亲及其自身组成的结构是线型，则对其祖父结点作旋转操作，同理，如果违规结点是其父亲的左孩子（也说明其父亲是祖父的左孩子），则右旋，否则左旋，且旋转后，还需要调整颜色，使得满足红黑树结构。

![image-20230420154921722](C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230420154921722.png)

​				**步骤1：**祖父左旋；

​				**步骤2：**当前父（也是原父）染黑；

​				**步骤3：**当前兄弟（原祖父）染红。

**值得注意的是，**

（1）这个过程要不断向上，直到整棵树完全符合规则；

（2）另外，由于当前结点是红色，那么如果树是违规的，其父亲必然也是红色，所以主要是看其叔叔结点的颜色；

（3）情况 3 实际上是先变换成了情况 4，然后把 cur 指针指向 A，然后继续操作，所以如果不看情况1，一般真正操作结点的分支情况只有情况 2 和情况 3；

（4）在变换过程中，不会影响被操作结点和其子树的颜色合法性，所以在不断向上调整的过程中不用担心已经构建的结构被破坏；

（5）对情况 4 而言，变换之后基本上可以直接达到整棵树的平衡和合法性，其不用修改 cur 的指向，但情况 2 需要将 cur 指向其祖父，因为其祖父是红色，此时仅达到了内部的平衡和合法性。

**代码：**

``` c plus
void mRedBlackTree::insertRBFixup(RedBlackNode* currentNode)
{
if (currentNode->parent == NULL)
{
    ((RedBlackNode*)root)->color = ColorEnum::BLACK;
    return;
}

while (currentNode != root && currentNode->parent != root && ((RedBlackNode*)currentNode->parent)->color != ColorEnum::BLACK)
{	
    // 当满足条件 currentNode->parent != root 的情况下，当前 cur 必然存在祖父结点
    RedBlackNode* parent = (RedBlackNode*)(currentNode->parent);
    RedBlackNode* gradFather = (RedBlackNode*)(parent->parent);
    // 因为每次插入结点的时候，只有当前结点的颜色是不合规则的，所以需要考虑的内容是有限的
    if (parent == gradFather->left)
    {
        // 如果当前结点的父亲是其祖父的左孩子，则叔叔结点一定是其右孩子
        RedBlackNode* uncle = (RedBlackNode*)(gradFather->right);
        if (uncle != NULL && uncle->color == ColorEnum::RED)
        {
            // 如果叔叔结点是红色，则仅用修改颜色
            // 把祖父改成红色，父亲和叔叔都改成黑色，并把 cur 指导祖父位置，进行后续调整
            uncle->color = ColorEnum::BLACK;
            parent->color = ColorEnum::BLACK;
            gradFather->color = ColorEnum::RED;
            currentNode = gradFather;
        }
        else
        {
            // 如果叔叔结点是黑色，则还需要判断当前 gradF、F 和 cur 之间的结构关系，如果是 tri 结构，需要先转换成 line 结构
            if (currentNode == parent->right)
            {
                //  /
                //  \
                // 明显是对 parent 结点进行左旋操作
                currentNode = parent;
                rotateLeft(parent);
            }
            // 到这一步之后必然是 line 结构，经过这里 line 的调整之后，结构必然可以符合红黑树结构
            //   /
            //  /
            // 对当前结点的父亲（其实是原 cur 结点，但是现在信息丢失了）和原祖父结点进行染色
            // 此时原祖父结点和当前结点同级，应染成红色，当前结点的父节点理应是黑色
            // 对祖父结点进行右旋操作
            ((RedBlackNode*)currentNode->parent)->color = ColorEnum::BLACK;
            gradFather->color = ColorEnum::RED;
            rotateRight(gradFather);
        }
    }
    else
    {
        // 如果当前结点的父亲是其祖父的右孩子，则叔叔结点一定是左孩子
        RedBlackNode* uncle = (RedBlackNode*)(gradFather->left);
        if (uncle != NULL && uncle->color == ColorEnum::RED)
        {
            parent->color = ColorEnum::BLACK;
            uncle->color = ColorEnum::BLACK;
            gradFather->color = ColorEnum::RED;
            currentNode = gradFather;
        }
        else
        {
            if (currentNode == parent->left)
            {
                currentNode = parent;
                rotateRight(parent);
            }
            ((RedBlackNode*)currentNode->parent)->color = ColorEnum::BLACK;
            gradFather->color = ColorEnum::RED;
            rotateLeft(gradFather);
        }
    }
}
((RedBlackNode*)root)->color = ColorEnum::BLACK;
}
```

### 1.2 删除元素

**（1）删除方法**

​		**情况1：**左孩子是 NIL；

​		**情况2：**右孩子是NIL；

​		**情况3：**两个孩子不是NIL；

<font color = red>**注：上述的过程只是删除结点的步骤，还有一步是调整红黑树的过程。且这个过程其实和一般二叉搜索树是一样的。**</font>

<font color = red>**另外，如果一个结点仅含有左右某个子树，那么在它含有的那一棵子树上必然不会存在黑色的结点。其实也说明，如果该结点是黑色的，那它包含的那棵子树上仅能存在一个红色结点，如果该结点是红色的，那么它一定是叶子结点，也就是说，不存在红色结点只含有一棵子树的情况，红色的结点要么有两个子树，要么是叶子结点。**</font>

**（2）调整方法**

​		在插入调整的时候，我们的主要依据是叔叔结点，此时的主要依据是兄弟结点，值得注意的是，所谓兄弟结点，指的是在删除操作中，用于替换原删除结点的结点的兄弟：

<img src="C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230421202155182.png" alt="image-20230421202155182" style="zoom: 33%;" />

​		**情况1：**w 为红色；

<img src="C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230421204544957.png" alt="image-20230421204544957" style="zoom: 50%;" />

​				**步骤1：**w 染成黑色；

​				**步骤2：**x 的父亲染成红色；

​				**步骤3：**对 x 的父亲进行左旋；

​				**步骤4：**把 w 指向当前 x 的兄弟结点。

​		**情况2：**w 为黑色，而 w 的左孩子和右孩子**都是黑色**；

<img src="C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230421205554950.png" alt="image-20230421205554950" style="zoom: 80%;" />

​				**步骤1：**w 染成红色；

​				**步骤2：**直接把 x 指向其父亲；

​		**情况3：**w 为黑色，而 w 的左孩子是红色，但右孩子是黑色；

<img src="C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230421210201519.png" alt="image-20230421210201519" style="zoom:80%;" />

​				**步骤1：**w 的左孩子染成黑色；

​				**步骤2：**w 染成红色；

​				**步骤3：**对 w 右旋；

​				**步骤4：**w 重新指向 x 的兄弟。		

​		**情况4：**w 为黑色，而 w 的右孩子是红色，**值得注意的是，情况 3 最后也会落到情况 4 中，即情况 3 操作之后，w 的右孩子也变成了红色**。

<img src="C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230421211042939.png" alt="image-20230421211042939" style="zoom:80%;" />

​				**步骤1：**w 染成它父亲的颜色（因为 w 是 x 的兄弟）；

​				**步骤2：**x 的父亲染成黑色；

​				**步骤3：**将 w 的右孩子染成黑色；

​				**步骤4：**对 x 的父亲作左旋。		

​				**步骤5：**将 x 设置为根结点。

**代码：**

``` c plus
// 重写删除函数
TNode* mRedBlackTree::erase(TNode*& const eraseNode)
{
	// removeOrMovedNode 代表的是真正需要删除的结点，对已经基本处于末端的结点（最多含有一个结点），其就是本身
	// 对于含有两个结点的待删除结点，其代表原待删除结点右子树上最左边的结点，此时等价于删除该结点
	// replaceNode 代表的是用于替换真正需要删除的结点的结点，有可能是空
	TNode* replaceNode = NULL;
	if (eraseNode != NULL && eraseNode != nilNode)
	{
		TNode* removeOrMovedNode = eraseNode;
		ColorEnum removeOrMovedNodeColor = ((RedBlackNode*)removeOrMovedNode)->color;
		if (eraseNode->left == nilNode)
		{
			// 如果要删除的结点没有左孩子，则直接将其右孩子接在待删除结点位置
			replaceNode = eraseNode->right;
			transplant(eraseNode, replaceNode);
		}
		else if (eraseNode->right == nilNode)
		{
			// 如果要删除的结点没有右孩子，则直接将其左孩子接在待删除结点位置
			replaceNode = eraseNode->left;
			transplant(eraseNode, replaceNode);
		}
		else
		{
			// 说明待删除结点左右孩子均含有，此时选后续结点来替代原结点
			// 至于为什么这里看的是后继节点的颜色而非待删除结点的颜色
			// 是因为通过将后继结点替换到原结点的位置并将其染成原结点的颜色，则最终可以看成删除的结点是后继结点
			removeOrMovedNode = getMinimum(eraseNode->right);
			removeOrMovedNodeColor = ((RedBlackNode*)removeOrMovedNode)->color;
			// 所以最终，这的删除实际上相当于删除了原待删除结点右子树上最左边的结点，并用其右子树来替换了它所在的位置
			// 当然，其右子树可能是空的
			replaceNode = removeOrMovedNode->right;
			if (removeOrMovedNode->parent == eraseNode)
				// 至于说为什么要进行这一步操作，个人感觉是由于要适配右树为空的特殊情况，此时用该 nilNode 来进行后续操作
				replaceNode->parent = removeOrMovedNode;
			else
			{
				transplant(removeOrMovedNode, removeOrMovedNode->right);
				removeOrMovedNode->right = eraseNode->right;
				removeOrMovedNode->right->parent = removeOrMovedNode;
			}
			transplant(eraseNode, removeOrMovedNode);
			removeOrMovedNode->left = eraseNode->left;
			removeOrMovedNode->left->parent = removeOrMovedNode;
			// 和我想的一样，将原待删除的结点用其它结点替换，然后把替换过来的结点的颜色染成原结点的颜色
			((RedBlackNode*)removeOrMovedNode)->color = ((RedBlackNode*)eraseNode)->color;
		}
		// 释放空间
		delete eraseNode;
		size--;
		if (removeOrMovedNodeColor == ColorEnum::BLACK)
			// 仅在真正删除的结点的颜色是黑色的情况下，才需要执行修复操作，删除红色结点没有影响
			// 因为最终在删除结点的时候，始终删除的是一个仅有一棵子树的结点，所以只要原结点不是黑色，则其总是可以自己达到平衡
			// 如果 replaceNode 是空的，此时有个问题，在于没有办法访问到它的兄弟结点
			eraseRBFixup((RedBlackNode*)replaceNode);
	}
	return replaceNode;
}

// 在删除结点之后进行树结构的修复
void mRedBlackTree::eraseRBFixup(RedBlackNode* x)
{
	while (x != root && isBlack(x))
	{
		if (x == x->parent->left)
		{
			RedBlackNode* w = (RedBlackNode*)x->parent->right;
			if (isRed(w))
			{
				w->color = ColorEnum::BLACK;
				((RedBlackNode*)x->parent)->color = ColorEnum::RED;
				rotateLeft(x->parent);
				w = (RedBlackNode*)x->parent->right;
			}
			if (isBlack(w->left) && isBlack(w->right))
			{
				w->color = ColorEnum::RED;
				x = (RedBlackNode*)x->parent;
			}
			else if (w != nilNode)
			{
				if (isBlack(w->right))
				{
					((RedBlackNode*)w->left)->color = ColorEnum::BLACK;
					w->color = ColorEnum::RED;
					rotateRight(w);
					w = (RedBlackNode*)x->parent->right;
				}
				w->color = ((RedBlackNode*)x->parent)->color;
				((RedBlackNode*)x->parent)->color = ColorEnum::BLACK;
				((RedBlackNode*)w->right)->color = ColorEnum::BLACK;
				rotateLeft(x->parent);
				x = (RedBlackNode*)root;
			}
			else
			{
				x->color = ColorEnum::BLACK;
				x = (RedBlackNode*)x->parent;
			}
		}
		else
		{
			RedBlackNode* w = (RedBlackNode*)x->parent->left;
			if (isRed(w)) 
			{
				w->color = ColorEnum::BLACK;
				((RedBlackNode*)x->parent)->color = ColorEnum::RED;
				rotateRight(x->parent);
				w = (RedBlackNode*)x->parent->left;
			}
			if (isBlack(w->left) && isBlack(w->right)) 
			{
				w->color = ColorEnum::RED;
				x = (RedBlackNode*)x->parent;
			}
			else if (w != nilNode) 
			{
				if (isBlack(w->left)) 
				{
					((RedBlackNode*)w->right)->color = ColorEnum::BLACK;
					w->color = ColorEnum::RED;
					rotateLeft(w);
					w = (RedBlackNode*)x->parent->left;
				}
				w->color = ((RedBlackNode*)x->parent)->color;
				((RedBlackNode*)x->parent)->color = ColorEnum::BLACK;
				((RedBlackNode*)w->left)->color = ColorEnum::BLACK;
				rotateRight(x->parent);
				x = (RedBlackNode*)root;
			}
			else 
			{
				x->color = ColorEnum::BLACK;
				x = (RedBlackNode*)x->parent;
			}
		}
	}
	// 不加这一句是错的，我也不知道为什么加了就是对的...
	x->color = ColorEnum::BLACK;
}

void main()
{
    mRedBlackTree rbTree;
    vector<int> arr = RandVector_NoRepeat(1, 100, 20);
    for (int i = 0; i < arr.size(); i++)
        rbTree.insert(arr[i]);
    rbTree.printTree();
	while (rbTree.getSize() != 0)
    {
        // 在这个循环里面删除结点
        int a = INT_MIN;
        cout << "Please input the value that you want to erase: ";
        cin >> a;
        mTree::TNode* nodeToErase = rbTree.search(a);
		rbTree.erase(nodeToErase);
        system("cls");
        rbTree.printTree();
    }

    system("pause");
}
```



## 2. AVL（Adelson-Velskii and Landis）树

### 2.1 原理简述

**平衡性：**

​		AVL 树的每一个结点都要维护一个平衡因子，用于表示左右子树的高度差异，即用左树的高度减去右树的高度，而为了达到 AVL 树的平衡，每个结点的平衡因子只能是 0、-1、1，否则就是不平衡的。

**四种不平衡类型：**

**（1）LL型：**

<img src="https://img-blog.csdnimg.cn/img_convert/db975b8a3af71c9cf11f4f3b1308eebf.png" alt="img" style="zoom:80%;" />

**不平衡原因：**上图中所示的三种不平衡的情况，都是根节点的左孩子的左孩子（LL）所造成，即因为 LL 本身或 LL 身上挂载了其他节点，造成了根节点的不平衡。这种情况下我们只需要对根节点进行一次右旋操作，即可恢复平衡。

**调整结果：**原本的**根节点**和**根节点的左孩子节点**的平衡因子会归零；原 LL 节点的平衡因子不会发生改变。

**（2）RR型：**

<img src="https://img-blog.csdnimg.cn/img_convert/88fea42f96f1872f508141c60de10b16.png" alt="img" style="zoom:80%;" />

**不平衡原因：**与LL相反，以上三种不平衡的情况都是根节点的右孩子的右孩子（RR）所造成，即因为 RR 本身或 RR 身上挂载了其他节点，造成了根节点的不平衡。这种情况下我们只需要对根节点进行一次左旋操作，即可恢复平衡。

**调整结果：**原本的**根节点**和**根节点的左孩子节点**的平衡因子会归零；原 RR 节点的平衡因子不会发生改变。

**（3）LR型：**

<img src="https://img-blog.csdnimg.cn/img_convert/13a39c1cc7a8075e6fefe627d6980dd7.png" alt="img" style="zoom:80%;" />

**不平衡原因：**这种不平衡的情况是根节点的左孩子的右孩子（LR）所造成，即因为 LR 本身或 LR 身上挂载了其他节点，造成了根节点不平衡。与前两种情况不同的是，上图所示的三种情况**无法通过单次的左旋或右旋操作使其达到平衡**。以第一种情况为例，假如我们直接对根节点进行右旋操作，会发现 3 节点成为了 4、6 节点的父节点，这显然不符合二叉搜索树的规则。究其原因，是因为根节点的平衡因子与根节点的左孩子的平衡因子符号不相同导致。那么我们只需要先将符号统一，再进行整体上的旋转操作即可。

​		具体操作即对问题结点先左旋再右旋即可。

**调整结果：**

原 LR 节点的平衡因子都会归零；

如果原 LR 节点平衡因子为-1，则调整后的原 L 节点平衡因子为1，否则为0；

如果原 LR 节点平衡因子为1，则调整后的原根节点平衡因子为-1，否则为0。

**（4）RL型：**

<img src="https://img-blog.csdnimg.cn/img_convert/bffc47bf85ebbf90e43e1f2ff0e2fce7.png" alt="img" style="zoom:80%;" />

**不平衡原因：**这种不平衡的情况是根节点的左孩子的右孩子（RL）所造成，即因为 RL 本身或 RL 身上挂载了其他节点，造成了根节点不平衡。

​		具体操作即对问题结点先右旋再左旋即可。

**调整结果：**

原 RL 节点的平衡因子都会归零；

如果原 RL 节点平衡因子为1，则调整后的原 R 节点平衡因子为-1，否则为0；

如果原 RL 节点平衡因子为-1，则调整后的原根节点平衡因子为1，否则为0；

### 2.2 代码

​		该树的实现原理也很简单哈，就尼玛红黑树最恶心。

``` c plus
namespace mAVLTree
{
	mTree::TNode* mAVLTree::insert(const int& element)
	{
		// 先用父类方法插入结点，然后再平衡
		TNode* newNode = mAbstractSelfBalancingBinarySearchTree::insert(element);
		rebalance((mAVLNode*)newNode);
		return newNode;
	}
	mTree::TNode* mAVLTree::erase(const int& element)
	{
		// 先找出来需要删除的结点
		TNode* eraseNode = mAbstractSelfBalancingBinarySearchTree::search(element);
		if (eraseNode != NULL)
		{
			// 找到待删除结点的后继结点
			// 值得注意的是 mAbstractSelfBalancingBinarySearchTree 中的 erase
			// 其返回的结点正儿八经是用于替换待删除结点的结点（当然可能是 NULL）
			// 值得注意的是，我们需要用到待删除结点的父亲，所以在执行删除之前，首先要维护待删除结点的父亲结点
			TNode* parent = eraseNode->parent;
			TNode* successorNode = mAbstractSelfBalancingBinarySearchTree::erase(eraseNode);
			if (successorNode != NULL)
			{
				// 如果是用非空结点来替代的原待删除结点
				// 非常明显的一点在于，如果原待删除结点仅有左右孩子之中的一个，此时就应该从当前替换后的那个结点开始向上检查
				// 而如果原待删除结点同时拥有左右两个孩子，此时必须要从当前结点右子树上最左边结点开始往上检查
				// 因为从那个结点开始，所有结点的高度都有可能发生了变化（当然也包括放在了原待删除结点位置的那个结点）
				// 当然，这个地方直接以当前结点是否存在右树来判断，也是完全没有问题的
				// 实际上，如果用于替换原待删除结点的结点如果存在右树，则它一定是属于原待删除结点左右树均存在的情况，这个很容易想
				mAVLNode* minimum = ((successorNode->right != NULL) ? (mAVLNode*)getMinimum(successorNode->right) : (mAVLNode*)successorNode);
				recomputeHeight(minimum);
				rebalance((mAVLNode*)minimum);
			}
			else
			{
				// 如果是用一个空结点来代替原待删除结点的位置
				// 明显的，此时应从原待删除结点的父亲开始检查并重新平衡
				recomputeHeight((mAVLNode*)parent);
				rebalance((mAVLNode*)parent);
			}
			return successorNode;
		}
		return NULL;
	}
	mTree::TNode* mAVLTree::createNode(const int& value, TNode* const parent, TNode* const left, TNode* const right)
	{
		return new mAVLNode(value, parent, left, right);
	}

	void mAVLTree::rebalance(mAVLNode* node)
	{
		while (node != NULL)
		{
			TNode* parent = node->parent;
			// 相当于如果左右树为空，则左右树的高度设置为 -1，否则直接去读对应结点的高度
			int leftHeight = (node->left == NULL) ? -1 : ((mAVLNode*)node->left)->height;
			int rightHeight = (node->right == NULL) ? -1 : ((mAVLNode*)node->right)->height;
			int nodeBalance = rightHeight - leftHeight;
			if (nodeBalance == 2)
			{
				// 说明是右树过于高了
				if (node->right->right != NULL)
				{
					// RR 型，则直接对当前结点执行左旋即可
					node = (mAVLNode*)rotateLeft(node);
					break;
				}
				else
				{
					// RL 型，对其右孩子右旋，得到 RR 型，然后左旋
					node = (mAVLNode*)doubleRotateRightLeft(node);
					break;
				}
			}
			else if (nodeBalance == -2)
			{
				// 说明是左树过于高了
				if (node->left->left != NULL)
				{
					// LL 型
					node = (mAVLNode*)rotateRight(node);
					break;
				}
				else
				{
					// LR 型
					node = (mAVLNode*)doubleRotateLeftRight(node);
					break;
				}
			}
			else
				// 没有不平衡产生
				// 在每次插入结点之后，重平衡的时候，必然先执行这一步，此时新插入的结点高度被更新成 0
				updateHeight(node);
			// 然后继续沿着当前的 node 向上检查
			node = (mAVLNode*)parent;
		}
	}
	mTree::TNode* mAVLTree::rotateLeft(mTree::TNode* node)
	{
		// 容易想到，左旋的情况下，以原结点为基准，只有原结点以及原结点的右孩子的高度变了
		// 至于为什么这里是 temp->left，只是因为在旋转之后，返回的结点实际上是原结点的右孩子，原结点对应于返回结点的左孩子
		TNode* temp = mAbstractSelfBalancingBinarySearchTree::rotateLeft(node);
		updateHeight((mAVLNode*)temp->left);
		updateHeight((mAVLNode*)temp);
		return temp;
	}
	mTree::TNode* mAVLTree::rotateRight(mTree::TNode* node)
	{
		TNode* temp = mAbstractSelfBalancingBinarySearchTree::rotateRight(node);
		updateHeight((mAVLNode*)temp->right);
		updateHeight((mAVLNode*)temp);
		return temp;
	}
	// 对孩子右旋，然后自身左旋，针对 RL 不平衡
	mTree::TNode* mAVLTree::doubleRotateRightLeft(mTree::TNode* node)
	{
		// 原代码里面还设置了当前 node 的 right 是旋转后的 right，但个人感觉明显没必要啊，rotateRight 里面明显已经修改了原结点的所有父子关系
		rotateRight(node->right);
		return rotateLeft(node);
	}
	// 对孩子左旋，然后自身右旋，针对 LR 不平衡
	mTree::TNode* mAVLTree::doubleRotateLeftRight(mTree::TNode* node)
	{
		rotateLeft(node->left);
		return rotateRight(node);
	}
	// 重新计算结点的高度
	// 这个函数正确的条件是：默认 node 以下的结点高度全部正确
	void mAVLTree::recomputeHeight(mAVLNode* node)
	{
		// 从给定结点开始，一直网上重新计算
		while (node != NULL)
		{
			updateHeight(node);
			node = (mAVLNode*)node->parent;
		}
	}
	// 返回两棵树中，较高的那棵树的高度
	int mAVLTree::maxHeight(mAVLNode* node1, mAVLNode* node2)
	{
		// 返回两棵树中，非空树的高度，如果是空树则返回高度为 -1
		// 说明对于一个只有一个结点的树而言，其高度是 0
		if (node1 != NULL && node2 != NULL)
			return node1->height > node2->height ? node1->height : node2->height;
		else if (node1 == NULL)
			return node2 != NULL ? node2->height : -1;
		else if (node2 == NULL)
			return node1 != NULL ? node1->height : -1;
		else
			return -1;
	}
	// 该函数和 recomputeHeight 的唯一区别就在于，recomputeHeight 会沿着给定结点向上计算所有结点的高度
	void mAVLTree::updateHeight(mAVLNode* node)
	{
		// 其实就是再根据左右树的高度来算一下当前树的高度
		int leftHeight = (node->left == NULL) ? -1 : ((mAVLNode*)node->left)->height;
		int rightHeight = (node->right == NULL) ? -1 : ((mAVLNode*)node->right)->height;
		node->height = 1 + max(leftHeight, rightHeight);
	}
}

void main()
{
    mAVLTree::mAVLTree avlTree;
    vector<int> arr = RandVector_NoRepeat(1, 100, 20);
    for (int i = 0; i < arr.size(); i++)
        avlTree.insert(arr[i]);
    avlTree.printTree();
    while (avlTree.getSize() != 0)
    {
        // 在这个循环里面删除结点
        int a = INT_MIN;
        cout << "Please input the value that you want to erase: ";
        cin >> a;
        avlTree.erase(a);
        system("cls");
        avlTree.printTree();
    }

    system("pause");
}
```



## 3. SB（Size Balance Tree）树

**平衡性：**

​		每棵子树的大小，不小于其兄弟的子树大小，即每棵叔叔树的大小，不小于其任何侄子树的大小。

**四种不平衡类型：**

**（1）LL型：**某根左孩子的左孩子比其右孩子的规模大，对该子树做右旋操作，此时如果有结点的孩子结点发生变化，就重复对孩子结点进行递归调整，复杂度为 $O(logN)$；

**（2）RR型：**某根右孩子的右孩子比其左孩子的规模大，对该子树做左旋操作，此时如果有结点的孩子结点发生变化，就重复对孩子结点进行递归调整，复杂度为

$O(logN)$；

**（3）LR型：**某根左孩子的右孩子的规模大于了其叔叔结点的规模，**关键在于把规模大的那个结点搞到当前头结点位置。**先针对左子树做左旋，然后对根作右旋，然后对所有孩子发生了变化的树都递归执行一遍平衡性调整；

**（4）RL型：**某根右孩子的左孩子的规模大于了其叔叔结点的规模，**关键在于把规模大的那个结点搞到当前头结点位置。**先针对右子树做右旋，然后对根作左旋，然后对所有孩子发生了变化的树都递归执行一遍平衡性调整；

<font color = red>**值得注意的是，要搞清楚左右旋的目的，是把某个过长活规模过大的结点放到头结点的位置，减少其层数，而这个目标结点在旋转的过程中，左旋则其保留其右孩子，右旋则保留其左孩子。**</font>

### 3.1 类代码：

**（其实也没有太难理解的地方，只是需要注意递归的操作方法）**

``` c plus
#include"mTree.h"
using namespace mTree;

namespace mSBTree
{
	// SB 树的结点
	template<class K, class V>
	class mSBTNode
	{
	public:
		K key;
		V value;
		mSBTNode<K, V>* left;
		mSBTNode<K, V>* right;
		// 只要创建了结点，默认的 size 为1
		int size = 1;
		mSBTNode(const K& key, const V& value) :key(key), value(value) {}
	};
	template<class K, class V>
	int getSize_(mSBTNode<K, V>* node)
	{
		return node == NULL ? 0 : node->size;
	}
	// SB 树定义
	template<class K, class V>
	class mSBTree
	{
	public:
		// 根节点
		mSBTNode<K, V>* root = NULL;
		// 由于在这个里面我们定义的结点没有 parent，所以对结点的左右旋转操作比较简单
		// 值得注意的是，我们理解的左右旋，理论上是要修改当前子树根对应父亲结点的指向的
		// 但在这段代码里面，左右旋仅仅改变了子树内部的结构，没有将原根父亲指向新根
		mSBTNode<K, V>* rotateRight(mSBTNode<K, V>* cur)
		{
			mSBTNode<K, V>* leftNode = cur->left;
			cur->left = leftNode->right;
			leftNode->right = cur;
			// 这一点是很容易想的，现在左节点替换了原结点的位置，包含其自身在内，在这个局部上它的 size 就是原结点的size
			leftNode->size = cur->size;
			// 至于已经变为左孩子的右孩子的原结点，其大小可以通过统计其当前左右孩子的 size 来得到
			cur->size = (cur->left != NULL ? cur->left->size : 0) + (cur->right != NULL ? cur->right->size : 0) + 1;
			// 此时原左孩子转到了父亲的位置，则返回当前父亲位置结点
			return leftNode;
		}
		mSBTNode<K, V>* rotateLeft(mSBTNode<K, V>* cur)
		{
			mSBTNode<K, V>* rightNode = cur->right;
			cur->right = rightNode->left;
			rightNode->left = cur;
			rightNode->size = cur->size;
			cur->size = (cur->right != NULL ? cur->right->size : 0) + (cur->left != NULL ? cur->left->size : 0) + 1;
			return rightNode;
		}
		mSBTNode<K, V>* maintain(mSBTNode<K, V>* cur)
		{
			if (cur == NULL) {
				// 如果当前检查结点为空，则直接返回
				return NULL;
			}
			if (cur->left != NULL && getSize_(cur->left->left) > getSize_(cur->right))
			{
				// LL 型不平衡
				// 对本身右旋，右旋之后，原结点和原结点的左孩子的孩子发生改变，需要递归进行检查
				// 当然，也可以看作是旋转后 cur 和 cur 的右孩子的孩子发生改变
				cur = rotateRight(cur);
				cur->right = maintain(cur->right);
				cur = maintain(cur);
			}
			else if (cur->left != NULL && getSize_(cur->left->right) > getSize_(cur->right))
			{
				// LR 型不平衡
				cur->left = rotateLeft(cur->left);
				cur = rotateRight(cur);
				// 对左右孩子检查完毕之后，检查 cur
				cur->left = maintain(cur->left);
				cur->right = maintain(cur->right);
				cur = maintain(cur);
			}
			else if (cur->right != NULL && getSize_(cur->right->right) > getSize_(cur->left))
			{
				// RR 型不平衡
				cur = rotateLeft(cur);
				cur->left = maintain(cur->left);
				cur = maintain(cur);
			}
			else if (cur->right != NULL && getSize_(cur->right->left) > getSize_(cur->left))
			{
				// RL 型不平衡
				cur->right = rotateRight(cur->right);
				cur = rotateLeft(cur);
				cur->left = maintain(cur->left);
				cur->right = maintain(cur->right);
				cur = maintain(cur);
			}
			return cur;
		}
		mSBTNode<K, V>* findLastIndex(const K& key)
		{
			// 根据观察，这个函数的效果是
			// 如果能找到 key 结点，则返回 key 结点
			// 如果找不到 key 结点，则返回如果当前想要插入这个 key 作为新的结点，其对应的父节点（这个结点的 key 可能比当前 key 大也可能小）
			mSBTNode<K, V>* pre = root;
			mSBTNode<K, V>* cur = root;
			while (cur != NULL)
			{
				pre = cur;
				if (key == cur->key)
					break;
				else if (key < cur->key)
					cur = cur->left;
				else
					cur = cur->right;
			}
			return pre;
		}
		// 这个函数的效果在于，找到树中，最接近但又不小于给定 key 的那个结点
		mSBTNode<K, V>* findLastNoSmallIndex(const K& key)
		{
			mSBTNode<K, V>* ans = NULL;
			mSBTNode<K, V>* cur = root;
			while (cur != NULL)
			{
				if (key == cur->key)
				{
					ans = cur;
					break;
				}
				else if (key < cur->key)
				{
					// 如果当前结点的 key 比给定的 key 大，则需要记录当前结点，然后继续向左边跳，看是否有另一个 key 比 cur 的 key 小
					// 但大于等于给定的 key
					ans = cur;
					cur = cur->left;
				}
				else
					cur = cur->right;
			}
			return ans;
		}
		// 这个函数的效果在于，找到树中，最接近但又不大于给定 key 的那个结点
		mSBTNode<K, V>* findLastNoBigIndex(const K& key)
		{
			mSBTNode<K, V>* ans = NULL;
			mSBTNode<K, V>* cur = root;
			while (cur != NULL)
			{
				if (cur->key == key)
				{
					ans = cur;
					break;
				}
				else if (key < cur->key)
					cur = cur->left;
				else
				{
					// 说明 cur 的 key 比给定的小
					ans = cur;
					cur = cur->right;
				}
			}
			return ans;
		}
		// 值得注意的是，add 函数内部，也没有对子树父节点的关系作处理（但对于给定的 cur 子树内部，其是作了父子结点关系处理的，在 * 位置）
		// 而该函数作为一个递归函数，则之后在实际提供的公用接口中，传入的 cur 应当始终是 root
		// 此时就无需考虑父亲的关系
		mSBTNode<K, V>* add(mSBTNode<K, V>* cur, const K& key, const V& value)
		{
			if (cur == NULL)
				// 只有当结点子树为空的时候，才用新节点作插入，新结点本身的 size 自动初始化为 1
				return new mSBTNode<K, V>(key, value);
			else
			{
				// 经过的所有结点的 size 都要 ++
				cur->size++;
				if (key < cur->key)
					// *****
					cur->left = add(cur->left, key, value);
				else
					// *****
					cur->right = add(cur->right, key, value);
				// 返回当前子树在进行 maintain 之后的根
				return maintain(cur);
			}
		}
		void put(const K& key, const V& value)
		{
			if (key == NULL)
				throw string("Invalid parameter!");
			mSBTNode<K, V>* lastNode = findLastIndex(key);
			if (lastNode != NULL && key == lastNode->key)
				// 如果原 key 已经被插入到树中，则修改对应结点的 value 
				lastNode->value = value;
			else
				// 如果原树为空（lastNode 为 NUll）或没找到对应结点（lastNode 不为 NULL 但其 key 不为给定的 key）
				// 则加入结点，与我所想的相同，是从 root 开始插入，这样才能保证结点的父亲关系不混乱
				root = add(root, key, value);
		}
		// 又是一个递归调用的函数
		mSBTNode<K, V>* erase(mSBTNode<K, V>* cur, const K& key)
		{
			// 经过的结点全部都要 size--
			cur->size--;
			if (key > cur->key)
				cur->right = erase(cur->right, key);
			else if (key < cur->key)
				cur->left = erase(cur->left, key);
			else
			{
				// 仅在这种情况下才真正地去删除结点
				if (cur->left == NULL && cur->right == NULL)
				{
					// 如果待删除结点左右孩子均为空，则直接释放对应结点的内存空间即可
					// 值得注意的是，此时需要返回 NULL，因为在调用这个函数的时候，是以 node->right or left = erase(...) 的形式
					// 此时需要把其调用该函数的位置对应结点的孩子置为 NULL
					delete cur;
					cur = NULL;
				}
				else if (cur->left == NULL && cur->right != NULL)
				{
					// 需要记录一下待删除的结点
					mSBTNode<K, V>* nodeToErase = cur;
					// 左孩子为空右孩子不为空
					cur = cur->right;
					delete nodeToErase;
				}
				else if (cur->left != NULL && cur->right == NULL)
				{
					mSBTNode<K, V>* nodeToErase = cur;
					cur = cur->left;
					delete nodeToErase;
				}
				else
				{
					// 两个孩子均不为空的情况，很明显，还是找右树上最左边的结点来替换待删除结点
					// 值得注意的是，此时需要对应修改结点的 size
					mSBTNode<K, V>* pre = NULL;
					mSBTNode<K, V>* des = cur->right;
					des->size--;
					// 这个循环找到的 des 就是右子树上的最左边的结点
					// 但此时的 pre 对应的是 des 的父节点，当然，如果当前右子树上没有左子树，pre 为初始的 NULL
					while (des->left != NULL)
					{
						// 沿着右树一直向左找
						pre = des;
						des = des->left;
						// 一个明显的效果在于，右树上最左结点的 size 其实不会在这个循环中减小，其实无所谓，这个结点的 size 有进一步处理
						des->size--;
					}
					if (pre != NULL)
					{
						// 说明当前右孩子有左孩子
						// 这个过程在干嘛，可以去看 自平衡二叉树 部分的解释，很简单，且值得注意的是 pre 的 size 也是被 -- 过的
						pre->left = des->right;
						// 把待删除结点的右树接到替换结点的右树
						des->right = cur->right;
					}
					// 把待删除结点的左树接到替换结点的左树
					des->left = cur->left;
					// 当前 cur 的 size 是 -- 过的，所以直接赋给 des 即可
					des->size = cur->size;
					// 释放 cur 的空间
					delete cur;
					// 将 cur 指向原给定的待删除结点位置处的代替结点
					cur = des;
				}
			}
			// 这里检查和调整没有任何问题，感觉很屌，看到该函数的头部的 size-- 就应该理解到
			// 这个递归函数实际上会对所有孩子产生了变化的结点都进行检查和调整
			cur = maintain(cur);
			return cur;
		}
		void remove(const K& key)
		{
			if (key == NULL)
				throw string("Invalid parameter!");
			if (containsKey(key))
				// 在原树包含 key 的情况下，才调用 erase 函数
				// 从 root 开始的所有结点到删除结点的整条路径上的结点都会被检查
				root = erase(root, key);
		}
		// 该函数的效果似乎是，找出除开右子树的 size 之后，左树 + 根（1） size = kth 的子树根
		// 实际上这个函数的效果是，给定 kth，找出树中第 kth 小的结点，kth 从 1 开始
		// 原理就是，如果一棵子树的根左树上有 n 个结点，那么该根一定是子树中第 n + 1 小的结点
		mSBTNode<K, V>* getIndex(mSBTNode<K, V>* cur, const int& kth)
		{
			if (kth == (cur->left != NULL ? cur->left->size : 0) + 1)
				return cur;
			else if (kth <= (cur->left != NULL ? cur->left->size : 0))
				// 如果没有进入第一个判断，在不包括子树本身的情况下，往左跳了之后，在该子树上，左子树 + 根（1） 的 size 理应比原子树少 1
				return getIndex(cur->left, kth);
			else
				// 此时 kth 等于原 kth 减去当前子树的 左子树 + 根（1） 的 size
				// 如果此时 kth 太大了，那么其实就是在当前右树上找第 kth - 左树 + 根（1） size 小的结点
				return getIndex(cur->right, kth - (cur->left != NULL ? cur->left->size : 0) - 1);
		}
		int getSize()
		{
			return root == NULL ? 0 : root->size;
		}
		bool containsKey(const K& key)
		{
			if (key == NULL)
				// 说明我们这树如果 key 是 int，那么不能用 0 作为 key
				throw string("Invalid parameter!");
			mSBTNode<K, V>*  lastNode = findLastIndex(key);
			// 事实上，findLastIndex 只可能在树完全为空（根节点指向 NULL）的情况下才返回 NULL
			return lastNode != NULL && key == lastNode->key ? true : false;
		}
		// 返回第 index + 1 小的结点对应的 key
		K getIndexKey(const int& index)
		{
			if (index < 0 || index >= getSize())
				throw string("Invalid parameter!");
			return getIndex(root, index + 1)->key;
		}
		// 返回给定 key 的结点对应的 value
		V get(const K& key)
		{
			if(key == NULL)
				throw string("Invalid parameter!");
			mSBTNode<K, V>* lastNode = findLastIndex(key);
			if (lastNode != NULL && key == lastNode->key)
				return lastNode->value;
			else
				// 啊这，那说明 value 中也不能出现 0
				return NULL;
		}
		// 返回树中的最小 key
		K firstKey()
		{
			if (root == NULL)
				return NULL;
			mSBTNode<K, V>* cur = root;
			while (cur->left != NULL)
				cur = cur->left;
			return cur->key;
		}
		// 返回树中的最大 key
		K lastKey()
		{
			if (root == NULL)
				return NULL;
			mSBTNode<K, V>* cur = root;
			while (cur->right != NULL)
				cur = cur->right;
			return cur->key;
		}
		// 如果树中有对应 key，返回对应 key
		// 如果树中没有对应 key，返回最接近该 key 但又不大于该 key 的 key
		K floorKey(const K& key)
		{
			if(key ==NULL)
				throw string("Invalid parameter!");
			mSBTNode<K, V>* lastNoBigNode = findLastNoBigIndex(key);
			// 如果返回 NULL，要么树是空的，要么没有小于等于给定 key 的 node
			return lastNoBigNode == NULL ? NULL : lastNoBigNode->key;
		}
		// 如果树中有对应 key，返回对应 key
		// 如果树中没有对应 key，返回最接近该 key 但又不小于该 key 的 key
		K ceilingKey(const K& key)
		{
			if(key==NULL)
				throw string("Invalid parameter!");
			mSBTNode<K, V>* lastNoSmallNode = findLastNoSmallIndex(key);
			return lastNoSmallNode == NULL ? NULL : lastNoSmallNode->key;
		}
	};
}
```

### 3.2 主函数：

``` c plus
void main()
{
	mSBTree::mSBTree<int, int> sbTree;
	vector<int> arr = RandVector_NoRepeat(1, 100, 30);
    for (int i = 0; i < arr.size(); i++)
		sbTree.put(arr[i], arr[i]);
    int destKey = 40;
    cout << "The floor key of " << destKey << ": " << sbTree.floorKey(destKey) << endl;
    cout << "The ceiling key of " << destKey << ": " << sbTree.ceilingKey(destKey) << endl;

    sbTree.printTree();
    while (sbTree.getSize() != 0)
    {
        // 在这个循环里面删除结点
        int a = INT_MIN;
        cout << "Please input the value that you want to erase: ";
        cin >> a;
        sbTree.remove(a);
        system("cls");
        sbTree.printTree();
    }
    system("pause");
}
```



## 4. 跳表Skiplist

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210430130749617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70)

**原理简述：**每次插入数据的时候，**随机地（默认后续指针数目为 1 个，然后每次以 0.5 的概率生成更多后续指针）**为该结点创建任意个后续指针。那么可以想见，如果节点数目为 N，则

拥有单链的结点数目为 N 个；

拥有双链的结点数目为 N/2 个；

拥有三链的结点数目为 N/4 个；

...拥有 n 链的结点数目为
$$
\frac{N}{2^{n-1}}
$$
而每次访问跳表的时候，都从最高层的的指针开始遍历，所以可以快速地跳过很多结点，并且由于各个结点至少有一条链和其它结点产生关系，则也必然能够找到目标结点。

**代码：**原理极其明了简单，直接看代码

### 4.1 类代码：

``` c plus
// 注：这个数据结构中，如果 K 是 int 类型，则 0 不能作为有效的 key
namespace mSkipListMap
{
// 跳表结点模板
template<typename K, typename V>
class mSkipListNode
{
public:
    // 结点的 key
    K key;
    // 结点的 value
    V value;
    // 当前结点的后续结点们，vector 的索引代表对应的 level 高度，每个高度对应于当前高度上，结点的后继结点
    vector<mSkipListNode<K, V>*> nextNodes;

    mSkipListNode(const K& k, const V& v)
    {
        key = k;
        value = v;
    }

    // 用于判断当前结点的 key 是否比给定的 otherKey 小
    bool isKeyLess(const K& otherKey)
    {
        return otherKey != NULL && (key == NULL || key < otherKey);
    }
    // 用于判断当前结点的 key 是否和给定的 otherKey 相同
    bool isKeyEqual(const K& otherKey)
    {
        return otherKey != NULL && (key == NULL || key == otherKey);
    }
};

// 跳表模板
template<typename K, typename V>
class mSkipListMap
{
public:
    mSkipListMap()
    {
        // 将 key 和 value 都初始化为 NULL
        head = new mSkipListNode<K, V>(NULL, NULL);
        // 给 head 的 0 层的后继初始化为 NULL，防止越界
        head->nextNodes.push_back(NULL);
        size = 0;
        maxLevel = 0;
    }
    bool containsKey(const K& key)
    {
        if (key == NULL)
            return false;
        // 找出最大的且值比当前 key 小的结点
        mSkipListNode<K, V>* less = mostRightLessNodeInTree(key);
        // 拿到 less 结点的下一个结点，如果它的值和给定的 key 相同，则当前跳表包含目标 key
        mSkipListNode<K, V>* next = less->nextNodes[0];
        // 当然，如果下一个结点是 NULL，那么依然说明该跳表不包含目标 key
        return next != NULL && next->isKeyEqual(key);
    }
    // 插入一个结点
    void put(const K& key, const V& value)
    {
        if (key == NULL)
            return;
        // 同理，先找最大的小结点
        mSkipListNode<K, V>* less = mostRightLessNodeInTree(key);
        mSkipListNode<K, V>* find = less->nextNodes[0];
        // 如果要推入的 key 已经存在，则修改已存在结点的 value
        if (find != NULL && find->key == key)
            find->value = value;
        else
        {
            size++;
            int newNodeLevel = 0;
            while (RandDouble(0, 1, 1) < PROBABILITY)
                // 当随机出来的数字比我们设定的结点阈值小，则增加当前结点的高度
                // 当然，有可能掷出来的第一个数字就比给定的阈值大，则此时 level 为 0
                newNodeLevel++;
            while (newNodeLevel > maxLevel)
            {
                // 头结点必然是最高的结点
                head->nextNodes.push_back(NULL);
                maxLevel++;
            }
            // 创建新结点
            mSkipListNode<K, V>* newNode = new mSkipListNode<K, V>(key, value);
            for (int i = 0; i <= newNodeLevel; i++)
                // 将新结点的后继加到对应高度
                newNode->nextNodes.push_back(NULL);
            int level = maxLevel;
            mSkipListNode<K, V>* pre = head;
            while (level >= 0)
            {
                // 按 level 的高度，逐步将前驱结点的后继指针指向当前结点，并将当前结点的后继指向其前驱结点的后继
                pre = mostRightLessNodeInLevel(key, pre, level);
                if (level <= newNodeLevel)
                {
                    newNode->nextNodes[level] = pre->nextNodes[level];
                    pre->nextNodes[level] = newNode;
                }
                level--;
            }
        }
    }

    // 给定 key，返回对应的 value
    V get(const K& key)
    {
        if (key == NULL)
            return NULL;
        mSkipListNode<K, V>* less = mostRightLessNodeInTree(key);
        mSkipListNode<K, V>* next = less->nextNodes[0];
        return next != NULL && next->isKeyEqual(key) ? next->value : NULL;
    }

    void remove(const K& key)
    {
        // 如果能找到对应的 key，才进行删除操作
        if (containsKey(key))
        {
            size--;
            int level = maxLevel;
            mSkipListNode<K, V>* pre = head;
            while (level >= 0)
            {
                pre = mostRightLessNodeInLevel(key, pre, level);
                mSkipListNode<K, V>* next = pre->nextNodes[level];
                if (next != NULL && next->isKeyEqual(key))
                    // 由于下一个结点要删除点，所以将前一个结点的对应各个 level 上的指针指向待删除结点的后续结点
                    // 看图可以知道，只有当有前驱的结点指向当前待删除结点的情况，才考虑修改指针的指向
                    pre->nextNodes[level] = next->nextNodes[level];
                // 如果 pre 指向的是 head，并且在上一步删除结点之后，pre 指向的下一个结点是 NULL，说明该层已经不存在有效结点了，则直接删除该层
                if (level != 0 && pre == head && pre->nextNodes[level] == NULL)
                {
                    head->nextNodes.pop_back();
                    maxLevel--;
                }
                if (level == 0)
                    // 如果当前删除的是第 0 level，则需要释放对应的内存空间
                    delete next;
                level--;
            }
        }
    }
    K firstKey()
    {
        // 在有插入元素的情况下，则返回第一个元素的 key，否则返回 NULL
        return head->nextNodes[0] != NULL ? head->nextNodes[0].key : NULL;
    }

    K lastKey()
    {
        int level = maxLevel;
        mSkipListNode<K, V>* cur = head;
        while (level >= 0)
        {
            // 按层数的不同，每一次都达到某一层的最后一个不为 NULL 的结点，然后降低 level 继续查询
            // 以此来快速找到最后一个结点
            mSkipListNode<K, V>* next = cur->nextNodes[level];
            while (next != NULL)
            {
                cur = next;
                next = cur->nextNodes[level];
            }
            level--;
        }
        return cur->key;
    }

    // 查找比给定的 key 大的第一个结点
    K ceillingKey(const K& key)
    {
        if (key == NULL)
            return NULL;
        mSkipListNode<K, V>* less = mostRightLessNodeInTree(key);
        mSkipListNode<K, V>* next = less->nextNodes[0];
        return next != NULL ? next->key : NULL;
    }

    // 如果存储有和给定 key 相同的结点，返回对应的 key，否则返回比该 key 小且最接近给定 key 的 key
    K floorKey(const K& key)
    {
        if (key == NULL)
            return NULL;
        mSkipListNode<K, V>* less = mostRightLessNodeInTree(key);
        mSkipListNode<K, V>* next = less->nextNodes[0];
        return next != NULL && next->isKeyEqual(key) ? next->key : less->key;
    }

    int getSize()
    {
        return size;
    }

    // 找到比当前给定 key 小的元素的个数
    int lessElementNumber(const K& key)
    {
        // 直接从最底层开始找就行
        mSkipListNode<K, V>* cur = head->nextNodes[0];
        int number = 0;
        while (cur != NULL && cur->key < key)
        {
            cur = cur->nextNodes[0];
            number++;
        }
        return number;
    }

    string printElement(const K& key)
    {
        if (containsKey(key))
        {
            string str = string("<") + to_string(key) + string(", ") + to_string(get(key)) + ">";
            return str;
        }
        else
            return string("Not Find!");
    }

    void printSkipList()
    {
        for (int i = maxLevel; i >= 0; i--)
        {
            string tmpStr = "level " + to_string(i) + " : ";
            cout << setw(11) << setiosflags(ios::left) << tmpStr;
            mSkipListNode<K, V>* cur = head;
            int printedPosition = 0;
            while (cur->nextNodes[i] != NULL)
            {
                // 输出的是 next 指针指向结点的结果，所以 cur 可以从 head 开始
                mSkipListNode<K, V>* next = cur->nextNodes[i];
                // 先输出对应个数的空格
                int needPosition = lessElementNumber(next->key);
                int diffPosition = needPosition - printedPosition;
                while (diffPosition-- > 0)
                {
                    cout << setw(11) << setiosflags(ios::left) << " ";
                    printedPosition++;
                }
                string str = string("<") + to_string(next->key) + string(", ") + to_string(next->value) + ">";
                cout <<setw(11)<<setiosflags(ios::left)<< str;
                cur = next;
                printedPosition++;
            }
            // 输出了一层之后，输出换行符
            cout << endl;
        }
    }

private:
    // 插入结点时，产生更高结点的概率
    static double PROBABILITY;
    // 跳表的首结点
    mSkipListNode<K, V>* head;
    // 
    int size;
    // 最高的高度
    int maxLevel;
    // 找出整个跳表中，key 小于给定 key 的结点中，key 最大的那一个结点
    mSkipListNode<K, V>* mostRightLessNodeInTree(const K& key)
    {
        if (key == NULL)
            return NULL;
        // 从最高的高度开始依次找
        int level = maxLevel;
        mSkipListNode<K, V>* cur = head;
        while (level >= 0)
        {
            // 挨个找就行，直到找到最底层
            cur = mostRightLessNodeInLevel(key, cur, level--);
        }
        return cur;
    }
    // 找出树中某个高度 level 上，从给定结点 cur 开始，key 小于给定 key 的结点中，key 最大的那一个结点
    mSkipListNode<K, V>* mostRightLessNodeInLevel(const K& key, mSkipListNode<K, V>* cur, const int& level)
    {
        // 找出 cur 在 level 上的后续结点，其实直接读写作 cur->nextNodes[level]
        // 但是如果 cur 在 level 上没有后续，由于我们是从大到小依次找的，所以如果找不到后续，则当前结点已经是最后一个结点
        // 我的意思是，不会存在越界的情况，因为大高的结点只会指向大高的结点，不会说因为大高指向小高，而导致小高结点访问越界
        mSkipListNode<K, V>* next = cur->nextNodes[level];
        while (next != NULL && next->isKeyLess(key))
        {
            // 如果找出来的结点的 key 比给定 key 小，则继续往后找
            cur = next;
            next = cur->nextNodes[level];
        }
        // 值得注意的是，最后返回的是 cur
        return cur;
    }
};
template<typename K, typename V>
double mSkipListMap<K, V>::PROBABILITY = 0.5;
}

```

### 4.2 主函数：

``` c plus
void main()
{
    mSkipListMap::mSkipListMap<int, int> skipList;
	vector<int> arr_norepeat = RandVector_NoRepeat(1, 50, 15, 1);
    vector<int> arr = RandVector(1, 50, 15);
    for (int i = 0; i < 15; i++)
    {
        skipList.put(arr_norepeat[i], arr[i]);
    }
    skipList.printSkipList();
    cout << "Find the correponding element one by one:" << endl;
	for (int i = 1; i < 10; i++)
		cout << skipList.printElement(i) << ", ";
    cout << endl;
    while (skipList.getSize() != 0)
    {
        cout << "Please input the key to delete: ";
        int a;
        cin >> a;
        skipList.remove(a);
        system("cls");
        skipList.printSkipList();
    }
    system("pause");
}
```





# 树型DP

## 1. 问题引入

​		叉树节点间的最大距离问题从二叉树的节点 a 出发，可以向上或者向下走，但沿途的节点只能经过一次，到达节点 b 时路径上的节点个数叫作 a 到 b 的距离，那么二叉树任何两个节点之间都有距离，求整棵树上的最大距离。

**解题思路：**很明显，问题可以被分解为三类，对当前根来说

​		**（1）如果当前根不参与最大距离的查询，即路径不通过当前根，**那么此时最大距离要么是左树的最大距离，要么是右树上的最大距离；

​		**（2）如果当前根参与最大距离的查询，**那么此时最大距离明显为左树高 + 1 + 右树高。

那么明显，我们需要从子树上拿到的信息就是：**当前子树的最大距离**以及**当前子树的高。**

**代码：**

``` c plus
// 查询树的最长路径
// 信息结构体，通过分析需要从子树上拿的信息得到
struct Info_MaxDistance
{
    int height;
    int maxDistance;
    Info_MaxDistance(const int& hei, const int& maxDis) :height(hei), maxDistance(maxDis) {};
};

int MaxDistance(TNode*& const head)
{
    return Process_MaxDistance(head).maxDistance;
}

Info_MaxDistance Process_MaxDistance(TNode*& const head)
{
    if (head == NULL) return Info_MaxDistance(0, 0);
    Info_MaxDistance Info_Left = Process_MaxDistance(head->left);
    Info_MaxDistance Info_Right = Process_MaxDistance(head->right);
    // 对应三种情况
    int p1 = Info_Left.maxDistance;
    int p2 = Info_Right.maxDistance;
    int p3 = Info_Left.height + Info_Right.height + 1;
    return Info_MaxDistance(max(Info_Left.height, Info_Right.height) + 1, max(p1, max(p2, p3)));
}

// 销毁一棵树
void DestroyTree(TNode*& head)
{
    if (head == NULL) return;
    DestroyTree(head->left);
    DestroyTree(head->right);
    delete head;
    // 防止原指针为野指针，将其置空
    head = NULL;
}
void main()
{
    // 构造一棵树
    TNode* tNode = ConstructBST();
    cout << MaxDistance(tNode)<<endl;
    DestroyTree(tNode);
    system("pause");
}
```

## 2. 套路总结

**树形dp套路第一步：**以某个节点X为头节点的子树中，分析答案有哪些可能性，并且这种分析是以X左子树、X的右子树和整棵树的角度来考虑可能性的；

**树形dp套路第二步：**根据第一步的可能性分析，列出所有需要的信息；

**树形dp套路第三步：**合并第二步的信息，对左树和右树提出同样的要求，并写出信息结构；

**树形dp套路第四步：**设计递归函数，递归函数是处理以为头节点的情况下的答案，包括设计递归的**basecase**，默认直接得到左树和右树的所有信息，以及把可能性做整合，并且要返回第三步的信息结构这四个小步骤。

## 3. DP案例

### 3.1 派对的最大快乐值

**问题简述：**员工信息的定义如下：

``` c plus
classEmployee
{
    public:
    int happy; //这名员工可以带来的快乐值
	List<Employee>subOrdinates; //这名员工有哪些直接下级
}
```

​		公司的每个员工都符合Employee类的描述。整个公司的人员结构可以看作是一棵标准的、没有环的多叉树。树的头节点是公司唯一的老板。除老板之外的每个员工都有唯一的直接上级。叶节点是没有任何下属的基层员工（subOrdinates列表为空），除基层员工外，每个员工都有一个或多个直接下级。

​		这个公司现在要办party，你可以决定哪些员工来，哪些员工不来。但是要遵循如下规则。

1. 如果某个员工来了，那么这个员工的所有**<font color =red>直接下级</font>都不能来**；

2. 派对的整体快乐值是所有到场员工快乐值的累加；

3. 你的目标是让派对的整体快乐值尽量大；

给定一棵多叉树的头节点boss，请返回派对的最大快乐值。

**分析步骤：**以当前根来或不来为准进行分类：

（1）在当前根来的情况下，其直属的若干结点均不能来，此时当前树的最大快乐值为 结点本身的快乐值 + 各个结点不来的情况下，其子树的最大快乐值；

（2）在当前根不来的情况下，其指数的若干结点均可能来，此时当签署的最大快乐值为 0 + $\sigma$ max(各个结点来的情况下子树的最大快乐, 各个结点不来的情况下子树的最大快乐值)。

**代码：**

``` c plus
struct EmployeeTNode
	{
		EmployeeTNode(const int& hv) :happyValue(hv) {};
		// 相当于当前的树可能不是一个二叉树，它可能拥有多个孩子
		vector<EmployeeTNode*> subOrdinates;
		int happyValue;
	};
struct Info_MaxHappyValue
{
    // 结构体表示的是，当前结点来或不来的情况下，以当前结点为根的树的最大快乐值
    int comeMaxHappy;
    int notcomeMaxHappy;
    Info_MaxHappyValue(const int& com, const int& notcom) :comeMaxHappy(com), notcomeMaxHappy(notcom) {};
};
// 构建一棵树
EmployeeTNode* ConstructHappyTree()
{
    // 构造一棵搜索二叉树
    EmployeeTNode* head = new EmployeeTNode(5);
    // 第一层
    head->subOrdinates.push_back(new EmployeeTNode(30));
    head->subOrdinates.push_back(new EmployeeTNode(90));
    head->subOrdinates.push_back(new EmployeeTNode(80));
    // 第二层
    head->subOrdinates[0]->subOrdinates.push_back(new EmployeeTNode(20));
    head->subOrdinates[0]->subOrdinates.push_back(new EmployeeTNode(40));

    head->subOrdinates[1]->subOrdinates.push_back(new EmployeeTNode(40));

    head->subOrdinates[2]->subOrdinates.push_back(new EmployeeTNode(70));
    head->subOrdinates[2]->subOrdinates.push_back(new EmployeeTNode(200));
    head->subOrdinates[2]->subOrdinates.push_back(new EmployeeTNode(100));
    // 第三层
    head->subOrdinates[0]->subOrdinates[0]->subOrdinates.push_back(new EmployeeTNode(100));
    head->subOrdinates[0]->subOrdinates[0]->subOrdinates.push_back(new EmployeeTNode(200));
    head->subOrdinates[0]->subOrdinates[0]->subOrdinates.push_back(new EmployeeTNode(300));

    head->subOrdinates[0]->subOrdinates[1]->subOrdinates.push_back(new EmployeeTNode(300));
    head->subOrdinates[0]->subOrdinates[1]->subOrdinates.push_back(new EmployeeTNode(100));

    head->subOrdinates[1]->subOrdinates[0]->subOrdinates.push_back(new EmployeeTNode(200));
    head->subOrdinates[1]->subOrdinates[0]->subOrdinates.push_back(new EmployeeTNode(2000));
    head->subOrdinates[1]->subOrdinates[0]->subOrdinates.push_back(new EmployeeTNode(240));

    head->subOrdinates[2]->subOrdinates[0]->subOrdinates.push_back(new EmployeeTNode(1000));
    head->subOrdinates[2]->subOrdinates[0]->subOrdinates.push_back(new EmployeeTNode(200));
    head->subOrdinates[2]->subOrdinates[0]->subOrdinates.push_back(new EmployeeTNode(300));

    head->subOrdinates[2]->subOrdinates[1]->subOrdinates.push_back(new EmployeeTNode(20));
    head->subOrdinates[2]->subOrdinates[1]->subOrdinates.push_back(new EmployeeTNode(100));
    head->subOrdinates[2]->subOrdinates[1]->subOrdinates.push_back(new EmployeeTNode(2000));
    // 构造的是这样的树
    //                                                5
    //                           30                  90                            80
    //                      20          40           40                   70         200            100
    //			   [100 200 300]   [300  100]    [200 2000 240]   [1000 200 300 ]  [20 100 2000] 
    // 可以考虑
    // 30 + 90 + 100 + 600 + 400 + 2440 + 1500 + 2120 = 3660 + 3620 = 7280
    return head;
}

int MaxHappyValue(EmployeeTNode*& const head)
{
    Info_MaxHappyValue info = Process_MaxHappyValue(head);
    return max(info.comeMaxHappy, info.notcomeMaxHappy);
}

Info_MaxHappyValue Process_MaxHappyValue(EmployeeTNode*& const head)
{
    if (head->subOrdinates.empty())
        // 基层员工
        return Info_MaxHappyValue(head->happyValue, 0);
    // 根据总结出的规则
    int com = head->happyValue;
    int notcom = 0;
    for (auto &subOrdinate : head->subOrdinates)
    {
        // 因为当前结点来了，那它的孩子们必然来不了
        com += Process_MaxHappyValue(subOrdinate).notcomeMaxHappy;
        // 当前结点没来，那它的孩子可以选择来或者不来，取两者中能够使得快乐值最大的情况
        notcom += max(Process_MaxHappyValue(subOrdinate).comeMaxHappy, Process_MaxHappyValue(subOrdinate).notcomeMaxHappy);
    }
    return Info_MaxHappyValue(com, notcom);
}

void main()
{
    // 构造一棵树
    EmployeeTNode* tNode = ConstructHappyTree();
    cout << MaxHappyValue(tNode)<<endl;
    system("pause");
}
```



# 其它问题

## 1. 岛问题

### 1.1 基本问题

**[题目]**
一个矩阵中只有0和1两种值，每个位置都可以和自已的上、下、左、右四个位置相连，如果有一片1连在一起，这个部分叫做一个岛，求一个矩阵中有多少个岛?
**[举例]**
$$
\begin{matrix}
		0 & 0 & 1 & 0 & 1 & 0\\
		1 & 1 & 1 & 0 & 1 & 0\\
		1 & 0 & 0 & 1 & 0 & 0\\
		0 & 1 & 0 & 0 & 0 & 0\\
\end{matrix}
$$
​		这个矩阵中有三个岛。

**经典解法：**感染法，由于原矩阵中只有0和1，那么我们只要遍历到1，那就以这个点作为种子，将其相关的所有1都设置为2，之后就不会再检测到被设置为2的区域。那么进行了几次独立的感染，就有几个岛，还是很简单的方法。

``` c plus
// 问题3，查询岛问题
int CountIslands(MatrixXi& m)
{
    int M = m.rows(), N = m.cols();
    if (m.cols() == 0 || m.rows() == 0) return 0;
    int result = 0;
    for (int i = 0; i < M; i++)
        for (int j = 0; j < N; j++)
        {
            // 如果检测到有1出现，开始感染
            if (m(i, j) == 1)
            {
                result++;
                Infect(m, i, j, M, N);
            }
        }
    return result;
}
// 感染函数，M表示行数，N表示列数
void Infect(MatrixXi& m, const int& i, const int& j, const int& M, const int& N)
{
    // 如果访问越界，或者对应元素不为1，则直接返回，说明不必感染
    if (i < 0 || i >= M || j < 0 || j >= N || m(i, j) != 1)return;
    // 修改元素值
    m(i, j) = 2;
    // 感染周围所有的结点
    Infect(m, i + 1, j, M, N);
    Infect(m, i, j + 1, M, N);
    Infect(m, i - 1, j, M, N);
    Infect(m, i, j - 1, M, N);
}

void main()
{
	MatrixXi m = MatrixXi::Zero(4, 6);
	// 0 0 1 0 1 0
	// 1 1 1 0 1 0
	// 1 0 0 1 0 0
	// 0 1 0 0 0 0
    m << 0, 0, 1, 0, 1, 0,
         1, 1, 1, 0, 1, 0,
         1, 0, 0, 1, 0, 0,
         0, 1, 0, 0, 0, 0;
	cout << "The count of the island is: " << CountIslands(m) << endl;
	system("pause");
}
```

**注：**一个位置最多只会被调用4次（上下左右），所以不会增加问题规模，最终的时间复杂度为 $O(M*N)$。

### 1.2 并查集

**提供一些操作：**

**（1）IsSameSet：**查询两个元素是否处于一个集合；

**（2）Union：**将两个元素所在的集合进行合并。

经典结构无法实现上面两个操作同时达到较快的速度**（如链表和哈希表）**。

**实现方法：**

​		一个向上指的图结构。

**（1）查询过程，**只需不断往上找，如果最上面的代表元素是同一个，那么此时说两个集合是同一个集合；

**（2）合并过程，**直接将元素少的顶挂在元素多的顶下面。

**优化方法：**

​		每次在向上查询的过程中，都直接把当前结点的上指针指向头顶结点，把并查集扁平化。

​		我们写一个并查集的方法，可以使其适配于最小生成树算法：

``` c plus
// 真正的并查集实现，T表示数据类型
// T比较合适的数据类型是指针或者字符或字符串，T必须要不同才行，否则其被作为key插入的时候，仅仅能插入一条数据
template<class T>
class UnionFindSet
{
public:
    UnionFindSet(const list<T>& nodes)
    {
        // 用一个结点列表来初始化这个并查集
        for (auto& node : nodes)
        {
            // 初始状态下把自己的父亲初始化为自己，并给所有集合分配rank值为1
            elementSet.insert(node);
            fatherMap.insert(make_pair(node, node));
            rankMap.insert(make_pair(node, 1));
        }
    }
    // 找到头结点，并在这里面把数据链扁平化
    T FindHead(T& const node)
    {
        // 用于存储查找头结点过程中的中间结点
        stack<T> stk;
        T result = node;
        T tmpN = node;
        while (tmpN != fatherMap[tmpN])
        {
            // 当当前结点的父节点不等于其自身的时候，不停向上查询
            // 先把结点存进去
            stk.push(tmpN);
            tmpN = fatherMap[tmpN];
        }
        // 记录结果
        result = tmpN;
        while (!stk.empty())
        {
            tmpN = stk.top();
            stk.pop();
            fatherMap[tmpN] = result;
        }
        return result;
    }
    // 判断是否为同一个集合
    bool IsTheSameSet(T& const nodeA, T& const nodeB)
    {
        if ((elementSet.find(nodeA) != elementSet.end()) && (elementSet.find(nodeB) != elementSet.end()))
            // 在并查集确实存在这两个元素的情况下，才有可能返回真
            return FindHead(nodeA) == FindHead(nodeB);
        return false;
    }
    // 集合合并
    void Union(T& const nodeA, T& const nodeB)
    {
        if ((elementSet.find(nodeA) != elementSet.end()) && (elementSet.find(nodeB) != elementSet.end()))
        {
            // 在并查集确实存在这两个元素的情况下，才进行合并
            T FA = FindHead(nodeA);
            T FB = FindHead(nodeB);
            if (FA != FB)
            {
                // 在两者不为同一个集合的时候才进行合并
                // 划分出大集合和小集合
                T bigSet = rankMap[FA] > rankMap[FB] ? FA : FB;
                T smallSet = bigSet == FA ? FB : FA;
                // 把小集合连到大集合里面
                fatherMap[smallSet] = bigSet;
                rankMap[bigSet] = rankMap[bigSet] + rankMap[smallSet];
                // 删除小集合
                rankMap.erase(rankMap.find(smallSet));
            }
        }
    }
private:
    // 哈希表1，用于指示每一个元素结点对应的父结点
    unordered_map<T, T> fatherMap;
    // 哈希表2，用于指示每一个代表结点对应的集合拥有多少个结点
    unordered_map<T, int> rankMap;
    // 哈希表3，用于存放该并查集中可能用到的所有元素
    unordered_set<T> elementSet;
};

void main()
{
    // 构造一个数据矩阵
    auto matrix = ConstructMSTData();
    // 基于数据矩阵构造图
    auto graph = CreateUnorderedGraph(matrix);
    // 全程操作用指针实现，但是不修改指针指向空间的值
    list<mGraph::Node*> lisNodes;
    vector<mGraph::Node*> vecNodes;
    for_each(graph.nodes.begin(), graph.nodes.end(), [&](const pair<int, mGraph::Node*>& node) {
        lisNodes.push_back(node.second);
        vecNodes.push_back(node.second);
        });
    // 基于某个结点深度遍历无向图，结点1开始
    auto result_UnionFindSet = mGraph::KruskalMST_UnionFindSet(graph);
    auto result = mGraph::KruskalMST(graph);
    // 遍历结果，查看最小生成树结果
    cout << "The normal way to generate the MST: ";
    for_each(result.begin(), result.end(), [=](mGraph::Edge* edge) {
        cout << edge->weight << ", ";
        });
    cout << endl;
    cout << "The UnionFindSet way to generate the MST: ";
    for_each(result_UnionFindSet.begin(), result_UnionFindSet.end(), [=](mGraph::Edge* edge) {
        cout << edge->weight << ", ";
        });
    cout << endl;

    system("pause");
}
```

**注：在 FindHead 调用次数超过样本个数 N 时（调用比较频繁），就可以将其时间复杂度看作 $O(1)$。** 



### 1.3 进阶问题

​		如何设计一个并行算法解决这个问题。

**问题背景：**如果给了一个非常大的矩阵，就不太好搞，可以考虑用并行分片的方法来解决。

**两个CPU的情况：**

**多个CPU的情况：**

<img src="C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230330170604840.png" alt="image-20230330170604840" style="zoom: 80%;" />

**步骤1：**矩阵分区，如上图所示分成4份；

**步骤2：**分区统计岛的数目，此时得到岛的总数为5个，并在感染过程中，记录源种子（橙黄色）和各个区块边界上（与其他区块相接的部分）各个元素的源种子（红色）；

**步骤3：**将各个源种子初始化为并查集（很明显是用元素地址作为并查集的结点元素而非数值），如此问题中的初始集合为{A}{B}{C}{D}{E}；

**步骤4：**遍历边界结点，如果某个对应边界结点的周围有其它由源种子感染的结点，将两者对应的集合合并，每成功合并一次**（即两者本身并非同个集合）**，原统计的岛数目--。



## 2. KMP算法

**问题描述：**查找某个字符串是否是某个字符串的子字符串**（要求是连续的）**。

**暴力解法：**挨个配对，如果父字符串有 n 个字符，子字符串有 m 个字符，在最差情况，一共要进行 n*m 次字符匹配。

**关键概念：**对于一个字符串而言，除开自身整体，前缀和后缀相等的最大个数。

**next数组：**即对子字符串而言，其每一个字符之前的子子字符串的前缀和后缀相等的最大个数，比如有

| a    | a    | b    | a    | a    | a    | b    | c    | b    | b    | a    |
| :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: |
|-1|0|1|0|1|2|2|3|0|0|0|

<font color =red>**注：关于具体的证明可以看王卓的视频笔记。**</font>

``` c plus
// 问题2，KMP算法
// 暴力解法
int GetSubStringIndex_Brutal(const string& fatherString, const string& subString)
{
    // 筛掉一些特殊情况，下面两个判断
    if (fatherString.size() < subString.size()) return -1;
    if (subString.size() == 0) return -1;
    int i = 0, j = 0;
    int totalIndex = 0;
    while (i < fatherString.size() && j < subString.size())
    {
        if (fatherString[i] == subString[j])
        {
            i++;
            j++;
        }
        else
        {
            i = ++totalIndex;
            j = 0;
        }
    }
    return j == subString.size() ? i - j : -1;
}

// 找出父字符串中子字符串的位置
int GetSubStringIndex_KMP(const string& fatherString, const string& subString)
{
    // 筛掉一些特殊情况，下面两个判断
    if (fatherString.size() < subString.size()) return -1;
    if (subString.size() == 0) return -1;
    // 拿到next数组
    auto next = GetIndexArray(subString);
    int i = 0;
    int j = 0;
    while (i < fatherString.size() && j < subString.size())
    {
        if (fatherString[i] == subString[j])
        {
            // 此时ij均向后移动
            i++;
            j++;
        }
        else if (j != 0)
            // 就是说当前虽然子字符串的j位置失配，但是当前j不为0，则我们可以继续向前跳
            j = next[j];
        else
            // 说明此时实在找不到前后缀相同的位置可以继续和当前主字符串中的位置进行匹配了，则主字符串的指标向后移动
            i++;
    }
    // 如果j已经到了子字符串的终止位置，则说明成功匹配，返回i-j即可
    return j == subString.size() ? i - j : -1;
}

int GetSubStringIndex_ModifiedKMP(const string& fatherString, const string& subString)
{
    // 筛掉一些特殊情况，下面两个判断
    if (fatherString.size() < subString.size()) return -1;
    if (subString.size() == 0) return -1;
    // 拿到next数组
    auto next = GetModifiedIndexArray(subString, GetIndexArray(subString));
    int i = 0;
    int j = 0;
    while (i < fatherString.size() && j < subString.size())
    {
        if (fatherString[i] == subString[j])
        {
            // 此时ij均向后移动
            i++;
            j++;
        }
        else if (j != 0)
            // 就是说当前虽然子字符串的j位置失配，但是当前j不为0，则我们可以继续向前跳
            j = next[j];
        else
            // 说明此时实在找不到前后缀相同的位置可以继续和当前主字符串中的位置进行匹配了，则主字符串的指标向后移动
            i++;
    }
    // 如果j已经到了子字符串的终止位置，则说明成功匹配，返回i-j即可
    return j == subString.size() ? i - j : -1;
}

// 给定子字符串，找出其对应的next vector
vector<int> GetIndexArray(const string& subString)
{
    // 筛出仅1个字符的情况
    if (subString.size() == 1) return vector<int>{-1};
    vector<int> result(subString.size());
    // 前两个元素必然是-1和0
    result[0] = -1; result[1] = 0;
    // 我们知道，从i = 0开始到最后一个字符，我们都要求一个结果放在对应位置的数组中
    // 而我们假设来到i位置看i对应的next值，我们第一步是要看i-1上的字符和next[i-1]上的元素是否相同
    // 而现在我们相当于是从i = 2开始比较，而next[i]=0,所以我们设置初始的cn = 0
    int cn = 0;
    int i = 2;
    // 指标是i小于子字符串的长度，因为我们的目标是为每一个位置都分配一个next值
    while (i < subString.size())
    {
        if (subString[cn] == subString[i - 1])
        {
            // 如果 cn 位置的字符和 i - 1 位置的字符相同，则直接 i 位置字符对应的next值（同样也代表前后缀有多少个相同）就是 next[i-1]+1
            // 这里值得注意的是，cn 同时也表示了 i - 1 位置字符前后缀有几个相同的
            // 这里因为刚好，i位置的next值是i-1位置next+1，所以直接++cn，而此时的cn刚好又可以给下一个位置的元素用
            result[i++] = ++cn;
        }
        else if (cn > 0)
        {
            // 这里说明还能往前跳，这里的原理在于，在 上层子字符串中，前后缀相同
            // 那么我们在这部分相同的前缀中，如果能够找到前缀的前缀的后一个元素能和第 i - 1 位置的元素相同
            // 同样可以说明当前 i 位置上的前后缀一共有 当前 cn + 1 个元素相同
            cn = result[cn];
        }
        else
        {
            // 说明跳都没得跳的了，直接给0即可，说明得从第一个元素开始比
            result[i++] = 0;
        }
    }
    return result;
}
// 根据next vector和原子字符串subString优化next vector
vector<int> GetModifiedIndexArray(const string& subString, const vector<int>& nextArray)
{
    auto result = nextArray;
    // 进一步优化，主要是当我们往前找元素的时候，如果那个位置的元素和我们当前位置的元素本来就相同，那还有啥好比的
    // 肯定是和当前的比较结果一样，所以可以一开始就找到最往前与当前 i 位置元素不同的元素，把这个位置塞到next vector中
    // i从2开始，可以避免边界产生问题
    for (int i = 2; i < result.size(); i++)
    {
        // 取当前字符和下一个字符的位置
        int chr = subString[i];
        int next = result[i];
        // next为0的时候也要跳出循环，否则会读到一个-1，此时索引出错
        while (chr == subString[next] && next != 0)
        {
            // 沿着next一直找下去，直到当前字符和next位置上的字符是不相同的，然后记录当前i位置的next值为对应的找到的next值
            chr = subString[next];
            next = result[next];
        }
        result[i] = next;
    }
    return result;
}

void main()
{
    string fatherString = RandString('a', 'c', 100000, true);
    string subString = RandString('a', 'c', 5, true);
    // 暴力法
    float start = clock();
    int pos_Brutal = GetSubStringIndex_Brutal(fatherString, subString);
    float end = clock();
    float time_Brutal = end - start;

    // KMP法
    start = clock();
    int pos_KMP = GetSubStringIndex_KMP(fatherString, subString);
    end = clock();
    float time_KMP = end - start;

    // 改进KMP法
    start = clock();
    int pos_ModifiedKMP = GetSubStringIndex_ModifiedKMP(fatherString, subString);
    end = clock();
    float time_ModifiedKMP = end - start;

    cout << "暴力法：" << pos_Brutal <<"，消耗时间："<<time_Brutal<<endl;
    cout << "KMP法：" << pos_KMP << "，消耗时间：" << time_KMP << endl;
    cout << "改进KMP法：" << pos_ModifiedKMP << "，消耗时间：" << time_ModifiedKMP << endl;

    system("pause");
}
```

**某个输出结果：**

![image-20230330214511374](C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230330214511374.png)

**复杂度估计：**

**（1）主代码块**

``` c plus
while (i < fatherString.size() && j < subString.size())
{
    if (fatherString[i] == subString[j])
    {
        i++;
        j++;
    }
    else if (j != 0)
        j = next[j];
    else
        i++;
}
```

​		**容易看出此时的两个变量 i 和 j，可以创建两个变量：i 以及 i - j**，可以发现，这两个变量的范围都是 0 ~ N，N 是主字符串的长度。而这两个变量在上述的循环中单调递增，那么最大最大也就只能迭代 2N 次，故时间复杂度为 $O(N)$。

**（2）求next数组**

``` c plus
while (i < subString.size())
{
    if (subString[cn] == subString[i - 1])
        result[i++] = ++cn;
    else if (cn > 0)
        cn = result[cn];
    else
        result[i++] = 0;
}
```

​		**容易看出此时的两个变量 cn 和 i，可以创建两个变量：i 以及 i - cn**，可以发现，这两个变量的范围都是 0 ~ M，M 是子字符串的长度。而这两个变量在上述的循环中单调递增，那么最大最大也就只能迭代 2M 次，故时间复杂度为 $O(M)$。

​		**综合来看，最终的时间复杂度为 $O(N)$。**



## 3. Manacher算法

### 3.1 最长回文子串问题

#### **暴力解法：**

​		给所有字符中间插入一个特殊字符，如 #**（可以是原串中出现过的问题）**，然后遍历整个字符串**（否则找不出偶数字符的回文）**，对每一个字符串，沿双边扩张，对比扩张时候扫过的元素是否相同，并输出最大扩张的长度。对得到的长度，再整型除以2得到的结果就是回文的长度。

**时间复杂度：**$O(N^2)$。

#### **Manacher解法：**

**基本概念：**

​		**回文半径**和**回文直径**，如下表所示是其对应的**回文半径数组**。
|  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  a   |  #   |  b   |  #   |  c   |  #   |  b   |  #   |  a   |
|  1   |  1   |  2   |  1   |  9   |  1   |  2   |  1   |  1   |

​		**回文右边界 R**，如下列表，其表示的是扩展到对应位置的时候，回文右边界 R 的更新情况（在扫掠字符串之前初始化为-1）。
|  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  a   |  #   |  b   |  #   |  c   |  #   |  b   |  #   |  a   |
|  0   |  1   |  3   |  3   |  8   |  8   |  8   |  8   |  8   |

​		**确定回文右边界的时候，取的中心点 C 在哪儿**，同理，对应变量 C 的更新情况如下标所示

|  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  a   |  #   |  b   |  #   |  c   |  #   |  b   |  #   |  a   |
|  0   |  1   |  2   |  2   |  4   |  4   |  4   |  4   |  4   |

**注：之后代码实现的时候，往原字符串的左边和最右边也加了一个特殊字符。**

**算法步骤：**

**规则1：**在查询过程中，如果当前位置不处于回文有边界内，则直接暴力查询当前位置的回文情况；

**规则2：**在查询过程中，如果当前位置在回文右边界中，此时的对应点关系如下**（i位置可能和R位置重合）**：

<img src="C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230331151253045.png" alt="image-20230331151253045" style="zoom:80%;" />

​		**规则2.1：**如果 i' 位置上形成的回文区域完全在以 (C, R) 形成的回文范围内**（不包含压线情况）**，这是显然的（应该是去查看 i' 位置的回文情况，然后确定当前位置的回文情况）；

​		**规则2.2：**如果 i' 位置形成的回文区域已经右部分在以 (C, R) 形成的回文范围外了，此时 i 位置和 i' 位置只有部分回文相同，并且**此时 i 位置的回文半径必然是 (R-i+1)**，即其对应的回文区域仅从其本身位置 i 扩充到当前的回文有边界 R，绝不会超出 R，这个结论直观上是很容易理解的；

**注：规则2.1和2.2的一个很大的区别在于，对于规则2.1来说，其作对称轴得到的 i'，其和 i 的回文区域必然相同，但是规则2.2下却不一定，并且 i 和 i’ 的回文范围有大有小。**

​		**规则2.3：**如果 i' 位置形成的回文区域刚好压线，即其左边界刚好是 C 回文区域的左边界，那么此时 i 位置的回文区域的回文半径大于等于 (R-i+1)，即有可能超出以 (C, R)形成的回文范围，**其和规则2.2其实是对称的关系。**

**注：规则2.1中，不用验证回文的半径为 i’ 位置的回文半径（如果仅自身形成回文，则回文半径为1），这个回文半径比 (R-C+1)小；而对规则2.2和规则2.3，不用验证回文的半径都为 (R-C+1)，此时这个值小于等于 i' 位置的回文半径。**

**时间复杂度：**由于在整个过程中，i 不管进入哪个循环，其总是变大，当然，在某一步 i 中，R 的扩张有可能会产生多次操作，但是由于 R 不会回退，不会重新赋值，且其最大也就是字符串的长度，故最终的时间复杂度必然是 $O(N)$。

``` c plus
// 问题3，最长回文问题
// 将原始字符串补充为带特殊分隔符号的完整字符串
string ManacherString(const string& oriStr)
{
    string result;
    int index = 0;
    for (int i = 0; i < 2 * oriStr.size() + 1; i++)
        // 补充完之后的字符串长度为 2 i + 1
        result.push_back(i % 2 == 0 ? '#' : oriStr[index++]);
    return result;
}

// 注，上面的表达式也可以写成
string ManacherString(const string& oriStr)
	{
		string result;
		int index = 0;
		for (int i = 0; i < oriStr.size() * 2 + 1; i++)
		{
            // 注意，这里的括号很关键，一定要把 (i & 1)括起来，不然运算顺序是错误的
            // 另外(i & 1) == 0表示当前的 i 是一个偶数
			result.push_back((i & 1) == 0 ? '#': oriStr[index++]);
		}
		return result;
	}

// 求出一个字符串的最大回文长度
int MaxLcpsLength(const string& oriStr)
{
    if (oriStr.size() == 0)return 0;
    string manaStr = ManacherString(oriStr);
    // S这里表示最右回文边界再往右走一步，这样的好处是方便判断回文半径，因为在其中一种情况下的回文半径理论表达式为 R = S - i + 1
    // 那么此时回文半径可以直接写为 R = S - i
    int S = -1;
    int C = -1;
    // 数组用于表示对应位置的字符对应的回文半径
    vector<int> RArr(manaStr.size());
    // 最长回文长度
    int maxR = INT_MIN;
    for (int i = 0; i < manaStr.size(); i++)
    {
        // 值得注意的是，该算法每一步都必然有 i 增量
        // 这里求出来的是不用进行判断是否是回文的范围，比如对 i 比回文右边界大的情况，此时仅自身不用回文判断
        // 规则2.2和2.3其实对这一步来说是等价的，只不过规则2.2下，在后续扩张查找的时候会直接break掉
        // 并且，刚好这里 RArr[i] 用于表示当前 i 位置的回文半径，可以直接赋值
        // 另外，如果 i 位置刚好踩在回文区域的边界上，此时 i 位置的回文半径必然为1，很容易想
        RArr[i] = (i >= S) ? 1 : min(S - i, RArr[2 * C - i]);
        // 下面这个循环找出的是 i 位置上的最大回文半径
        while (i - RArr[i] > -1 && i + RArr[i] < manaStr.size())
        {
            if (manaStr[i - RArr[i]] == manaStr[i + RArr[i]])
            {
                RArr[i]++;
            }
            else
                break;	
        }
        // 上一个循环设置好了 i 位置的回文半径，此时我们就可以来看当前有没有进一步扩张最右回文边界
        if (i + RArr[i] > S)
        {
            // 大概想一下就知道，直接用 i + 回文半径，得到的是回文区域往后走一步
            S = i + RArr[i];
            C = i;
        }
        maxR = max(maxR, RArr[i]);
    }
    // 用扩充字符串找到的最大回文半径减去 1 得到的就是原字符串的最大回文长度
    return maxR - 1;
}

void main()
{
    // 以下字符串的最长回文为 abcdefgfedcba，长度为13
    string LcpStr("amwkemqlksmdabcdcbaasdojioqwabcdefgfedcbadfkgcopvkb");
    cout << "The length of the longest Lcps is: " << MaxLcpsLength(LcpStr) << endl;
    system("pause");
}

```



## 4. 窗口最大值问题

由一个代表题目，引出一种结构

**[题目]**

有一个整型数组 arr 和一个大小为 w 的窗口从数组的最左边滑到最右边，窗口每次向右边滑一个位置。
例如，数组为[4, 3, 5, 4, 3, 3, 6, 7]，窗口大小为 3 时：

​		[4 3 5] 4 3 3 6 7

​		4 [3 5 4] 3 3 6 7

​		4 3 [5 4 3] 3 6 7

​		4 3 5 [4 3 3] 6 7

​		4 3 5 4 [3 3 6] 7

​		4 3 5 4 3 [3 6 7]

​		窗口中最大值为5、窗口中最大值为5、窗口中最大值为5、窗口中最大值为4、窗口中最大值为6、窗口中最大值为7，如果数组长度为 n，窗口大小为 w，则一共产生 (n-w+1) 个窗口的最大值。请实现一个函数

**输入：**整型数组 arr，窗口大小为 w。

**输出：**一个长度为 (n-w+1) 的数组 res，res[i] 表示每一种窗口状态下的以本题为例，结果应该返回 [5, 5, 5, 4, 6, 7]。

**解题思路：**拓展窗口，不要求窗口大小固定，只要求窗口的左端界限小于等于右端界限。

**结构和规则：**结构本身是一个双端队列

​		**规则1：**队列右边界扩张时，当新扩张元素比队尾元素小时**（等于的时候也不能直接推入元素）**，直接推入元素，否则从队尾弹出元素，直到新扩展元素小于队尾元素（即保证队列始终单调递减）；

​		**规则2：**队列左边界向右收缩时，判断队首元素是否是当前双端队列最大元素，如果是，则从队首出队，否则不做任何操作**（因为有可能已经在规则1中从队尾出队，此时我们说这个下标是过期的）**；

​		**规则3：**左右边界均只能向右移动，不能回退。

**注：则该双端队列实际上维护的是窗口收缩过程中，窗口中可能成为当前窗口最大值的所有元素，并且从左往右是最大值的优先度，所以当从右扩张得到新元素的时候，如果该新元素比队列中的所有元素都大，那么扩张之后，原本队列的元素不再可能成为最大元素，则全部弹出，<font color = red>有一个值得思考的问题在于新元素和队尾元素相同的情况，其实就算我们在等于的时候也认作是可直接推入元素的情况，应该也是逻辑上可行的。</font>**

**实现方法1——类单独实现：**

``` c plus
// 两种方式来解决，第一种，我们通过创建这样一种数据结构来搞
class MaxValueDeque
{
public:
    // 返回两个迭代器，方便访问
    deque<pair<int, int>>::const_iterator MaxValueDeque::begin() const
    {
        return m_Data.begin();
    }
    deque<pair<int, int>>::const_iterator MaxValueDeque::end() const
    {
        return m_Data.end();
    }
    // 右边界扩张
    void MaxValueDeque::push_back(const pair<int, int>& value)
    {
        RIndex++;
        // 先把数组准备好，之后再插入
        while (!m_Data.empty())
        {
            if (m_Data.rbegin()->second < value.second)
                // 如果队尾元素比较小，则一直推出队尾元素
                m_Data.pop_back();
            else
                break;
        }
        // 此时要么队列空了，要么队尾元素比要推入的元素大了
        m_Data.push_back(value);
    }
 	// 左边界收缩
	void MaxValueDeque::pop_front()
	{
		// 窗口的大小仅靠 L 和 R 来维护
		if (LIndex >= RIndex) return;
		// 如果队里面已经空了，不能再收缩，但不能直接返回，此时依然要操控 LIndex++
		if (m_Data.empty()) {}
		else
		{
			int result = 0;
			if (LIndex != m_Data.begin()->first) {}
			// 说明当前元素已经被弹出了，不要做任何操作
			else
			{
				result = m_Data.front().second;
				// 否则把当前对首元素扔了
				m_Data.pop_front();
			}
			// 操作完毕之后再修改 L，因为它其实对应了当前窗口的左边界
		}
		LIndex++;
		return;
	}
    void MaxValueDeque::show()
    {
        for (int i = 0; i < m_Data.size(); i++)
        {
            cout << m_Data[i].second << ", ";
        }
        cout << endl;
    }
private:
    deque<pair<int, int>> m_Data;
    int LIndex = 0;
    int RIndex = 0;
};

// 可以指定窗口大小
vector<int> SlidingWindowMaxArray(const vector<int>& arr, const int& windowSize)
{
    MaxValueDeque mvd;
    vector<int> result;
    for (int i = 0; i < arr.size(); i++)
    {
        // 这里循环应该要在整个arr上面进行的，傻逼
        if (i < windowSize - 1)
            mvd.push_back(make_pair(i, arr[i]));
        else if (i == windowSize - 1)
        {
            mvd.push_back(make_pair(i, arr[i]));
            result.push_back(mvd.begin()->second);
        }
        else
        {
            mvd.push_back(make_pair(i, arr[i]));
            mvd.pop_front();
            // 直接推入双头队列的队首元素即可
            result.push_back(mvd.begin()->second);
        }
        mvd.show();
    }
    return result;
}
```

**实现方法2——函数中直接处理**

``` c plus
vector<int> SlidingWindowMaxArray_Direct(const vector<int>& arr, const int& windowSize)
{
    if (arr.empty() || windowSize < 1 || arr.size() < windowSize) throw string("Error for SlidingWindowMaxArray_Direct!");
    vector<int> result(arr.size() - windowSize + 1);
    // 值得注意的是，由于直接在函数中进行操作的时候，可以通过下标直接访问原本的数组 arr，所以此时我们 deque 存的是下标信息
    // 所以，也要注意，涉及到具体数值比较的时候，一定要用 arr[i]，不要忘了
    deque<int> qMax;
    for (int i = 0; i < arr.size(); i++)
    {
        // 这个时候问题就稍微局限一点，在一个循环中，必然同时伸展和收缩窗口，即要求窗口的尺寸固定
        // 伸展窗口，因为要求存在于 deque 中的元素是严格递减，所以等于的情况也要弹出
        while (!qMax.empty() && arr[qMax.back()] <= arr[i])
            qMax.pop_back();
        qMax.push_back(i);
        // 收缩窗口，其实 i - windowSize 就是窗口在自动滑动了
        if (qMax.front() == i - windowSize)
            // 满足这个关系的时候才真的推出元素，很好的一个方法，不仅达到逻辑需求，还过滤了初始先要形成一定尺寸窗口的情况
            qMax.pop_front();
        if (i >= windowSize - 1)
            // 这种情况下推入 qMax 的队首元素
            result[i - windowSize + 1] = (arr[*qMax.begin()]);
    }
    return result;
}

void main()
{
	vector<int> arr{ 4,3,5,4,3,3,6,7 };
	vector<int> result = SlidingWindowMaxArray(arr, 3);
	for_each(result.begin(), result.end(), [&](const int& num) {
		cout << num << ", ";
		});
	cout << endl;
	result = SlidingWindowMaxArray_Direct(arr, 3);
	for_each(result.begin(), result.end(), [&](const int& num) {
		cout << num << ", ";
		});
	cout << endl;

	system("pause");
}
```

**注：该方法的时间复杂度明显是 $O(N)$ ，仅有一个地方值得考虑，在于 qMax 数组中，在推入数字的时候可能会多次弹出数字，但是由于原数组中的所有元素只可能进入 qMax 一次，不会重复进入，而同时窗口也仅单调扫掠过原数组一次，则可以确定其时间复杂度。**



## 5. 单调栈结构

### 5.1 定义

**问题简述：**找出一个数组中，每个元素左边和右边比它大的且离它最近的元素的位置。

**原理简述：**

​		**规则1：**始终保证栈从栈底到栈顶单调递减；

​		**规则2：**当压入元素的时候，判断当前元素是否比栈顶元素小，如果是，直接压入，如果不是，得到栈顶元素信息：其压住的元素是其左边比它大的最近元素，当前即将压入的元素是右边比它大的第一个元素，重复规则2，直到当前元素可以被压入栈；

​		**规则3：**在没有元素可以压入的时候，弹出元素，在弹出前的栈顶元素，其右边没有元素比它大**（清算截断弹出的所有元素必然右边没有比它们大的元素）**，左边比它大的元素是其压住的元素；

**注：如果一个元素弹出的时候，其处于栈底，则其左边没有任何元素比它大。另外，对于数值大小相同的情况，可以通过链表或者其它数据结构把它们压在一起，之后再有进出的时候它们作为整体进行处理，或者直接压入元素，然后释放的时候进行多次判断即可。**

**同理，也可以考虑找到左边和右边比他小的且离它最近的元素的位置，即保证单调栈中始终保持栈底到栈顶的单调递增。**

``` c plus
// 暴力法解决元素左右最近小元素问题
vector<vector<int>> GetNearLess_Brutal(const vector<int>& arr)
{
    // 先全部元素初始化为0
    vector<vector<int>> result(arr.size(), vector<int>(2, 0));
    for (int i = 0; i < arr.size(); i++)
    {
        // 先找左边的
        int curIndex = i - 1;
        // 等号的数字不要取，我们是找到严格小于当前位置值的位置
        while (curIndex > -1 && arr[curIndex] >= arr[i])
            curIndex--;
        // 如果左边没有任何元素比当前元素小，则最终 curIndex 走到 -1
        result[i][0] = curIndex;
        // 然后找右边的
        curIndex = i + 1;
        while (curIndex < arr.size() && arr[curIndex] >= arr[i])
            curIndex++;
        // 如果右边没有任何元素比当前元素小，则走到 arr.size()，但我们最终取的是-1
        result[i][1] = curIndex == arr.size() ? -1 : curIndex;
    }
    return result;
}

// 单调栈解决元素左右最近小元素问题，数组中无重复数问题
vector<vector<int>> GetNearLess_NoRepeat(const vector<int>& arr)
{
    // 注：栈中的数据是索引而非具体的数值
    vector<vector<int>> result(arr.size(), vector<int>(2, 0));
    stack<int> stk;
    for (int i = 0; i < result.size(); i++)
    {
        // 有一个很不错的思路就是先把栈准备好，然后推入数据
        while (!stk.empty() && arr[stk.top()] > arr[i])
        {
            // 说明现在直接推入元素无法保证栈的栈底到栈顶单调递增性，则需要一直推出元素
            // 在推出元素的时候，我们就可以对推出的元素设置其对应的最近左右小元素
            int popIndex = stk.top();
            stk.pop();
            // 如果当前栈已经空了，则左边没有比弹出元素更小的元素，则左小元素索引置为 -1
            result[popIndex][0] = stk.empty() ? -1 : stk.top();
            result[popIndex][1] = i;
        }
        stk.push(i);
    }
    // 清算阶段
    while (!stk.empty())
    {
        // 弹出一个元素
        int popIndex = stk.top();
        stk.pop();
        result[popIndex][0] = stk.empty() ? -1 : stk.top();
        // 清算阶段弹出的元素必然右边没有元素比它小
        result[popIndex][1] = -1;
    }
    return result;
}

// 单调栈解决元素左右最近小元素问题，数组中有重复数问题
vector<vector<int>> GetNearLess(const vector<int>& arr)
{
    vector<vector<int>> result(arr.size(), vector<int>(2, 0));
    // 元素为双头队列的单调栈
    stack<deque<int>> stk;
    for (int i = 0; i < arr.size(); i++)
    {
        // stk.top().front()表示单调栈顶双头队列中的队首元素的下标
        while (!stk.empty() && arr[stk.top().front()] > arr[i])
        {
            // 现在要对栈中的一个元素（双头队列）进行循环赋值
            auto popIndexes = stk.top();
            stk.pop();
            // 因为是要求最近的那一个元素，所以对左边的双头队列，应该取最后一个元素，有点东西
            int leftLessIndex = stk.empty() ? -1 : stk.top().back();
            for (int j = 0; j < popIndexes.size(); j++)
            {
                // 有可能在当前执行弹出操作之后，栈为空
                result[popIndexes[j]][0] = leftLessIndex;
                result[popIndexes[j]][1] = i;
            }
        }
        // 将所有比 arr[i] 大的元素弹出之后，现在留在栈顶的元素有可能是等于当前元素的
        if (!stk.empty() && arr[stk.top().front()] == arr[i])
            stk.top().push_back(i);
        else
            // 此时说明要么当前栈为空，或者栈顶元素比当前元素小，则需要新创建一个双头队列
            stk.push(deque<int>{i});
    }
    // 清算阶段
    while (!stk.empty())
    {
        auto popIndexes = stk.top();
        stk.pop();
        int leftLessIndex = stk.empty() ? -1 : stk.top().back();
        for (int j = 0; j < popIndexes.size(); j++)
        {
            result[popIndexes[j]][0] = leftLessIndex;
            result[popIndexes[j]][1] = -1;
        }
    }
    return result;
}

void main()
{
	// ===== 无重复数的单调栈方法测试 ===== //
	vector<int> arr_NoRepeat = RandVector_NoRepeat(0, 1000, 500);
	// 暴力法
	auto result_Brutal_NoRepeat = GetNearLess_Brutal(arr_NoRepeat);
	// 单调栈法
	auto result_MonotonousStack_NoRepeat = GetNearLess_NoRepeat(arr_NoRepeat);
	cout << "The result got by two ways are (No Repeat): " \
		<< (IsMatrixTheSame(result_Brutal_NoRepeat, result_MonotonousStack_NoRepeat) ? "the same!" : ("not the same!")) << endl;
		
	// ===== 有重复数的单调栈方法测试 ===== //
	vector<int> arr = RandVector(0, 1000, 500, true);
	// 暴力法
	auto result_Brutal = GetNearLess_Brutal(arr);
	// 单调栈法
	auto result_MonotonousStack = GetNearLess(arr);
	cout << "The result got by two ways are: " \
		<< (IsMatrixTheSame(result_Brutal, result_MonotonousStack) ? "the same!" : ("not the same!")) << endl;

	system("pause");
}
```



### 5.2 应用

**定义：**数组中累积和与最小值的乘积，假设叫做指标A。给定一个数组，请返回子数组中，指标A最大的值**（数组的元素均为正数）**。

其实很简单，利用单调栈，我们只需要找到以每一个元素为最小值的若干子数组（找到左边和右边第一个比它小的数），并拿到它们对应的指标最大值，然后再找到全局的最大指标即可。

**复杂度分析：**因为单调栈的复杂度为 $O(N)$，不过不能保证后续的求和过程复杂度也是这么多，用前缀和数组可以将求任意两个索引之间的数组和的时间复杂度降低到 $O(1)$，则可以保住最终的时间复杂度为 $O(N)$，想想暴力法的时间复杂度为 $O(N!)$，感觉这东西特别屌。

``` c plus
// 暴力法解决最大指标 A 问题
int GetMaxA_Brutal(const vector<int>& arr)
{
    int maxValue = INT_MIN;
    // 遍历所有可能出现的子数组，然后统计对应的指标
    for (int i = 0; i < arr.size(); i++)
    {
        // 为什么取等号，要自己想一下，特殊情况一想就直到
        for (int j = 1; i + j <= arr.size(); j++)
        {
            // 这里的 j 表示子数组的长度
            maxValue = max(GetA_SubArray(arr, i, j), maxValue);
        }
    }
    return maxValue;
}

int GetMaxA_Monotonous(const vector<int>& arr)
{
    // 先得到每个数左右两边离它最近的小元素索引
    auto nearLessMatrix = GetNearLess(arr);
    int maxValue = INT_MIN;
    for (int i = 0; i < arr.size(); i++)
    {
        int sum = 0;
        // 有一个小问题在于，如果右边界是-1，此时要扩张到最后一个元素
        for (int j = nearLessMatrix[i][0] + 1; j < (nearLessMatrix[i][1] == -1 ? arr.size() : nearLessMatrix[i][1]); j++)
            sum += arr[j];
        // 取大值作为我们需要的指标
        maxValue = max(maxValue, sum * arr[i]);
    }
    return maxValue;
}

int GetMaxA_Monotonous_PreSum(const vector<int>& arr)
{
    vector<int> preSum(arr.size(), 0);
    // 先构造前缀和数组，时间复杂度为 O(n)
    for (int i = 0; i < preSum.size(); i++)
        preSum[i] = (i == 0) ? arr[i] : (preSum[i - 1] + arr[i]);
    // 后续过程和之前一样
    auto nearLessMatrix = GetNearLess(arr);
    int maxValue = INT_MIN;
    for (int i = 0; i < arr.size(); i++)
    {
        // 注：前缀和数组中 preSum[i] - preSum[j] 表示的是原数组从 j + 1 到 i 的累加和
        // 这样刚好，因为我们的左右小值数组中的索引位置的值本身就不能被算在内
        int rightValue = nearLessMatrix[i][1] == -1 ? preSum[arr.size() - 1] : preSum[nearLessMatrix[i][1] - 1];
        int leftValue = nearLessMatrix[i][0] == -1 ? 0 : preSum[nearLessMatrix[i][0]];
        int sum = rightValue - leftValue;
        // 取大值作为我们需要的指标
        maxValue = max(maxValue, sum * arr[i]);
    }
    return maxValue;
}

void main()
{
    // ===== 无重复数的单调栈方法测试 ===== //
    vector<int> arr = RandVector(0, 1000, 4000);
    // 暴力法求解
    int start = clock();
    cout << "The max A(Brutal) is: " << GetMaxA_Brutal(arr) << endl;
    int end = clock();
    cout << "The time cost is: " << end - start << endl;
    // 单调栈求解
    start = clock();
    cout << "The max A(Monotonous) is: " << GetMaxA_Monotonous(arr) << endl;
    end = clock();
    cout << "The time cost is: " << end - start << endl;
    // 前缀和数组加速求解
    start = clock();
    cout << "The max A(PreSum) is: " << GetMaxA_Monotonous_PreSum(arr) << endl;
    end = clock();
    cout << "The time cost is: " << end - start << endl;
    system("pause");
}
```

**输出结果：**

![image-20230401154759698](C:\Users\Zz\AppData\Roaming\Typora\typora-user-images\image-20230401154759698.png)



## 6. Morris遍历（线索二叉树）

### 6.1 问题简述

​		一种遍历二叉树的方式，并且时间复杂度 $O(N)$，**额外空间复杂度 $O(1)$**。通过利用原树中大量空闲指针的方式，达到节省空间的自的。

### 6.2 实现细节

​		假设来到当前节点cur，开始时cur来到头节点位置

**1）如果cur没有左孩子，**cur向右移动 (cur=cur.right)；

**2）如果cur有左孩子，**找到左子树上最右的节点 mostRight：

​		a. 如果mostRight的右指针指向空，让其指向cur然后cur向左移动 (cur=cur.left)；

​		b. 如果mostRight的右指针指向cur，让其指向null然后cur向右移动 (cur= cur.right)；

3）cur为空时遍历停止。

**注：**

1）如果要求始终不能修改树的任何指针的话，Morris遍历是用不了的；

2）起始只有一种情况下会往左移动，即当前结点有左子树并且是第一次到达当前结点的情况**（即其左子树的最右结点的右指针为空）**；

3）Morris遍历中，有左树的结点会被遍历两次，但没有左树的结点仅会被遍历一次**（要知道，一般方法中，一个结点会被遍历三次）**；

4）如果需要在第三次遍历到某个结点的时候做数据整合，就可以采用Morris遍历作为最优解，否则只能用DP套路求解。

``` c plus
// 3. Morris遍历
void MorrisForeach(TNode*& const head)
{
    if (head = NULL) return;
    // 表示当前访问到的结点
    TNode* cur = head;
    // 表示左子树上的最右结点
    TNode* mostRight = NULL;
    while (cur != NULL)
    {
        // 首要目标是找出当前结点 cur 的左子树上的最右结点
        mostRight = head->left;
        if (mostRight != NULL)
        {
            // 如果当前结点 cur 有左孩子，那么就要找其对应的最右结点
            // 值得注意的是，其左子树最右结点有可能指向其自身（说明已经是第二次访问cur）
            while (mostRight->right != NULL && mostRight->right != cur)
                mostRight = mostRight->right;
            // 找到最右结点了
            if (mostRight->right == NULL)
            {
                // 第一次访问，唯一向左移动的情况
                // 先把左子树最右结点指向自身，然后再移动当前结点
                mostRight->right = cur;
                cur = cur->left;
                continue;
            }
            else
                // 第二次访问，直接把左子树最右结点置空即可
                mostRight->right = NULL;
        }
        // 有两种情况会往右跳，所以单独写在这里
        // 即当前结点没有左子树以及第二次访问到 cur 的情况
        cur = cur->right;
    }
}
```

### 6.3 其它问题

#### 6.3.1 Morris遍历实现前序遍历

**方法：**对于有左子树的结点，其必然被遍历两遍，在第一次经过它的时候进行操作；对于没有左子树的结点，其只被经过一遍，经过它的时候进行操作。

``` c plus
// Morris前序遍历
void MorrisPreForeach(TNode*& const head)
{
    if (head == NULL) return;
    TNode* cur = head;
    TNode* mostRight = NULL;
    while (cur != NULL)
    {
        mostRight = cur->left;
        if (mostRight != NULL)
        {
            while (mostRight->right != NULL && mostRight->right != cur)
                mostRight = mostRight->right;
            if (mostRight->right == NULL)
            {
                cout << cur->data << ", ";
                mostRight->right = cur;
                cur = cur->left;
                continue;
            }
            else
                mostRight->right = NULL;
        }
        else
            // 这个比一般的 Morris 遍历多一个 else，因为要将其和有左子树但是第二次遍历的情况分开来
            cout << cur->data << ", ";
        cur = cur->right;
    }
}
```

#### 6.3.2 Morris遍历实现中序遍历

**方法：**对于有左子树的结点，其必然被遍历两遍，在第二次经过它的时候进行操作；对于没有左子树的结点，其只被经过一遍，经过它的时候进行操作。

``` c plus
// Morris中序遍历
void MorrisMidForeach(TNode*& const head)
{
    if (head == NULL) return;
    TNode* cur = head;
    TNode* mostRight = NULL;
    while (cur != NULL)
    {
        mostRight = cur->left;
        if (mostRight != NULL)
        {
            while (mostRight->right != NULL && mostRight->right != cur)
                mostRight = mostRight->right;
            if (mostRight->right == NULL)
            {
                mostRight->right = cur;
                cur = cur->left;
                continue;
            }
            else
            {
                mostRight->right = NULL;
                cout << cur->data << ", ";
            }
        }
        else
            cout << cur->data << ", ";
        cur = cur->right;
    }
}
```

#### 6.3.3 Morris遍历实现后序遍历

**方法：**对于有左子树的结点，其必然被遍历两遍，在第二次经过它的时候，对其左子树的右边界根据逆序进行操作；对于没有左子树的结点，其只被经过一遍，不直接进行操作；在基本遍历完成后，逆序遍历整体树的右边界。

``` c plus
// Morris后序遍历
void MorrisPostForeach(TNode*& const head)
{
    if (head == NULL) return;
    TNode* cur = head;
    TNode* mostRight = NULL;
    while (cur != NULL)
    {
        mostRight = cur->left;
        if (mostRight != NULL)
        {
            while (mostRight->right != NULL && mostRight->right != cur)
                mostRight = mostRight->right;
            if (mostRight->right == NULL)
            {
                mostRight->right = cur;
                cur = cur->left;
                continue;
            }
            else
            {
                mostRight->right = NULL;
                PrintRightList(cur->left);
            }
        }
        cur = cur->right;
    }
    PrintRightList(head);
}
```

**主函数：**

``` c plus
void main()
{
    // 构造一棵树
    TNode* head = ConstructUBT();
    cout << "// ========== 前序遍历 ========== //" << endl;
    cout << "普通前序遍历；" << endl;
    PreOrderRecur1(head); cout << endl;
    cout << "Morris前序遍历；" << endl;
    MorrisPreForeach(head); cout << endl;
    cout << "// ========== 中序遍历 ========== //" << endl;
    cout << "普通前序遍历；" << endl;
    InOrderRecur1(head); cout << endl;
    cout << "Morris中序遍历；" << endl;
    MorrisMidForeach(head); cout << endl;
    cout << "// ========== 后序遍历 ========== //" << endl;
    cout << "普通后序遍历；" << endl;
    PostOrderRecur1(head); cout << endl;
    cout << "Morris后序遍历；" << endl;
    MorrisPostForeach(head); cout << endl;

    system("pause");
}
```

#### 6.3.4 Morris遍历实现搜索二叉树识别

**方法：**只需在中序遍历的过程中，采用一个变量用于记录上一个遍历结果即可，只要保证遍历过程始终升序，就返回真，否则返回假。

``` c plus

```

## 7. 大数据问题

1）哈希函数可以把数据按照种类均匀分流；

2）布隆过滤器用于集合的建立与查询，并可以节省大量空间；

3）一致性哈希解决数据服务器的负载管理问题；

4）利用并查集结构做岛问题的并行计算；

5）位图解决某一范围上数字的出现情况，并可以节省大量空间；

6）利用分段统计思想、并进一步节省大量空间；

7）利用堆、外排序来做多个处理单元的结果合并。

### 7.1 找未出现过的数问题

**问题描述：** 32位无符号整数的范围是0~4,294,967,295，现在有一个正好包含40亿个无符号整数的文件，**所以在整个范围中必然存在没出现过的数**。可以使用最多1GB的内存，怎么找到所有未出现过的数？

**问题思路：**我们可以创建一个bit数组，由于8个bit才占用1B，而每一位的bit用于代表对应的数字是否出现过，那么对于32位的无符号整数，我们一共需要$2^{32}$位的bit数组，实际上对应的空间消耗为 $(2^{32})/(2^{3})$ ，结果为 536870912，即500MB左右，则达到了我们的目的。

**[进阶1]**

​		内存限制为10MB，但是只用找到一个没出现过的数即可。

**[进阶2]**

​		内存限制为3KB，但是只用找到一个没出现过的数即可。

**问题思路：**非常简单，对于 3KB ~= 3000B 的存储空间而言，其可以存储的无符号整型数据个数为 3000/4 = 750 个，向下取到离它最近的一个 2 的整数次方，即
$$
n=ground(log_2{750})=9
$$
那么我们可以想象将所有可能产生的整型数分成 $2^n$ 份，每一份对应的数字个数为 $2^{32}/2^{n}$，那么对于第 i 个范围内，其对应维护的数据范围为
$$
(i-1) \times \frac{2^{32}}{2^{n}}  \sim i \times \frac{2^{32}}{2^{n}}-1
$$
然后遍历所有数字，通过判断其对应的范围，将我们的数组的对应索引位置对应的值++，由于数字的范围比数字的个数大，所以必然存在数组在某些位上的数字必然比对应那一份的数字个数少，那么继续在这一部分范围的数中细分即可，周而复始，直到可以完全将数细分。

**[进阶3]**

​		如果仅仅只能申请若干个变量，如何找到一个没出现过的数。直接二分，两边分别有一个变量维护在这个范围内遍历到的数个数，同理，不断细分直至找出一个没有出现过的数。

**代码：**

``` c plus
// C++实现位数组
void main()
{
    // 1024 / 8 = 128 Bytes
    bitset<1024> u;
    cout << sizeof(u) << endl;
    system("pause");
}
```

### 7.2 海量URL问题

​		有个包含100亿个URL的大文件，假设每个URL占用64B，请找出其中所有重复的URL**（Hash分流或者布隆过滤器）**。

**[补充]** 某搜索公司一天的用户搜索词汇是海量的（百亿数据量），请设计一种求出每天热门 Top100 词汇的可行办法。

**思路：**先通过Hash分流，把问题分解到若干子计算机或者小文件中，由一群计算机一起处理，或者逐个处理小文件，在小文件中把所有数据处理为堆（统计过程也在此时进行，之前只是发送数据但是不处理数据），然后最后由各个小文件把最大值发送到一个总堆中进行维护，则每一次总堆中弹出一个元素，其对应的原小文件中就将该条数据从堆顶弹出。

### 7.3 大数据中位数问题

​		32位无符号整数的范围是0~4294967295，现在有40亿个无符号整数，可以使用最多1GB的内存，找出所有出现了两次的数**（Hash分流或者位图表示，此时用2位表示一个整数的信息，比如00表示0次，01表示1次，10表示2次，11表示多于2次）**。

**[补充]** 可以使用最多10MB的内存，怎么找到这40亿个整数的中位数？参考7.1，只是现在在统计词频之后，对词频进行累加，当加上某个位置上的数据之后，其刚好超过20亿，此时说明中位数必定在这个范围上，周而复始，直至细分**（有个误区在于，中位数不一定要有序）**。

### 7.4 有限内存搞定数字排序

​		比如一个文件中有1G的数据，但是内存空间只有500M，要求对原数据进行排序，并将其输出到一个新的文件中。先来看一个东西：
$$
2^{32} = 4,294,967,296 \rightarrow 4 \ billions = 4 G \\\
2^{31} = 2,147,483,648 \rightarrow 2 \ billions = 2 G \\\
2^{29} = 536,870,912 \rightarrow 536 \ millions = 536 M
$$
同理，内存空间向下取整，我们用堆作为中继来处理原数据，而堆中的每一条数据要同时基于数字的大小来进行堆的结构维护，并且每一条数据还需附带该数字出现的数目，那么不妨设一条数据占用的空间为 16 B，那么我们的内存中一共能够处理的数据数目为
$$
\frac{500M}{2^4} \approx 2^{24}
$$
那么此时我们就可以通过多次遍历，而每一次遍历仅处理某个范围上的数据即可，或者以大根堆的形式维护数据，每一次对于原文件中的数据，如果其大于堆顶元素且当前堆中的元素数目已经达到了内存上限，我们不统计该新元素，其不属于当次的处理范围；而如果其比当前堆顶的元素小了，我们弹出堆顶元素，把当前元素放进去，作Heapify，继续。

## 8. 位运算题目

### 8.1 比较大小

​		给定两个有符号32位整数a和b，返回a和b中较大的。

**[要求]** 不用做任何比较判断。

``` c plus
// 判断一个数字的符号
bool sign(const int& number)
{
    // 注：不能用异或，因为负数向右移动的时候，其补位用的是1不是0，会错
    return !((number >> 31) & 1);
}

int getMax1(const int& a, const int& b)
{
    int c = a - b;
    // 得到结果的符号
    bool s = sign(c);
    // 如果符号为正，说明a比b大，则返回a，否则返回b
    return s * a + (!s) * b;
}

// 无溢出的算法
int getMax2(const int& a, const int& b)
{
    int c = a - b;
    bool sa = sign(a);
    bool sb = sign(b);
    bool sc = sign(c);
    // 先总结出返回 a 的情况
    bool diffs = sa ^ sb;
    // ab符号不同且a为正
    // ab符号相同且c为正
    bool condition_return_a = diffs * sa + (!diffs) * sc;
    return condition_return_a * a + (!condition_return_a) * b;
}

void main()
{
    // 非溢出情况测试
    int a = 10;
    int b = -15;
    cout << "Big one is: " << getMax1(a, b) << endl;
    cout << "Big one is: " << getMax2(a, b) << endl;
    // 溢出情况测试
    a = pow(2, 31) - 1;
    b = -pow(2, 31);
    cout << "Big one is: " << getMax1(a, b) << endl;
    cout << "Big one is: " << getMax2(a, b) << endl;
    system("pause");
}
```

### 8.2 判断数

**问题描述：**判断一个 32 位的**正数**是不是 2 的幂、4 的幂。

**思路：**非常之简单，如果一个数是 2 的幂，那么其在位图上必然只有一个位置为 1，如果一个数是 4 的幂，那么其必然先是 2 的幂，即位图上只有一个位置为 1，并且这个 1 必然在偶数位上，值得一提的是 2 进制到 16 进制的转换，其实就是把 2 进制的数 44 分组，每一组变成其对应的 16 进制的数即可：
$$
01010101010101010101010101010101 \rightarrow 0\rm X55555555
$$
**判断一个数在位图上是否只有一个1：**

1）找到其最右边的第一个1，提取出来，如果它和本身数值相同，则说明该数仅在位图上有一个 1；

2）该数减去1，和本身与，如果为0则...。

**代码：**

``` c plus
// 判断一个数是否是2的次幂
bool if2Pow(const int& a)
{
    // 把两个条件放在一个里面，要求同时成立
    return ((a - 1) & a) == 0 && ((~a + 1) & a) == a;
}

// 判断一个数是否是4的次幂
bool if4Pow(const int& a)
{
    return (a & (0x55555555)) && ((a - 1) & a) == 0;
}

void main()
{
    vector<int> arr = { 1,3,4,8,64,128,99,72,144,256 };
    for_each(arr.begin(), arr.end(), [&](const int& number) {
        cout << "The number " << number << (if2Pow(number) ? (" is the power of 2.") : (" isn't the power of 2.")) << endl;
        cout << "The number " << number << (if4Pow(number) ? (" is the power of 4.") : (" isn't the power of 4.")) << endl;
        cout << "================================" << endl << endl;
        });
    system("pause");
}
```

### 8.3 不用算数运算符的整数运算

​		给定两个**有符号32位整数a和b**，不能使用算术运算符，分别实现a和b的加、减、乘、除运算。

**[要求]** 如果给定a、b执行加减乘除的运算结果就会导致数据的溢出，那么你实现的函数不必对此负责，除此之外请保证计算过程不发生溢出。

**（1）加法：**

​		加法 = 两数字异或的结果（无进位加法） + 两数字求与再向左移动（进位信息）

重复上述的过程，**<font color = red>直到在某一步将不产生进位信息</font>**，则输出结果。

**代码：**

``` c plus
// 该加法没有专门处理数据溢出的情况
int mAdd(const int& a, const int& b)
{
    // tmpA 表示无进位加法，tmpB 表示进位信息
    int tmpA = a, tmpB = b;
    // 写作sum，其实只是一个临时变量，因为在一次操作的过程中，要保证原始的 a 和 b 不被修改
    int sum = tmpA;
    while (tmpB != 0)
    {
        sum = tmpA ^ tmpB;
        tmpB = (tmpA & tmpB) << 1;
        tmpA = sum;
    }
    return sum;
}
void main()
{
    vector<int> arr1 = RandVector(0, 100, 20, true);
    vector<int> arr2 = RandVector(0, 100, 20, true);
    for (int i = 0; i < arr1.size(); i++)
    {
        cout << "(Directly) a + b = " << arr1[i] + arr2[i] << endl;
        cout << "(Bit Operation) a + b = " << mAdd(arr1[i], arr2[i]) << endl;
        cout << "==============================================" << endl;
    }

    system("pause");
}
```

**（2）减法**

​		A - B = A + (-B)

​		而负数的反码实际上就等于其对应正数按位取反，那么负数的二进制实际上就是对应正数按位取反再 + 1，比较有意思的是，正负数的运算也等同于其二进制表示形式下的运算。

**代码：**

``` c plus
int mNegative(const int& a)
{
    return (~a + 1);
}

int mMinus(const int& a, const int& b)
{
    return mAdd(a, mNegative(b));
}
void main()
{
    vector<int> arr1 = RandVector(0, 100, 20, true);
    vector<int> arr2 = RandVector(0, 100, 20, true);
    for (int i = 0; i < arr1.size(); i++)
    {
        cout << "(Directly) a - b = " << arr1[i] - arr2[i] << endl;
        cout << "(Bit Operation) a - b = " << mMinus(arr1[i], arr2[i]) << endl;
        cout << "==============================================" << endl;
    }
    system("pause");
}
```

**（3）乘法**

​		二进制的乘法规则和十进制是一样的，确实有点东西，而且由于二进制刚好存在0和1，所以可以将乘法分解为加法。

**代码：**

``` c plus
int mTimes(const int& a, const int& b)
{
    // 先判断符号
    bool sa = sign(a);
    bool sb = sign(b);
    int result = 0;
    // 全部转换为正数
    int tmpA = sa ? a : mNegative(a);
    int tmpB = sb ? b : mNegative(b);
    while (tmpB != 0)
    {
        if ((tmpB & 1) != 0)
        {
            result = mAdd(result, tmpA);
        }
        tmpA <<= 1;
        tmpB >>= 1;
    }
    return sa == sb ? result : mNegative(result);
}

void main()
{
    vector<int> arr1 = RandVector(-50, 50, 20, true);
    vector<int> arr2 = RandVector(-50, 50, 20, true);
    for (int i = 0; i < arr1.size(); i++)
    {
        cout << "(Directly) a * b = " << arr1[i] * arr2[i] << endl;
        cout << "(Bit Operation) a * b = " << mTimes(arr1[i], arr2[i]) << endl;
        cout << "==============================================" << endl;
    }
    system("pause");
}
```

**（4）除法**

**思路：**由于除法是乘法的逆运算，可以通过这个性质来构造除法运算，比如如果用101101/000101，那么很明显，在001000位置和000001位置上会存在一个00101，那么结果就是001001；

**实际操作：**对于问题 a / b，让 a 向右移动（用临时变量，不要真的把修改 a，以免丢失信息），最多移动32位，只要当次移动之后，

**代码：**

``` c plus
int mDivide(const int& a, const int& b)
{
    bool sa = sign(a);
    bool sb = sign(b);
    int tmpA = sa ? a : mNegative(a);
    int tmpB = sb ? b : mNegative(b);
    int result = 0;
    // 这里从大到小没有任何问题，即从高位开始首先去除除数，其实 a 右移完全等于 b 左移，不用想那么复杂，逻辑上是通顺的
    for (int i = 31; i > -1; i--)
    {
        // 值得注意的是，当前数字必然是正数，所以在第一次循环中，向右移动31位，此时移出来的值为 0
        // 这里没有真的修改 tmpA 的值
        if ((tmpA >> i) >= tmpB)
        {
            result |= (1 << i);
            tmpA = mMinus(tmpA, tmpB << i);
        }
    }
    return sa == sb ? result : mNegative(result);
}

void main()
{
    vector<int> arr1 = RandVector(-500, 500, 40, true);
    vector<int> arr2 = RandVector(-10, 10, 40, true);
    for (int i = 0; i < arr1.size(); i++)
    {
        if (arr2[i] == 0)break;
        cout << "(Directly) a / b = " << arr1[i] / arr2[i] << endl;
        cout << "(Bit Operation) a / b = " << mDivide(arr1[i], arr2[i]) << endl;
        cout << "==============================================" << endl;
    }
    system("pause");
}
```

**针对特殊情况的解法（主要是要在a和b取到最小整数值的时候，因为此时我们的Negative函数无法再正确地表示最小负整数值对应的正整数）：**

``` c plus
int mDivide_Complete(const int& a, const int& b)
	{
		if (b == 0) throw string("The divisor is 0");
		if (a == INT_MIN && b == INT_MIN)
			return 1;
		else if (b == INT_MIN)
			return 0;
		else if (a == INT_MIN)
		{
			int result = mDivide(mAdd(a, 1), b);
			return mAdd(result, mDivide(mMinus(a, mTimes(result, b)), b));
		}
		else
			return mDivide(a, b);
	}

void main()
{
    cout << "// ========= Special conditions 1: ========= //" << endl;
    int number1 = INT_MIN;
    int number2 = INT_MIN;
    cout << "(Directly) a / b = " << number1/number2 << endl;
    cout << "(Bit Operation) a / b = " << mDivide_Complete(number1, number2) << endl;
    cout << "Special conditions 2: " << endl;
    
    cout << "// ========= Special conditions 2: ========= //" << endl;
    number1 = 25;
    number2 = INT_MIN;
    cout << "(Directly) a / b = " << number1 / number2 << endl;
    cout << "(Bit Operation) a / b = " << mDivide_Complete(number1, number2) << endl;

    vector<int> arr1(5, INT_MIN);
	vector<int> arr2{ 1, -2, INT_MAX, INT_MIN + 1, INT_MIN / 2 };

    cout << "// ========= Special conditions 3: ========= //" << endl;
    for (int i = 0; i < arr1.size(); i++)
    {
		cout << "(Directly) a / b = " << arr1[i] / arr2[i] << endl;
		cout << "(Bit Operation) a / b = " << mDivide_Complete(arr1[i], arr2[i]) << endl;
    }
    system("pause");
}
```

**主要说明一下函数中<font color = red>被除数是最小整数的情况</font>：**

​		实际上很简单，我们可以先计算 INT_MIN + 1 作为除数的情况，然后再在下一个等价表达式中掺入这一项，保证每一次运算都在控制范围内，因为我们的目标是
$$
result= \frac{a}{b}
$$
那么有
$$
c=\frac{a+1}{b}\\\
result=c + \frac{a-bc}{b}=\frac{a}{b}
$$
**<font color = red>值得注意的是，bc 必然可以整除 b，所以用 a - bc 之后除以 b，其得到结果的余数和直接用 a 除以 b 是一样的，这是保证最后结果不出错的前提。</font>**

## 9. 动态规划

**优化流程：**暴力尝试 -> 记忆化搜索 -> 严格表结构

**形成严格表结构的方法：**

​		1）确定问题取值范围；

​		2）确定base case，初始化表格；

​		3）确定表格之间的递推关系；

​		4）确定目标表格元素。

### 9.1 机器人运动问题

**问题简述：**给定一个数 N，对应有 {1, 2, 3, ..., N - 1, N}位置，求出一个机器人从 S 位置开始，用 K 步到达 E 位置的走法数目。

**暴力解法：**很简单，直接看代码

``` c plus
// 各个参数的含义如下所示
// 注：N 至少要是 2，否则没啥意义，因为此时的 startPosition 和 endPosition 都只能在1位置上
int robotWalk1(const int& N, const int& startPosition, const int& endPosition, const int& stepNumber)
{
    if (N < 2 || startPosition < 1 || startPosition >N || endPosition < 1 || endPosition > N || stepNumber < 0)
        return -1;
    return robotWalk1_Process(N, startPosition, endPosition, stepNumber);
}

int robotWalk1_Process(const int& N, const int& startPosition, const int& endPosition, const int& restStepNumber)
{
    // Base Case
    if (restStepNumber == 0)
    {
        // 用完了所有步数之后，如果当前的起始位置在终止位置上，则返回1，否则返回0
        return startPosition == endPosition ? 1 : 0;
    }
    // 两种边界情况
    if (startPosition == 1)
        // 在左边界的时候，其只能往右边走
        return robotWalk1_Process(N, startPosition + 1, endPosition, restStepNumber - 1);
    if (startPosition == N)
        // 在右边界的时候，其只能往左边走
        return robotWalk1_Process(N, startPosition - 1, endPosition, restStepNumber - 1);
    // 剩下的是中间位置的情况
    // 往左走的情况
    int stepLeft = robotWalk1_Process(N, startPosition - 1, endPosition, restStepNumber - 1);
    int stepRight = robotWalk1_Process(N, startPosition + 1, endPosition, restStepNumber - 1);
    return stepLeft + stepRight;
}
```

<font color= red>**注：在函数递归调用的时候，其与调用它的函数无关，即之前的决定不影响当前函数的调用（即只要实参确定，其调用的结果必然相同），即无后效型的尝试，这种问题是比较适合用动态规划方法的。**</font>

**记忆化搜索方法：**

``` c plus
// 方案2，记忆化搜索
// 个人感觉，用 vector 嵌套一个 hash_map 比较方便，双层 hash 表也不太方便，至少对这个问题是这样的
int robotWalk2(const int& N, const int& startPosition, const int& endPosition, const int& stepNumber)
{
    // 初始的时候，给 vec 装 N + 1 个空的哈希表，至于为什么是 N + 1，因为 0 位置我们不用，所以最终的维度其实是 N + 1
    vector<unordered_map<int, int>> dpMap(N + 1);
    int result = robotWalk2_Process(N, startPosition, endPosition, stepNumber, dpMap);
    return result;
}
int robotWalk2_Process(const int& N, const int& startPosition, const int& endPosition, const int& restStepNumber
    , vector<unordered_map<int, int>>& dp)
{
    if (dp[startPosition].find(restStepNumber) != dp[startPosition].end())
    {
        // 说明从当前 startPosition 开始走并剩余 restStepNumber 的情况已经计算过，则直接返回该值，不需要重新计算
        return dp[startPosition][restStepNumber];
    }
    if (restStepNumber == 0)
    {
        // 这里必须返回，不然其会继续往下执行，是错误的
        dp[startPosition][restStepNumber] = startPosition == endPosition ? 1 : 0;
        return dp[startPosition][restStepNumber];
    }
    // 两种边界情况
    if (startPosition == 1)
    {
        // 在左边界的时候，其只能往右边走
        dp[startPosition].insert(make_pair(restStepNumber, robotWalk2_Process(N, 2, endPosition, restStepNumber - 1, dp)));
    }
    else if (startPosition == N)
    {
        // 在右边界的时候，其只能往左边走
        dp[startPosition].insert(make_pair(restStepNumber, robotWalk2_Process(N, N - 1, endPosition, restStepNumber - 1, dp)));
    }
    else
    {
        // 剩下的是中间位置的情况
        int stepLeft = robotWalk2_Process(N, startPosition - 1, endPosition, restStepNumber - 1, dp);
        int stepRight = robotWalk2_Process(N, startPosition + 1, endPosition, restStepNumber - 1, dp);
        dp[startPosition].insert(make_pair(restStepNumber, stepRight + stepLeft));
    }
    return dp[startPosition][restStepNumber];
}
```

**严格表结构：**

​		记忆化搜索方法仅仅是通过空间换时间，但是严格表结构会关注各个递归层级之间的联系。比如给定 N = 5，且机器人从 2 位置开始走，用 5 步走到 4 位置。

​		1）确定问题取值范围，对该问题，N 和 E 不变，K 从 5 变到 0，S 从 1 变到 N； 

​		2）确定base case，初始化表格，该问题的 base case 是 K = 0 时，S 是否和 E 相等，相等取 1， 不等取 0；

​		3）确定表格之间的递推关系，对边界情况，即 S 为 1 和 N 的情况，在下面的表格中，分别仅基于左下角元素和左上角元素，其他情况同时基于左下和右上角元素；

​		4）确定目标表格元素，目标是 K = 5，S = 2 对应位置的元素。

| | K = 5 | K = 4 | K = 3 | K = 2 | K = 1 | K = 0 |
| :---:  | :---: | :---: | :---: | :---: | :---: | -----  |
| **S = 1** | 4 | 0 | 1 | 0 | 0 | 0 |
| **S = 2** | <font color=red> **0** </font> | 4 | 0 | 1 | 0 | 0 |
| **S = 3** | 9 | 0 | 3 | 0 | 1 | 0 |
| **S = 4** | 0 | 5 | 0 | 2 | 0 | 1 |
| **S = 5** | 5 | 0 | 2 | 0 | 1 | 0 |

**代码：**

``` c plus\
int robotWalk3(const int& N, const int& startPosition, const int& endPosition, const int& stepNumber)
{
    if (N < 2 || startPosition<1 || startPosition>N || endPosition < 1 || endPosition>N || stepNumber < 0)
        return 0;
    // 第一个坐标表示的是起始位置
    vector<unordered_map<int, int>> dpMap(N + 1);
    // 初始化表格和表格元素递推
    // 值得注意的是，需要观察如何循环可以自然地初始化元素并进行后续递推
    for (int j = 0; j <= stepNumber; j++)
    {
        if (j == 0)
        {
            // 1. 初始化表格
            for (int i = 1; i < N + 1; i++)
            {
                dpMap[i][j] = i == endPosition;
            }
        }
        else
        {
            // 2. 元素递推
            for (int i = 1; i < N + 1; i++)
            {
                if (i == 1)
                    dpMap[i][j] = dpMap[i + 1][j - 1];
                else if (i == N)
                    dpMap[i][j] = dpMap[i - 1][j - 1];
                else
                    dpMap[i][j] = dpMap[i + 1][j - 1] + dpMap[i - 1][j - 1];
            }
        }	
    }
    // 返回对应元素
    return dpMap[startPosition][stepNumber];
}
```

**基于上述的案例，写出主函数为：**

``` c plus
void main()
{
	int N = 5;
	int E = 4;
	int K = 5;
	for (int S = 1; S <= N; S++)
	{
		cout << "The result when S equals " << S << ": " << robotWalk1(N, S, E, K) << ", ";
		cout << robotWalk2(N, S, E, K) << ", ";
		cout << robotWalk3(N, S, E, K) << endl;
	}
    system("pause");
}
```

**时间复杂度分析：**

​		对该问题而言，**对暴力法，**其采用系统栈的形式处理，而每一次压栈递归可看作产生两个分支，而根据初始步数 K，其最终可能递归 K 次，所以时间复杂度可看作 $O(2^K)$；

​		**对记忆化搜索和严格表格法，**两者的最终结果都是把一个 N × K 的表格填满，所以时间复杂度为 $O(N \times K)$。



### 9.2 硬币最少问题

**问题描述：**有一堆硬币，面值为{2, 7, 3, 4, 3, 2}，如果现在要求面值达到某个值 aim，比如10，求最少需要多少个硬币，对这道题结果为 2。

**暴力解法：**

``` c plus
// 方案1，直接递归
int minCoins1(const vector<int>& arr, const int& aim)
{
    if (arr.size() == 0 || aim < 0)
        // 表示无解
        // 值得注意的是，这里的无解和解为 0 是有区别的，解为 0 表示的是选中之前的硬币之后，不选当前硬币，可以形成最终解
        return -1;
    return minCoins1_Process(arr, 0, aim);
}
// index表示前面所有的 index 已经确定，用 index ~ end 达成 aim 目标
int minCoins1_Process(const vector<int>& arr, const int& index, const int& aim)
{
    // base case
    if (aim < 0)
        // 不管现在是在选哪个硬币，只要 aim 比 0 小，则肯定无解
        return -1;
    if (aim == 0)
        // 说明此时达到目标，则当前及后面的硬币肯定不能再选了
        return 0;
    if (index == arr.size())
        // 如果硬币已经全部选完了，若此时达到了目标，则返回 0，因为当前不需要再选硬币，否则返回 -1，说明无解
        return -1;
    // 然后分析普通情况
    // p1 代表不要当前硬币的情况下，后续能产生的可以达到目的的最小硬币数目
    int p1 = minCoins1_Process(arr, index + 1, aim);
    // p2 代表要当前硬币的情况下，后续能产生的可以达到目的的最小硬币数目，但需要注意的是，这里一定不能直接 + 1，因为 -1 代表的是无解
    int p2 = minCoins1_Process(arr, index + 1, aim - arr[index]);
    if (p1 == -1 && p2 == -1)
        // 说明后续情况均无解，则选不选当前硬币都无解
        return -1;
    // 下面是两种情况中，至少有一种情况有解，则返回那种情况
    if (p1 == -1)
        return p2 + 1;
    if (p2 == -1)
        return p1;
    return min(p1, p2 + 1);
}
```

**记忆化搜索：**

``` c plus
int minCoins2(const vector<int>& arr, const int& aim)
{
    if (arr.size() == 0 || aim < 0)
        // 表示无解
        // 值得注意的是，这里的无解和解为 0 是有区别的，解为 0 表示的是选中之前的硬币之后，不选当前硬币，可以形成最终解
        return -1;
    // 至于维度为什么是 size + 1，这是由于我们也要记录终止位置上的结果
    vector<unordered_map<int, int>> dpMap(arr.size() + 1);
    return minCoins2_Process(arr, 0, aim, dpMap);
}
int minCoins2_Process(const vector<int>& arr, const int& index, const int& aim, vector<unordered_map<int, int>>& dpMap)
{
    if (aim < 0)
        // 在这一步就说明，我们必然不会把 aim 小于 0 的情况推入到我们的表格中
        return -1;
    if (dpMap[index].find(aim) != dpMap[index].end())
        // 说明之前算过这种情况，直接返回
        return dpMap[index][aim];
    if (aim == 0)
    {
        // 形成一种解，但是不能选当前硬币，所以给 0
        dpMap[index][aim] = 0;
        return 0;
    }
    if (index == arr.size())
    {
        // 这种情况说明无解，因为 aim < 0 和 aim == 0 的情况已经判断过，此时 aim > 0，则必然无解
        dpMap[index][aim] = -1;
        return -1;
    }
    // 一般情况	
    int p1 = minCoins2_Process(arr, index + 1, aim, dpMap);
    int p2 = minCoins2_Process(arr, index + 1, aim - arr[index], dpMap);
    // 注，下面必须写成并列形式，不能够单独写 if，一定要注意这个问题！！！！！！
    if (p1 == -1 && p2 == -1)
        dpMap[index][aim] = -1;
    else if (p1 == -1)
        dpMap[index][aim] = p2 + 1;
    else if (p2 == -1)
        dpMap[index][aim] = p1;
    else
        dpMap[index][aim] = min(p1, p2 + 1);
    return dpMap[index][aim];
}
```

**严格表格法：**

``` c plus
// 方案3，严格表格法
int minCoins3(const vector<int>& arr, const int& aim)
{
    if (arr.size() == 0 || aim < 0)
        // 表示无解
        // 值得注意的是，这里的无解和解为 0 是有区别的，解为 0 表示的是选中之前的硬币之后，不选当前硬币，可以形成最终解
        return -1;
    // base case，能够想到，aim 小于 0 的情况暂且不论，在 index == arr.size() 时，仅有 aim == 0 的元素被设置为 0，其他的都是 -1
    // 值得注意的是，对于 index == arr.size() 情况下，对应哈希表的 key 的选择，由于 aim 小于 0 的情况我们不记录，所以我们只记录 arr 数组中的数值
    // 比较尴尬的问题是，对于 index == arr.size() 情况下，对应哈希表的 key 的选择可能是 aim 减去 arr 中任意个元素组合累加的结果
    // 这么算就明显麻烦了，因为这个时间复杂度是 O(arr.size()!)，所以不如不用哈希表，直接用 vector 全部记录，那么显然，此时的二维数组中，很多元素是用不上的
    // 式中，-2 表示还未操作过，-1 表示无解
    vector<vector<int>> dpMap(arr.size() + 1, vector<int>(aim + 1, -2));
    // 在老师的代码中，这里把列为 0，即 aim == 0 的所有行元素都置为 0，这从逻辑上看确实没有任何问题
    // 不用担心其它元素会有影响，因为我们的结果只会用到固定的那些数据
    for (int i = 0; i <= arr.size(); i++)
        dpMap[i][0] = 0;
    for (int j = 1; j <= aim; j++)
        // 最后一行，除了第一个元素，全部置为 -1，都是没有解的
        dpMap[arr.size()][j] = -1;
    // 倒过来循环
    for (int index = arr.size() - 1; index >= 0; index--)
    {
        for (int rest = 1; rest <= aim; rest++)
        {
            // 因为第 0 列已经设置为 0 了，所以从 1 列开始
            int p1 = dpMap[index + 1][rest];
            // p2 的值需要稍微注意一下
            int p2 = rest - arr[index] < 0 ? -1 : dpMap[index + 1][rest - arr[index]];
            if (p1 == -1 && p2 == -1)
                dpMap[index][rest] = -1;
            else if (p1 == -1)
                dpMap[index][rest] = p2 + 1;
            else if (p2 == -1)
                dpMap[index][rest] = p1;
            else
                dpMap[index][rest] = min(p1, p2 + 1);
        }
    }
    // 该问题中，明显应该返回的值是 dpMap[0][aim]
    return dpMap[0][aim];
}
```

**主函数：**

``` c plus
void main()
{
    // 随机生成 10 次数据，看方法的计算结果是否相同
    int aim = 200;
    for (int i = 0; i < 20; i++)
    {
        vector<int> arr = RandVector(0, 20, 25, true);
        // 事实证明，主要还是第一个算法的时间复杂度过高
		cout << "Random Vector " << i << ": " << minCoins1(arr, aim) << ", " << minCoins2(arr, aim) << ", " << minCoins3(arr, aim) << endl;
    }
    system("pause");
}
```

**时间复杂度：**显然，**暴力法**的时间复杂度为 $O(2^{arr.size()})$，这个时间复杂度是非常高的 ；

而上面代码中的**记忆化搜索法**的时间复杂度不太好估计，简而言之，需要看 (aim - arr中的各个任意元素之间的累积和) 有多少个不同的结果，且还需要剔除掉结果小于 0 的情况，**而且此时在读取数据的时候还需要计入哈希表存取的时间复杂度，有点小麻烦**，不妨设对应数据为 K，那么大致的最终时间复杂度为 $O(K\times arr.size())$；

**严格化表格法（上述的实现形式）**的时间复杂度为 $O(arr.size() \times aim)$。

### 9.3 纸牌博弈问题

​		**是之前用递归做过的一个问题，再看一下题，现在要求将其改为动态规划的方法：**

​		给定一个整型数组arr，代表数值不同的纸牌排成一条线。玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后拿，但是每个玩家每次只能拿走最左或最右的纸牌，玩家A和玩家B都绝顶聪明。请返回最后获胜者的分数。
**[举例]**

**情况1：**

1. arr=[1, 2, 100, 4]。开始时，玩家A只能拿走1或4。如果开始时玩家A拿走1，则排列变为[2, 100, 4]，接下来玩家B可以拿走2或4，然后继续轮到玩家A...

2. 如果开始时玩家A拿走4，则排列变为[1，2，100]，接下来玩家B可以拿走1或100，然后继续轮到玩家A...

3. 玩家A作为绝顶聪明的人不会先拿4，因为拿4之后，玩家B将拿走100。所以玩家A会先拿1，

4. 让排列变为[2, 100, 41]，接下来玩家B不管怎么选，100都会被玩家A拿走。玩家A会获胜，分数为101。所以返回101。

**情况2：**

1. arr=[1, 100, 2]。开始时，玩家A不管拿1还是2，玩家B作为绝顶聪明的人，都会把100拿走。玩家B会获胜分数为100。所以返回100。

**记忆化搜索：**

``` c plus
// 方案2，记忆化搜索
int CardGambling2(const vector<int>& arr)
{
    if (arr.size() == 0) return 0;
    vector<vector<int>> dpMap_First(arr.size(), vector<int>(arr.size(), -1));
    vector<vector<int>> dpMap_Second(arr.size(), vector<int>(arr.size(), -1));
    // 初始对角线元素，意味着在仅剩一个元素的时候，先手和后手能否取到这个元素
    for (int i = 0; i < arr.size(); i++)
    {
        dpMap_First[i][i] = arr[i];
        dpMap_Second[i][i] = 0;
    }
    return max(CardGambling2_FirstProcess(arr, 0, arr.size() - 1, dpMap_First, dpMap_Second),
        CardGambling2_SecondProcess(arr, 0, arr.size() - 1, dpMap_First, dpMap_Second));
}
int CardGambling2_FirstProcess(const vector<int>& arr, const int& i, const int& j, vector<vector<int>>& dpMap_First, vector<vector<int>>& dpMap_Second)
{
    // 因为当前是先手函数，所以用先手的矩阵进行判断
    if (dpMap_First[i][j] != -1)
        return dpMap_First[i][j];
    else
        dpMap_First[i][j] = \
            max(CardGambling2_SecondProcess(arr, i + 1, j, dpMap_First, dpMap_Second) + arr[i]\
            ,CardGambling2_SecondProcess(arr, i, j - 1, dpMap_First, dpMap_Second) + arr[j]);
    return dpMap_First[i][j];
}
int CardGambling2_SecondProcess(const vector<int>& arr, const int& i, const int& j, vector<vector<int>>& dpMap_First, vector<vector<int>>& dpMap_Second)
{
    // 因为当前是后手函数，所以用后手的矩阵进行判断
    if (dpMap_Second[i][j] != -1)
        return dpMap_Second[i][j];
    else
        dpMap_Second[i][j] = \
            min(CardGambling2_FirstProcess(arr, i + 1, j, dpMap_First, dpMap_Second)\
            , CardGambling2_FirstProcess(arr, i, j - 1, dpMap_First, dpMap_Second));
    return dpMap_Second[i][j];
}
```

**严格表格结构：**

``` c plus
// 方案3，严格表格
int CardGambling3(const vector<int>& arr)
{
    // 值得注意的是，这种范围递归的问题，很多时候 i 和 j 是有严格的大小关系的，也就是说 i <= j，所以创造的表也仅有一般，另外一半不能用
    if (arr.size() == 0) return 0;
    vector<vector<int>>dpMap_First(arr.size(), vector<int>(arr.size() ,-1));
    vector<vector<int>>dpMap_Second(arr.size(), vector<int>(arr.size(), -1));
    for (int i = 0; i < arr.size(); i++)
    {
        dpMap_First[i][i] = arr[i];
        dpMap_Second[i][i] = 0;
    }
    // 然后按照对角线进行循环赋值即可
    for (int i = 1; i < arr.size(); i++)
    {
        // 外层循环是按照对角线循环
        for (int j = 0; j < arr.size() - i; j++)
        {
            // 内存循环是在一条对角线以内进行循环
            // 值得注意的是 dpMap_Second[j][j + i - 1] 是同行前一列的元素，说明拿走的是 j + i 元素
            // dpMap_Second[j + 1][j + i] 是同列的后一行的元素，说明拿走的是 arr[j] 元素
            // dpMap_First[j][j + i] 表示从 j ~ j + i 位置上选元素
            dpMap_First[j][j + i] = max(dpMap_Second[j][j + i - 1] + arr[j + i], dpMap_Second[j + 1][j + i] + arr[j]);
            dpMap_Second[j][j + i] = min(dpMap_First[j][j + i - 1], dpMap_First[j + 1][j + i]);
        }
    }
    return max(dpMap_First[0][arr.size() - 1], dpMap_Second[0][arr.size() - 1]);
}
```

**主函数：**

``` c plus
void main()
{
    for (int i = 0; i < 31; i++)
    {
        vector<int> arr = RandVector(1, 100, 26, true);
        cout << "The rand vector " << i << ", result: "<< CardInline_Win1(arr) << ", " << CardGambling2(arr)<<", "<<CardGambling3(arr) << endl;
    }
    system("pause");
}
```

**时间复杂度分析：**

​		很明显，由于暴力法递归就是二分递归压栈，所以时间复杂度显然为 $O(2^{arr.size()})$，而记忆化搜索和严格表格的时间复杂度都明显是填表的复杂度，即 $O(arr.size() \times arr.size())$。所以，记忆化搜索和严格表格法可以处理到 1000 维度这个数量级的问题，当然，对暴力递归法，处理到 30 维度左右数量级的问题就已经跑不动了：

``` c plus
void main()
{
    for (int i = 0; i < 31; i++)
    {
        vector<int> arr = RandVector(1, 200, 1000, true);
        cout << "The rand vector " << i << ", result: " << CardGambling2(arr)<<", "<<CardGambling3(arr) << endl;
    }
    system("pause");
}
```

### 9.4 象棋🐎问题

​		有一个棋盘，将其各个放棋的点看作坐标点，有一个 🐎，总是在最开始的时候将其放在左下角坐标原点，要求其跳 K 次，最终达到位置 (x, y)的方法有多少种，这个问题一看就知道是一个**无后效型的尝试问题。**

**问题解法：**关键在于，如何把原问题逐步分解。而之所以称这个问题是个三维的问题，是因为在每一步递归中，可变参数有 3 个。思路还是很简单的，找到 K 步跳到 (x, y) 点的方法数，实际上可以找出 K - 1 步跳到 (x - 1, y + 2) 的方法数 + K - 1跳到 (x - 1, y - 2) 的方法数 +...，因为我们只要能用 K - 1 步跳到最终目标点的周围点，那么下一步必然可以产生一种解法，能够跳到 K 步的目标位置。

**代码：**还是很简单的，不用过多解释

``` c plus
// 象棋跳马问题
// 方案1，暴力递归
int HorseJump1(const int& x, const int& y, const int& restStepNumber)
{
    return HorseJump1_Process(x, y, restStepNumber);
}
int HorseJump1_Process(const int& x, const int& y, const int& restStepNumber)
{
    // 不能越界，越界就返回 0 
    // 如果不能跳了，那么除非当前目标点就在原点，可以返回 1，否则返回 0
    if (x < 0 || x > 8 || y < 0 || y > 9 || restStepNumber < 0)
        return 0;
    if (restStepNumber == 0)
        return (x == 0 && y == 0) ? 1 : 0;
    return \
        HorseJump1_Process(x - 1, y + 2, restStepNumber - 1)\
        + HorseJump1_Process(x - 1, y - 2, restStepNumber - 1)\
        + HorseJump1_Process(x + 1, y + 2, restStepNumber - 1)\
        + HorseJump1_Process(x + 1, y - 2, restStepNumber - 1)\
        + HorseJump1_Process(x - 2, y + 1, restStepNumber - 1)\
        + HorseJump1_Process(x - 2, y - 1, restStepNumber - 1)\
        + HorseJump1_Process(x + 2, y + 1, restStepNumber - 1)\
        + HorseJump1_Process(x + 2, y - 1, restStepNumber - 1);
}

// 方案2，严格表格
int HorseJump2(const int& x, const int& y, const int& K)
{
    // 第一循环表示行，取值范围为 [0, 8]，第二循环表示列，取值范围为 [0, 9]，第三循环表示使用步数，因为是从 0 ~ K，所以是 K + 1 维
    vector<vector<vector<int>>> dpMap(9, vector<vector<int>>(10, vector<int>(K + 1, 0)));
    // 第一层，即无跳步的情况下，只有 x y 表示原点的时候，才能有一种解法
    dpMap[0][0][0] = 1;
    // 由于同层数据之间没有依赖关系，所以这个递推还是非常简单的
    for (int k = 1; k <= K; k++)
        for (int i = 0; i < 9; i++)
            for (int j = 0; j < 10; j++)
            {
                dpMap[i][j][k] += getValue(dpMap, i - 1, j + 2, k - 1);
                dpMap[i][j][k] += getValue(dpMap, i - 1, j - 2, k - 1);
                dpMap[i][j][k] += getValue(dpMap, i + 1, j + 2, k - 1);
                dpMap[i][j][k] += getValue(dpMap, i + 1, j - 2, k - 1);
                dpMap[i][j][k] += getValue(dpMap, i - 2, j + 1, k - 1);
                dpMap[i][j][k] += getValue(dpMap, i - 2, j - 1, k - 1);
                dpMap[i][j][k] += getValue(dpMap, i + 2, j + 1, k - 1);
                dpMap[i][j][k] += getValue(dpMap, i + 2, j - 1, k - 1);
            }
    return dpMap[x][y][K];
}
int getValue(const vector<vector<vector<int>>>& dpMap, const int& i, const int& j, const int& k)
{
    // 可以想象，在边界的时候，一个平面内的 i 和 j 是可能产生越界的
    if (i < 0 || i > 8 || j < 0 || j > 9 || k < 0)
        return 0;
    else
        return dpMap[i][j][k];
}
void main()
{
    int x = 7;
    int y = 3;
    int K = 10;
    cout << HorseJump1(x, y, K) <<", " << HorseJump2(x, y, K) << endl;
    system("pause");
}
```

### 9.5 Bob生存概率

**问题简述：**给定一个网格范围 [0 ~ N] 和 [0 ~ M]，Bob 初始位置在 (x, y)，Bob 在每一步等概率地往上下左右运动，共运动 K 步，问 Bob 活下来的概率。

**解题思路：**非常简单，活下来的方法数 / 走的总方法数即可。

**求最大公约数：**辗转相除法，即对一个被除数 m 和除数 n，在除数不为 0 的情况下，将原被除数 m 置为原除数 n，将原除数 n 置为 (原被除数 m 模 原除数)；若除数为 0，直接返回被除数。

``` c plus
// 辗转相除法求最大公约数
long gcd(const int& m, const int& n)
{
    return n == 0 ? m : gcd(n, m % n);
}
```

**代码：**真的太简单了这种问题

``` c plus
// Bob生存问题
void BobLive1(const int& M, const int& N, const int& x, const int& y, const int& K)
{
    // 所有可能情况
    long all = pow(4, K);
    // Bob生存下来的情况
    long live = BobLive1_Process(M, N, x, y, K);
    long g = gcd(all, live);
    cout << "The probability that Bob stay alive is: " << live / g << "/" << all / g << endl;
}
long BobLive1_Process(const int& M, const int& N, const int& x, const int& y, const int& K)
{
    // 如果当前走到边界外了，则直接返回 0
    if (x < 0 || x > M || y < 0 || y > N)
        return 0;
    // 说明此时并没有越界，而且步数也用完了，那么可以返回 1 种存活的情况
    if (K == 0)
        return 1;
    return \
        BobLive1_Process(M, N, x - 1, y, K - 1)\
        + BobLive1_Process(M, N, x + 1, y, K - 1)\
        + BobLive1_Process(M, N, x, y - 1, K - 1)\
        + BobLive1_Process(M, N, x, y + 1, K - 1);
}
void main()
{
    // 这个表示的是 口 口，起始点点在左边那个框上，只能走一步，看能有多少存活的概率，明显是 1/4
    BobLive1(1, 0, 0, 0, 1);
    system("pause");
}
```

**动态规划代码：**

``` c plus
// 严格表格法
void BobLive2(const int& M, const int& N, const int& x, const int& y, const int& K)
{
    // 这张表只用来统计能活的情况，只有最开始踩在范围内，才有可能或，所以只初始化这个范围内的表格
    vector<vector<vector<long>>> dpMap(M + 1, vector<vector<long>>(N + 1, vector<long>(K + 1, 0)));
    // 那么踩在这个范围内且初始步数为 0 的情况下，则必然能活
    for (int i = 0; i <= M; i++)
        for (int j = 0; j <= N; j++)
            dpMap[i][j][0] = 1;
    for (int k = 1; k <= K; k++)
        for (int i = 0; i <= M; i++)
            for (int j = 0; j <= N; j++)
            {
                // 值得注意的是，这个过程是有可能越界的，越界的情况肯定活不下来，则直接给 0
                dpMap[i][j][k] += (i - 1 >= 0 ? dpMap[i - 1][j][k - 1] : 0);
                dpMap[i][j][k] += (i + 1 <= M ? dpMap[i + 1][j][k - 1] : 0);
                dpMap[i][j][k] += (j - 1 >= 0 ? dpMap[i][j - 1][k - 1] : 0);
                dpMap[i][j][k] += (j + 1 <= N ? dpMap[i][j + 1][k - 1] : 0);
            }
    // 所有可能情况
    long all = powl(4, K);
    // Bob生存下来的情况
    long live = dpMap[x][y][K];
    long g = gcd(all, live);
    cout << "The probability that Bob stay alive is(Table): " << live / g << "/" << all / g << endl;
}
void main()
{
    BobLive1(8, 6, 5, 5, 15);
    BobLive2(8, 6, 5, 5, 15);
    system("pause");
}
```

### 9.6 找零问题

**问题简述：**令有几种货币面值为 [2, 5, 10, 20]，现在给定目标值为 1000，问有多少种方式可以找零。

**解题思路：**还是非常简单的，只是说多了一个循环的过程，对于 index 位置上的元素，我们可能需要循环多次，以达到多次取同一个元素的效果，这也显著增加了问题的时间复杂度。

**暴力递归：**

``` c plus
// 方案1，暴力递归
int GetChanges1(const vector<int>& arr, const int& aim)
{
    // 特殊情况，没办法找零，值得注意的是对于 aim == 0 的情况，其实这是我们在求解过程中必然出现的 base case 情况
    // 但一开始 aim 就为 0 和最终的 base case 感觉上还是有点区别的
    if (aim < 0 || arr.size() == 0) return 0;
    return GetChanges1_Process(arr, 0, aim);
}
// 值得注意的是，index 表示的是当前选若干 arr[index] 位置上的元素 
int GetChanges1_Process(const vector<int>& arr, const int& index, const int& aim)
{
    // 很典型的一个 base case，值得注意的是下面的值得注意
    if (index == arr.size())
        return aim == 0 ? 1 : 0;
    int count = 0;
    int result = 0;
    while (count * arr[index] <= aim)
        // 值得注意的是，在这个循环位置，我们始终保证 aim >= 0，所以其实不可能出现 aim < 0 的情况，这是一个很好的现象
        result += GetChanges1_Process(arr, index + 1, aim - arr[index] * count++);
    return result;
}
```

**严格表格结构：**

``` c plus
// 方案2，严格表格结构，但不考虑同层之间的逻辑关系，暴力枚举
int GetChanges2(const vector<int>& arr, const int& aim)
{
    // 即横向是当前使用钞票的 index，其有可能达到终止位，所以要 size + 1，纵向变化是 aim 的可能取值，由于我们解释过了，我们剔除了 aim 小于 0 的情况
    vector<vector<int>> dpMap(arr.size() + 1, vector<int>(aim + 1, 0));
    // base case，明显的，在终止位上（不用任何钞票兑换时），aim 为 0 的时候对应元素为 1，否则为 0
    dpMap[arr.size()][0] = 1;
    // 在原始问题中，每一行的元素仅仅依赖于其下一行，同行之间没有依赖关系
    for (int i = arr.size() - 1; i >= 0; i--)
        for (int j = 0; j <= aim; j++)
        {
            // j 其实表示的就是当前位置需要凑出来的 aim 的总数
            int count = 0;
            int result = 0;
            while (j - count * arr[i] >= 0)
            {
                result += dpMap[i + 1][j - count * arr[i]];
                count++;
            }	
            dpMap[i][j] = result;
        }
    return dpMap[0][aim];
}
```

**精细化严格表格结构：**

```  c plus
// 方案3，严格表格结构，考虑同层之间的依赖关系
// 则此时要求计算每一行元素的时候，从左往右计算，斜率优化
int GetChanges3(const vector<int>& arr, const int& aim)
{
    // 即横向是当前使用钞票的 index，其有可能达到终止位，所以要 size + 1，纵向变化是 aim 的可能取值，由于我们解释过了，我们剔除了 aim 小于 0 的情况
    vector<vector<int>> dpMap(arr.size() + 1, vector<int>(aim + 1, 0));
    // base case，明显的，在终止位上（不用任何钞票兑换时），aim 为 0 的时候对应元素为 1，否则为 0
    dpMap[arr.size()][0] = 1;
    // 在原始问题中，每一行的元素仅仅依赖于其下一行，同行之间没有依赖关系
    for (int i = arr.size() - 1; i >= 0; i--)
        for (int j = 0; j <= aim; j++)
            // 刚好，在该问题中，斜率优化的过程就是从左往右的
            // 即同行前一个元素 + 下一行同列元素
            // 值得注意的是，需要先考虑创建第一列的元素，此时不需要加上同行前列（可能不止隔了一列）元素
            dpMap[i][j] = (j - arr[i] < 0 ? 0 : dpMap[i][j - arr[i]]) + dpMap[i + 1][j];
    return dpMap[0][aim];
}
```

**主函数：**

``` c plus
void main()
{
    for (int i = 0; i < 1001; i++)
    {
        vector<int> arr = RandVector(1, 20, 10, true);
		cout << "rand vector " << i << ", the result is: " << GetChanges1(arr, 100) << ", " << GetChanges2(arr, 100) << ", " << GetChanges3(arr, 100) << endl;
    }
    system("pause");
}
```

**时间复杂度分析：**该问题用暴力法和一般的严格表格结构其实时间复杂度都非常之高，而对于不同的 arr 数组，消耗的时间也完全不同，比如如果 arr 里面随机出来一个元素 1，那么问题可能会出现非常多的分支，从而导致运算时间大大增加，则可以看出，三者的时间复杂度为：

**暴力递归法：**$O(aim^{arr.size()})$，看的出来，是一个非常恐怖的数量级，因为每一次递归分支都会拿出来 aim 量级**（大部分情况没这么多，但确实是这个量级）**；

**普通严格表格：**$arr.size() \times aim^2$；

**精细严格表格：**$arr.size() \times aim$。

**如何评价递归的尝试方法：**可变参数的个数和可变参数的维度**（最好是 0 维的，即可变参数是一个数值）**。





